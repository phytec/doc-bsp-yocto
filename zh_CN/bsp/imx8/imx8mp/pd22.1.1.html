

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. PHYTEC 文档 &mdash; PHYTEC BSP Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/code-block.css?v=7a82ee62" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/phytec-theme.css?v=82726be5" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="canonical" href="https://phytec.github.io/doc-bsp-yocto/bsp/imx8/imx8mp/pd22.1.1.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7d86a446"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/translations.js?v=beaddf03"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="Libra i.MX 8M Plus FPSC 手册" href="../imx8mp-fpsc/imx8mp-fpsc.html" />
    <link rel="prev" title="1. PHYTEC 文档" href="pd22.1.2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PHYTEC BSP Documentation
              <img src="../../../_static/logo-phytec.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">BSP Manuals</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../imx8.html">i.MX 8</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="imx8mp.html">phyCORE-i.MX 8M Plus Manuals</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#head">HEAD</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#mainline-head">Mainline HEAD</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#bsp-yocto-nxp-i-mx8mp-pd24-1-0">BSP-Yocto-NXP-i.MX8MP-PD24.1.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#bsp-yocto-ampliphy-i-mx8mp-pd24-1-2">BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#bsp-yocto-ampliphy-i-mx8mp-pd24-1-1">BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#bsp-yocto-nxp-i-mx8mp-pd23-1-0">BSP-Yocto-NXP-i.MX8MP-PD23.1.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx8mp.html#bsp-yocto-nxp-i-mx8mp-pd22-1-2">BSP-Yocto-NXP-i.MX8MP-PD22.1.2</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="imx8mp.html#bsp-yocto-nxp-i-mx8mp-pd22-1-1">BSP-Yocto-NXP-i.MX8MP-PD22.1.1</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">1. PHYTEC 文档</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#supported-hardware">1.1. 支持的硬件</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#getting-started">2. 开始使用</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#get-the-image">2.1. 下载镜像</a></li>
<li class="toctree-l5"><a class="reference internal" href="#write-the-image-to-sd-card">2.2. 将镜像写入SD卡</a></li>
<li class="toctree-l5"><a class="reference internal" href="#first-start-up">2.3. 首次启动</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#building-the-bsp">3. 编译BSP</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#basic-set-up">3.1. 基本设置</a></li>
<li class="toctree-l5"><a class="reference internal" href="#get-the-bsp">3.2. 下载BSP</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#installing-the-os">4. 安装操作系统</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#bootmode-switch-s3">4.1. 启动模式开关 (S3)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#flash-emmc">4.2. 烧写eMMC</a></li>
<li class="toctree-l5"><a class="reference internal" href="#flash-spi-nor-flash">4.3. 烧写 SPI NOR Flash</a></li>
<li class="toctree-l5"><a class="reference internal" href="#rauc">4.4. RAUC</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#development">5. 开发</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#host-network-preparation">5.1. 主机网络准备</a></li>
<li class="toctree-l5"><a class="reference internal" href="#booting-the-kernel-from-a-network">5.2. 从网络启动内核</a></li>
<li class="toctree-l5"><a class="reference internal" href="#working-with-uuu-tool">5.3. 使用UUU工具</a></li>
<li class="toctree-l5"><a class="reference internal" href="#standalone-build-preparation">5.4. 独立编译准备</a></li>
<li class="toctree-l5"><a class="reference internal" href="#u-boot-standalone-build">5.5. 单独编译U-Boot</a></li>
<li class="toctree-l5"><a class="reference internal" href="#kernel-standalone-build">5.6. 单独编译内核</a></li>
<li class="toctree-l5"><a class="reference internal" href="#accessing-the-development-states">5.7. 获取BSP开发中版本</a></li>
<li class="toctree-l5"><a class="reference internal" href="#accessing-the-latest-upstream-support">5.8. 获取最新的Upstream支持</a></li>
<li class="toctree-l5"><a class="reference internal" href="#format-sd-card">5.9. Format SD card</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#device-tree-dt">6. 设备树 (DT)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#introduction">6.1. 介绍</a></li>
<li class="toctree-l5"><a class="reference internal" href="#phytec-soc-bsp-device-tree-concept">6.2. PHYTEC i.MX 8M Plus BSP设备树概念</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-peripherals">7. 访问外设</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#soc-pin-muxing">7.1. i.MX 8M Plus 引脚复用</a></li>
<li class="toctree-l5"><a class="reference internal" href="#rs232-rs485">7.2. RS232/RS485</a></li>
<li class="toctree-l5"><a class="reference internal" href="#ethernet">7.3. Ethernet</a></li>
<li class="toctree-l5"><a class="reference internal" href="#wlan-bluetooth">7.4. WLAN/Bluetooth</a></li>
<li class="toctree-l5"><a class="reference internal" href="#bluetooth">7.5. 蓝牙</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sd-card">7.6. SD card</a></li>
<li class="toctree-l5"><a class="reference internal" href="#emmc-devices">7.7. eMMC设备</a></li>
<li class="toctree-l5"><a class="reference internal" href="#spi-master">7.8. SPI主设备</a></li>
<li class="toctree-l5"><a class="reference internal" href="#gpios">7.9. GPIOs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#leds">7.10. LED灯</a></li>
<li class="toctree-l5"><a class="reference internal" href="#i2c-bus">7.11. I²C总线</a></li>
<li class="toctree-l5"><a class="reference internal" href="#eeprom">7.12. EEPROM</a></li>
<li class="toctree-l5"><a class="reference internal" href="#rtc">7.13. RTC</a></li>
<li class="toctree-l5"><a class="reference internal" href="#usb-host-controller">7.14. USB主控制器</a></li>
<li class="toctree-l5"><a class="reference internal" href="#can-fd">7.15. CAN FD</a></li>
<li class="toctree-l5"><a class="reference internal" href="#pcie">7.16. PCIe</a></li>
<li class="toctree-l5"><a class="reference internal" href="#audio">7.17. 音频</a></li>
<li class="toctree-l5"><a class="reference internal" href="#video">7.18. 视频</a></li>
<li class="toctree-l5"><a class="reference internal" href="#display">7.19. 显示</a></li>
<li class="toctree-l5"><a class="reference internal" href="#power-management">7.20. 电源管理</a></li>
<li class="toctree-l5"><a class="reference internal" href="#thermal-management">7.21. 热管理</a></li>
<li class="toctree-l5"><a class="reference internal" href="#watchdog">7.22. 看门狗</a></li>
<li class="toctree-l5"><a class="reference internal" href="#snvs-power-key">7.23. snvs电源按键</a></li>
<li class="toctree-l5"><a class="reference internal" href="#npu">7.24. NPU</a></li>
<li class="toctree-l5"><a class="reference internal" href="#isp">7.25. ISP</a></li>
<li class="toctree-l5"><a class="reference internal" href="#on-chip-otp-controller-ocotp-ctrl-efuses">7.26. 片上一次性可编程控制器 (OCOTP_CTRL) - eFuse</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#soc-mcore">8. i.MX 8M Plus M7 Core</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#getting-the-firmware-examples">8.1. 获取固件示例</a></li>
<li class="toctree-l5"><a class="reference internal" href="#running-mcore-examples">8.2. 运行 M7 Core 示例</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#bsp-extensions">9. BSP扩展</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#chromium">9.1. Chromium</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../imx8mp-fpsc/imx8mp-fpsc.html">phyCORE-i.MX 8M Plus FPSC Manuals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../imx8mm/imx8mm.html">phyCORE-i.MX 8M Mini Manuals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../imx8mn/imx8mn.html">phyCORE-i.MX 8M Nano Manuals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../imx9/imx9.html">i.MX 9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../am6x/am6x.html">AM6X</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Yocto Manuals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../yocto/manual-index.html">Unstable (dev)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../yocto/manual-index.html#kirkstone">Kirkstone</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../yocto/manual-index.html#mickledore">Mickledore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../yocto/manual-index.html#scarthgap">Scarthgap</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application Manuals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rauc/manual-index.html">RAUC Update &amp; Device Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/manual-index.html">Security Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coprocessor/index.html">Coprocessor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">贡献</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing_links.html">贡献</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PHYTEC BSP Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../imx8.html">i.MX 8</a></li>
          <li class="breadcrumb-item"><a href="imx8mp.html">i.MX 8M Plus 手册</a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>PHYTEC 文档</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/phytec/doc-bsp-yocto/blob/main/source/bsp/imx8/imx8mp/pd22.1.1.rst" class="fa fa-github"> 在 GitHub 上编辑</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>pdf格式的文档： <a class="reference external" href="../../../_static/imx8mp-pd22.1.1.pdf">下载</a></p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td colspan="2"><p>i.MX 8M Plus BSP手册</p></td>
</tr>
<tr class="row-even"><td><p>文档标题</p></td>
<td><p>i.MX 8M Plus BSP手册</p></td>
</tr>
<tr class="row-odd"><td><p>文档类型</p></td>
<td><p>BSP 手册</p></td>
</tr>
<tr class="row-even"><td><p>Yocto 手册</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>发布日期</p></td>
<td><p>2023/05/25</p></td>
</tr>
<tr class="row-even"><td><p>母文档</p></td>
<td><p>i.MX 8M Plus BSP手册</p></td>
</tr>
</tbody>
</table>
<p>下表显示了与本手册兼容的 BSP：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>适用BSP</p></th>
<th class="head"><p>BSP 发布类型</p></th>
<th class="head"><p>BSP 发布日期</p></th>
<th class="head"><p>BSP 状态</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BSP-Yocto-NXP-i.MX8MP-PD22.1.1</p></td>
<td><p>小更新</p></td>
<td><p>2023/05/23</p></td>
<td><p>已发布</p></td>
</tr>
</tbody>
</table>
<p>本手册指导您完成BSP包的安装、编译和烧写，并描述如何使用 <strong>phyCORE-i.MX8M Plus Kit</strong> 的硬件接口。本手册还包括如何从源码编译内核、u-boot镜像。本手册包含需要在PC(Linux操作系统)上执行的指令。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>本文档包含指令示例，描述如何在串口终端上与核心板进行交互。指令示例以“host:~$”、“target:~$”或“u-boot=&gt;”开头，开头的这些关键字描述了指令执行的软件环境。如果需要复制这些指令，请仅复制这些关键字之后的内容。</p>
</div>
<section id="phytec-documentation">
<h1><span class="section-number">1. </span>PHYTEC 文档<a class="headerlink" href="#phytec-documentation" title="Link to this heading"></a></h1>
<p>PHYTEC provides a variety of hardware and software documentation for
all of its products. This includes any or all of the following:</p>
<ul class="simple">
<li><p><strong>QS Guide</strong>: A short guide on how to set up and boot a phyCORE based
board.</p></li>
<li><p><strong>Hardware Manual</strong>: A detailed description of the System-on-Module and
accompanying carrierboard.</p></li>
<li><p><strong>Yocto 指南</strong>：phyCORE 使用的 Yocto 版本的综合指南。本指南包含: Yocto 概述；PHYTEC BSP 介绍、编译和定制化修改；如何使用 Poky 和 Bitbake 等编译框架。</p></li>
<li><p><strong>BSP 手册</strong>：phyCORE 的 BSP 版本专用手册。可在此处找到如何编译BSP、启动、更新软件、设备树和外设等信息。</p></li>
<li><p><strong>开发环境指南</strong>：本指南介绍了如何使用 PHYTEC 虚拟机来搭建多样的开发环境。VM 中包含了 Eclipse 和 Qt Creator 的详细上手指导，还说明了如何将所编译出的demo程序放到phyCORE 核心板上运行。本指南同时也介绍了如何在本地Linux ubuntu上搭建完整的开发环境。</p></li>
<li><p><strong>引脚复用表</strong>：phyCORE 核心板附带一个引脚复用表（Excel 格式）。此表将显示从处理器到底板的信号连接以及默认的设备树复用选项。这为开发人员进行引脚复用和设计提供了必要的信息。</p></li>
</ul>
<p>除了这些标准手册和指南之外，PHYTEC 还将提供产品变更通知、应用说明和技术说明。这些文档将根据具体案例进行针对性提供。大部分文档都可以在我们产品的 <a class="reference external" href="https://www.phytec.de/produkte/system-on-modules/phycore-imx-8m-plus/#downloads">https://www.phytec.de/produkte/system-on-modules/phycore-imx-8m-plus/#downloads</a> 中找到。</p>
<section id="supported-hardware">
<h2><span class="section-number">1.1. </span>支持的硬件<a class="headerlink" href="#supported-hardware" title="Link to this heading"></a></h2>
<p>在我们的网页上，您可以查看适用于BSP版本 BSP-Yocto-NXP-i.MX8MP-PD22.1.1 的所有Machine及其对应的Article Numbers(产品型号)： <a class="reference external" href="https://www.phytec.de/bsp-download/?bsp=BSP-Yocto-NXP-i.MX8MP-PD22.1.1">网页</a>.</p>
<p>如果您在“Supported Machines”一栏选择了特定的 <strong>Machine Name</strong> ，您可以查看该machine下可用的 <strong>Article Numbers</strong> 以及硬件信息的简短描述。如果您只有硬件的 <strong>Article Numbers</strong> ，您可以将 <strong>Machine Name</strong> 下拉菜单留空，仅选择您的 <strong>Article Numbers</strong> 。现在，它应该会显示您特定硬件所需的 <strong>Machine Name</strong></p>
<section id="sbc-components">
<span id="imx8mp-pd22-1-1-components"></span><h3><span class="section-number">1.1.1. </span>phyBOARD-Pollux 器件<a class="headerlink" href="#sbc-components" title="Link to this heading"></a></h3>
<figure class="align-center" id="id4">
<a class="reference internal image-reference" href="../../../_images/phyBOARD-Pollux-front-components.jpg"><img alt="../../../_images/phyBOARD-Pollux-front-components.jpg" src="../../../_images/phyBOARD-Pollux-front-components.jpg" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-text"><strong>phyBOARD-Pollux 器件图（顶部）</strong></span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id5">
<a class="reference internal image-reference" href="../../../_images/phyBOARD-Pollux-back-components.jpg"><img alt="../../../_images/phyBOARD-Pollux-back-components.jpg" src="../../../_images/phyBOARD-Pollux-back-components.jpg" style="width: 85%;" />
</a>
<figcaption>
<p><span class="caption-text"><strong>phyBOARD-Pollux 器件图（底部）</strong></span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="getting-started">
<h1><span class="section-number">2. </span>开始使用<a class="headerlink" href="#getting-started" title="Link to this heading"></a></h1>
<p>该 <strong>phyCORE-i.MX8M Plus Kit</strong> 包含预先烧写好的SD卡。它包含 phytec-qt5demo-image ，可以直接用作启动盘。默认情况下，核心板的eMMC仅烧写了U-boot。您可以从 <a class="reference external" href="https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/">PHYTEC下载服务器</a> 获取所有源代码。本章解释了如何将BSP镜像烧录到SD卡以及如何启动开发板。</p>
<section id="get-the-image">
<h2><span class="section-number">2.1. </span>下载镜像<a class="headerlink" href="#get-the-image" title="Link to this heading"></a></h2>
<p>WIC镜像包含预先格式化的分区信息以及分区中包含的BSP文件，可以使用单个Linux命令 <code class="docutils literal notranslate"><span class="pre">dd</span></code> 轻松写入到SD卡上。WIC镜像可以通过Yocto编译或从PHYTEC下载服务器下载。</p>
<p>从下载服务器获取WIC文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>wget<span class="w"> </span>https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic
</pre></div>
</div>
</section>
<section id="write-the-image-to-sd-card">
<h2><span class="section-number">2.2. </span>将镜像写入SD卡<a class="headerlink" href="#write-the-image-to-sd-card" title="Link to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>要使用 <code class="docutils literal notranslate"><span class="pre">dd</span></code> 命令创建SD卡启动盘，您必须具有root权限。在使用 <code class="docutils literal notranslate"><span class="pre">dd</span></code> 指定目标设备时请务必小心！所选设备上的所有文件将在命令执行后立即被擦除，而且擦除前不会有任何进一步的确认！</p>
<p>选择错误的设备可能会导致 <strong>数据丢失</strong> ，例如，可能会擦除您当前所在PC上的系统！</p>
</div>
<p>要创建SD卡启动盘，首先要找到PC上您SD卡对应的正确设备名称。在开始将镜像复制到SD卡之前，请卸载任何已挂载的分区。</p>
<ol class="arabic">
<li><p>为了获取正确的设备名称，请移除您的SD卡并执行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ lsblk
</pre></div>
</div>
</li>
<li><p>现在插入你的SD卡，然后再次执行该命令：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ lsblk
</pre></div>
</div>
</li>
<li><p>比较两个输出，以获取第二个输出中的新设备名称。这些是SD卡的设备名称（如果SD卡已格式化，则包括设备名称和对应的分区）。</p></li>
<li><p>为了验证找到的设备名称的最终正确性，请执行命令 <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">dmesg</span></code>。在其输出的最后几行中，您应该也能找到设备名称，例如 <code class="docutils literal notranslate"><span class="pre">/dev/sde</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/dev/mmcblk0</span></code> （具体取决于您的系统）。</p></li>
</ol>
<p>或者，您可以使用图形化的程序，例如 <a class="reference external" href="https://apps.gnome.org/en/DiskUtility/">GNOME Disks</a> 或 <a class="reference external" href="https://apps.kde.org/partitionmanager/">KDE Partition Manager</a> 来找到正确的设备。</p>
<p>现在您已经得到了正确的设备名称，例如 <code class="docutils literal notranslate"><span class="pre">/dev/sde</span></code>，如果SD卡曾格式化过，需要确认已取消其分区的挂载，您可以在输出中看到带有附加了数字的设备名称（例如 <code class="docutils literal notranslate"><span class="pre">/dev/sde1</span></code>），它们是SD卡的分区。一些Linux发行版系统在设备插入时会自动挂载分区。在写入之前，必须卸载这些分区，以避免数据损坏。</p>
<ul>
<li><p>卸载所有分区，例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ sudo umount /dev/sde1
</pre></div>
</div>
</li>
<li><p>在卸载所有分区后，您可以创建SD卡启动盘：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ sudo dd if=&lt;IMAGENAME&gt;-&lt;MACHINE&gt;.wic of=/dev/sdX bs=1M conv=fsync status=progress
</pre></div>
</div>
<p>再次确保将 <code class="docutils literal notranslate"><span class="pre">/dev/sdX</span></code> 替换为之前找到的设备名称。</p>
<p>参数 <code class="docutils literal notranslate"><span class="pre">conv=fsync</span></code> 强制在 <code class="docutils literal notranslate"><span class="pre">dd</span></code> 返回之前对设备进行sync操作。这确保所有数据块都已写入SD卡，而没有任何数据缓存在内存中。参数 <code class="docutils literal notranslate"><span class="pre">status=progress</span></code> 将打印出进度信息。</p>
</li>
</ul>
<p>准备SD卡启动盘的另一种更快的方法是使用Intel的 <a class="reference external" href="https://github.com/intel/bmap-tools">bmap-tools</a> 。Yocto会自动为WIC镜像创建一个block map文件（ <code class="docutils literal notranslate"><span class="pre">&lt;IMAGENAME&gt;-&lt;MACHINE&gt;.wic.bmap</span></code> ），该文件描述了镜像内容并包含数据完整性的校验。 <em>bmaptool</em> 已被多种Linux发行版支持。对于基于Debian的系统，可以通过以下命令安装：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ sudo apt install bmap-tools
</pre></div>
</div>
<p>通过以下命令将WIC镜像烧写到SD卡：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ bmaptool copy &lt;IMAGENAME&gt;-&lt;MACHINE&gt;.wic /dev/&lt;your_device&gt;
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><em>bmaptool</em> 仅擦写SD卡上镜像数据所在的区域。这意味着在写入新的镜像后，之前写入的旧U-Boot环境变量可能仍然可用。</p>
</div>
</section>
<section id="first-start-up">
<h2><span class="section-number">2.3. </span>首次启动<a class="headerlink" href="#first-start-up" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>要从SD卡启动， <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 需要设置为以下位置：</p></li>
</ul>
<img alt="../../../_images/SD_Card_Boot3.png" src="../../../_images/SD_Card_Boot3.png" />
<ul class="simple">
<li><p>插入SD卡</p></li>
<li><p>Connect the target and the host with <strong>micro USB</strong> on <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">(X1)</span></a>
debug USB</p></li>
<li><p>给开发板通电</p></li>
</ul>
</section>
</section>
<section id="building-the-bsp">
<h1><span class="section-number">3. </span>编译BSP<a class="headerlink" href="#building-the-bsp" title="Link to this heading"></a></h1>
<p>本节将指导您使用Yocto和phyLinux脚本进行 i.MX 8M Plus BSP的编译。更多有关phytec meta-layer和Yocto的信息，请访问： L-813e.A12 Yocto Reference Manual (Hardknott) 。</p>
<section id="basic-set-up">
<h2><span class="section-number">3.1. </span>基本设置<a class="headerlink" href="#basic-set-up" title="Link to this heading"></a></h2>
<p>如果您从未在您的主机上使用Yocto编译过Phytec BSP，您应查看 L-813e.A12 Yocto Reference Manual (Hardknott) 中的BSP Workspace安装一节。</p>
</section>
<section id="get-the-bsp">
<h2><span class="section-number">3.2. </span>下载BSP<a class="headerlink" href="#get-the-bsp" title="Link to this heading"></a></h2>
<p>获取BSP有两种方式。您可以从我们的下载页面下载完整的BSP镜像： <a class="reference external" href="https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/">BSP-Yocto-IMX8MP</a> ；您也可以使用Yocto下载BSP工程并编译。如果您想要对BSP进行修改，建议使用第二种方式。</p>
<p>The phyLinux script is a basic management tool for PHYTEC Yocto BSP releases
written in Python. It is mainly a helper to get started with the BSP sources
structure.</p>
<ul>
<li><p>创建一个新的项目文件夹，获取phyLinux脚本，并赋予脚本具备可执行权限：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>mkdir<span class="w"> </span>~/yocto
<span class="gp">host:~$ </span><span class="nb">cd</span><span class="w"> </span>yocto/
<span class="gp">host:~/yocto$ </span>wget<span class="w"> </span>https://download.phytec.de/Software/Linux/Yocto/Tools/phyLinux
<span class="gp">host:~/yocto$ </span>chmod<span class="w"> </span>+x<span class="w"> </span>phyLinux
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>我们需要一个空的项目文件夹，phyLinux首先会清理当前所在的工作目录。从一个不为空的目录下调用phyLinux将会产生告警。</p>
</div>
</li>
<li><p>运行phyLinux：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto$ </span>./phyLinux<span class="w"> </span>init
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在首次初始化时，phyLinux脚本会要求您在 <code class="docutils literal notranslate"><span class="pre">/usr/local/bin</span></code> 目录中安装Repo工具。</p>
</div>
</li>
<li><p>在执行init命令时，您需要选择您的处理器平台（SoC）、PHYTEC的BSP版本号以及您正在使用的硬件。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您无法根据菜单中提供的信息识别您的开发板，请查看产品的发票。并查看  <a class="reference external" href="https://www.phytec.de/bsp-download/?bsp=BSP-Yocto-NXP-i.MX8MP-PD22.1.1">our BSP</a> 。</p>
</div>
</li>
<li><p>也可以通过命令行参数直接传递这些信息：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto$ </span><span class="nv">DISTRO</span><span class="o">=</span>ampliphy-vendor-xwayland<span class="w"> </span><span class="nv">MACHINE</span><span class="o">=</span>phyboard-pollux-imx8mp-3<span class="w"> </span>./phyLinux<span class="w"> </span>init<span class="w"> </span>-p<span class="w"> </span>imx8mp<span class="w"> </span>-r<span class="w"> </span>BSP-Yocto-NXP-i.MX8MP-PD22.1.1
</pre></div>
</div>
</li>
</ul>
<p>After the execution of the init command, phyLinux will print a few important
notes. For example, it will print your git identity, SOC and BSP release which
was selected as well as information for the next steps in the build process.</p>
<section id="starting-the-build-process">
<h3><span class="section-number">3.2.1. </span>开始构建<a class="headerlink" href="#starting-the-build-process" title="Link to this heading"></a></h3>
<ul>
<li><p>设置Shell环境变量：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto$ </span><span class="nb">source</span><span class="w"> </span>sources/poky/oe-init-build-env
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在每次打开新的用于编译的shell时，都需要先执行这一步骤。</p>
</div>
</li>
<li><p>当前的工作目录会变更为 build/。</p></li>
<li><p>打开主配置文件，同意并接受GPU和VPU二进制文件的许可证协议。通过取消注释相应的行来完成此操作，如下所示。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto/build$ </span>vim<span class="w"> </span>conf/local.conf
<span class="gp"># </span>Uncomment<span class="w"> </span>to<span class="w"> </span>accept<span class="w"> </span>NXP<span class="w"> </span>EULA
<span class="gp"># </span>EULA<span class="w"> </span>can<span class="w"> </span>be<span class="w"> </span>found<span class="w"> </span>under<span class="w"> </span>../sources/meta-freescale/EULA
<span class="go">ACCEPT_FSL_EULA = &quot;1&quot;</span>
</pre></div>
</div>
</li>
<li><p>编译您的镜像：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto/build$ </span>bitbake<span class="w"> </span>phytec-qt5demo-image
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于第一次编译，我们建议从我们的较小的非图形化镜像phytec-headless-image开始，以查看一切是否正常工作。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/yocto/build$ </span>bitbake<span class="w"> </span>phytec-headless-image
</pre></div>
</div>
<p>第一次构建过程在现代的Intel Core i7处理器上大约需要40分钟。后续的构建将使用本次编译产生的缓存，大约需要3分钟。</p>
</div>
</li>
</ul>
</section>
<section id="bsp-images">
<h3><span class="section-number">3.2.2. </span>BSP镜像<a class="headerlink" href="#bsp-images" title="Link to this heading"></a></h3>
<p>所有由Bitbake生成的镜像都放在 <code class="docutils literal notranslate"><span class="pre">~/yocto/build/deploy*/images/&lt;machine&gt;</span></code> 。例如以下列表是 phyboard-pollux-imx8mp-3 machine生成的所有文件：</p>
<ul class="simple" id="imx8mp-pd22-1-1-images">
<li><p><strong>u-boot.bin</strong>: 编译后的U-boot bootloader二进制文件。不是最终镜像中的bootloader！</p></li>
<li><p><strong>oftree</strong>: 默认内核设备树</p></li>
<li><p><strong>u-boot-spl.bin</strong>: 二级程序加载器 (SPL)</p></li>
<li><p><strong>bl31-imx8mp.bin</strong>: ARM可信固件二进制文件</p></li>
<li><p><strong>lpddr4_pmu_train_2d_dmem_202006.bin, lpddr4_pmu_train_2d_imem_202006.bin</strong>: DDR PHY固件镜像</p></li>
<li><p><strong>imx-boot</strong>：由imx-mkimage编译的bootloader镜像，包括SPL、U-Boot、ARM可信固件和DDR固件。这是最终的可引导bootloader镜像。</p></li>
<li><p><strong>Image</strong>: Linux内核镜像</p></li>
<li><p><strong>Image.config</strong>: 内核config文件</p></li>
<li><p><strong>imx8mp-phyboard-pollux-rdk*.dtb</strong>: 内核设备树文件</p></li>
<li><p><strong>imx8mp-phy*.dtbo</strong>: 内核设备树overlay文件</p></li>
<li><p><strong>phytec-qt5demo-image*.tar.gz</strong>: 根文件系统</p></li>
<li><p><strong>phytec-qt5demo-image*.wic</strong>: SD卡镜像</p></li>
</ul>
</section>
</section>
</section>
<section id="installing-the-os">
<h1><span class="section-number">4. </span>安装操作系统<a class="headerlink" href="#installing-the-os" title="Link to this heading"></a></h1>
<section id="bootmode-switch-s3">
<h2><span class="section-number">4.1. </span>启动模式开关 (S3)<a class="headerlink" href="#bootmode-switch-s3" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>硬件修订版底板：1552.2</p>
</div>
<p>The phyBOARD-Pollux features a boot switch with four individually switchable ports to
select the phyCORE-i.MX 8M Plus default bootsource.</p>
<table class="docutils align-default" id="imx8mp-pd22-1-1-bootswitch">
<tbody>
<tr class="row-odd"><td><figure class="align-default" id="id6">
<img alt="../../../_images/eMMC3.png" src="../../../_images/eMMC3.png" />
<figcaption>
<p><span class="caption-text">eMMC</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id7">
<img alt="../../../_images/Internal_Fuses2.png" src="../../../_images/Internal_Fuses2.png" />
<figcaption>
<p><span class="caption-text">内部fuse</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id8">
<img alt="../../../_images/SPI_NOR3.png" src="../../../_images/SPI_NOR3.png" />
<figcaption>
<p><span class="caption-text">SPI NOR</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
</tr>
<tr class="row-even"><td><figure class="align-default" id="id9">
<img alt="../../../_images/USB_Serial_Download3.png" src="../../../_images/USB_Serial_Download3.png" />
<figcaption>
<p><span class="caption-text">USB</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id10">
<img alt="../../../_images/SD_Card_Boot3.png" src="../../../_images/SD_Card_Boot3.png" />
<figcaption>
<p><span class="caption-text">SD卡</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id11">
<img alt="../../../_images/Test_Mode.png" src="../../../_images/Test_Mode.png" />
<figcaption>
<p><span class="caption-text">测试模式</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
</section>
<section id="flash-emmc">
<h2><span class="section-number">4.2. </span>烧写eMMC<a class="headerlink" href="#flash-emmc" title="Link to this heading"></a></h2>
<p>要从eMMC启动，请确保BSP镜像已正确烧录到eMMC，并且 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 设置为 <strong>默认SOM启动</strong> 。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当eMMC和SD卡上烧录了相同（完全一致）的镜像时，他们boot分区的UUID也是相同的。所以如果从emmc启动时，烧录一致镜像的SD卡也同时存在，这会导致不确定的后果，因为Linux会根据UUID来挂载启动分区。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>blkid
</pre></div>
</div>
<p>可以运行上述命令来检查系统启动在这种条件下是否会到影响。如果 <code class="docutils literal notranslate"><span class="pre">mmcblk2p1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mmcblk1p1</span></code> 具有相同的UUID，则会影响系统正确启动。</p>
</div>
<section id="flash-emmc-from-network">
<h3><span class="section-number">4.2.1. </span>从网络烧写 eMMC<a class="headerlink" href="#flash-emmc-from-network" title="Link to this heading"></a></h3>
<p>i.MX 8M Plus 开发板具有以太网连接器，可以通过网络进行更新。确保正确设置主机，主机的IP需要设置为192.168.3.10，子网掩码为255.255.255.0，并且需要在主机开启TFTP服务。抽象来看，eMMC设备和SD卡十分类似。因此，可以直接将Yocto生成的 <strong>WIC镜像</strong> （ <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;.wic</span></code> ）直接烧写到eMMC。该镜像包含bootloader、内核、设备树、设备树overlay和根文件系统。</p>
<section id="flash-emmc-from-network-in-u-boot-on-target">
<h4><span class="section-number">4.2.1.1. </span>在开发板的u-boot环境中从网络烧写eMMC<a class="headerlink" href="#flash-emmc-from-network-in-u-boot-on-target" title="Link to this heading"></a></h4>
<p>这些步骤将展示如何通过网络更新eMMC。然而，此步骤仅在镜像文件小于1GB的情况下会被执行成功。如果镜像文件更大，请转到“格式化SD卡”一节。配置 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 以从SD卡启动，并插入一张SD卡。给开发板上电并进入U-Boot环境。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>需要保证设备和存储镜像的主机之间的网络正常！ <a class="reference internal" href="#imx8mp-pd22-1-1-development"><span class="std std-ref">Setup Network Host</span></a></p>
</div>
<ul>
<li><p>通过网络将您的镜像加载到内存中：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; tftp ${loadaddr} phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic
Using ethernet@30be0000 device
TFTP from server 192.168.3.10; our IP address is 192.168.3.11
Filename &#39;phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic&#39;.
Load address: 0x40480000
Loading: ######################################
         ######################################
         ######################################
         ...
         ...
         ...
         ######################################
         #############
         11.2 MiB/s
done
Bytes transferred = 911842304 (36599c00 hex)
</pre></div>
</div>
</li>
<li><p>将镜像写入eMMC：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; mmc dev 2
switch to partitions #0, OK
mmc2(part 0) is current device
u-boot=&gt; setexpr nblk ${filesize} / 0x200
u-boot=&gt; mmc write ${loadaddr} 0x0 ${nblk}

MMC write: dev # 2, block # 0, count 1780942 ... 1780942 blocks written: OK
</pre></div>
</div>
</li>
</ul>
</section>
<section id="flash-emmc-via-network-in-linux-on-target">
<h4><span class="section-number">4.2.1.2. </span>在开发板的Linux系统中通过网络烧写eMMC<a class="headerlink" href="#flash-emmc-via-network-in-linux-on-target" title="Link to this heading"></a></h4>
<p>您可以在开发板系统中更新eMMC。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>需要保证设备和存储镜像的主机之间的网络正常！设置主机网络。</p>
</div>
<p>使用一条命令，通过网络ssh协议将带有块映射的压缩或未压缩的镜像发送到开发板的eMMC上使用,执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ssh<span class="w"> </span>&lt;USER&gt;@192.168.3.10<span class="w"> </span><span class="s2">&quot;dd if=&lt;path_to_file&gt;/phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>dd<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2
</pre></div>
</div>
</section>
<section id="flash-emmc-via-network-in-linux-on-host">
<h4><span class="section-number">4.2.1.3. </span>在Linux主机上通过网络烧写 eMMC<a class="headerlink" href="#flash-emmc-via-network-in-linux-on-host" title="Link to this heading"></a></h4>
<p>可以在您的Linux主机上将镜像烧写到eMMC。和之前一样，您需要在主机上准备一个完整的镜像。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>需要保证设备和存储镜像的主机之间的网络正常！设置主机网络。</p>
</div>
<p>查看主机上可用的镜像文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>ls
<span class="go">phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic</span>
</pre></div>
</div>
<p>通过网络使用ssh将镜像用dd命令发送到您设备的eMMC：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic<span class="w"> </span><span class="nv">status</span><span class="o">=</span>progress<span class="w"> </span><span class="p">|</span><span class="w"> </span>ssh<span class="w"> </span>root@192.168.3.11<span class="w"> </span><span class="s2">&quot;dd of=/dev/mmcblk2&quot;</span>
</pre></div>
</div>
</section>
</section>
<section id="flash-emmc-u-boot-image-via-network-from-running-u-boot">
<h3><span class="section-number">4.2.2. </span>在u-boot中通过网络烧写eMMC u-boot镜像<a class="headerlink" href="#flash-emmc-u-boot-image-via-network-from-running-u-boot" title="Link to this heading"></a></h3>
<p>如果eMMC上的bootloader位于eMMC的User区，从u-boot中更新独立的u-boot镜像imx-boot也是可能的。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>需要保证设备和存储镜像的主机之间的网络正常！设置主机网络。</p>
</div>
<p>通过tftp将镜像加载到RAM中，然后写入eMMC：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; tftp ${loadaddr} imx-boot
u-boot=&gt; setexpr nblk ${filesize} / 0x200
u-boot=&gt; mmc dev 2
u-boot=&gt; mmc write ${loadaddr} 0x40 ${nblk}
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>十六进制值表示偏移量，单位为512字节块的倍数。请参阅 <a class="reference external" href="#offset-table">偏移表</a> 以获取相应SoC的正确值。</p>
</div>
</section>
<section id="flash-emmc-from-usb">
<h3><span class="section-number">4.2.3. </span>从USB烧写eMMC<a class="headerlink" href="#flash-emmc-from-usb" title="Link to this heading"></a></h3>
<section id="flash-emmc-from-usb-in-u-boot-on-target">
<h4><span class="section-number">4.2.3.1. </span>在u-boot上从USB烧写eMMC<a class="headerlink" href="#flash-emmc-from-usb-in-u-boot-on-target" title="Link to this heading"></a></h4>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>此步骤仅在镜像文件大小小于1GB时有效，因为在启用OPTEE后，Bootloader中可用的RAM大小有限。</p>
</div>
<p>下面这些步骤展示如何通过USB设备更新eMMC。将启动模式开关配置为 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 并插入SD卡。给开发板上电并进入U-Boot环境。将已存储了未压缩WIC镜像的优盘插入开发板USB接口。</p>
<p>将镜像从USB设备加载到RAM中：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; usb start
starting USB...
USB0:   USB EHCI 1.00
scanning bus 0 for devices... 2 USB Device(s) found
       scanning usb for storage devices... 1 Storage Device(s) found
u-boot=&gt; fatload usb 0:1 ${loadaddr} *.wic
497444864 bytes read in 31577 ms (15 MiB/s)
</pre></div>
</div>
<p>将镜像写入eMMC：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; mmc dev 2
switch to partitions #0, OK
mmc2(part 0) is current device
u-boot=&gt; setexpr nblk ${filesize} / 0x200
u-boot=&gt; mmc write ${loadaddr} 0x0 ${nblk}

MMC write: dev # 2, block # 0, count 1024000 ... 1024000 blocks written: OK
u-boot=&gt; boot
</pre></div>
</div>
</section>
<section id="flash-emmc-from-usb-in-linux">
<h4><span class="section-number">4.2.3.2. </span>在运行的Linux系统中从USB烧写eMMC<a class="headerlink" href="#flash-emmc-from-usb-in-linux" title="Link to this heading"></a></h4>
<p>下面这些步骤展示如何在Linux系统上使用USB大容量存储设备烧写eMMC。您需要一个保存了完整镜像的U盘和一个可从SD卡启动的核心板（例如 phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic）。将引导模式开关设置为 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a>。</p>
<ul>
<li><p>插入并挂载U盘：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[   60.458908] usb-storage 1-1.1:1.0: USB Mass Storage device detected</span>
<span class="go">[   60.467286] scsi host0: usb-storage 1-1.1:1.0</span>
<span class="go">[   61.504607] scsi 0:0:0:0: Direct-Access                               8.07 PQ: 0 ANSI: 2</span>
<span class="go">[   61.515283] sd 0:0:0:0: [sda] 3782656 512-byte logical blocks: (1.94 GB/1.80 GiB)</span>
<span class="go">[   61.523285] sd 0:0:0:0: [sda] Write Protect is off</span>
<span class="go">[   61.528509] sd 0:0:0:0: [sda] No Caching mode page found</span>
<span class="go">[   61.533889] sd 0:0:0:0: [sda] Assuming drive cache: write through</span>
<span class="go">[   61.665969]  sda: sda1</span>
<span class="go">[   61.672284] sd 0:0:0:0: [sda] Attached SCSI removable disk</span>
<span class="gp">target:~$ </span>mount<span class="w"> </span>/dev/sda1<span class="w"> </span>/mnt
</pre></div>
</div>
</li>
<li><p>现在查看您在USB优盘上保存的镜像文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">cd</span><span class="w"> </span>/mnt
<span class="gp">target:~$ </span>ls
<span class="go">phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic</span>
</pre></div>
</div>
</li>
<li><p>显示可用的MMC设备列表：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ls<span class="w"> </span>/dev<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>mmc
<span class="go">mmcblk1</span>
<span class="go">mmcblk1p1</span>
<span class="go">mmcblk1p2</span>
<span class="go">mmcblk2</span>
<span class="go">mmcblk2boot0</span>
<span class="go">mmcblk2boot1</span>
<span class="go">mmcblk2p1</span>
<span class="go">mmcblk2p2</span>
<span class="go">mmcblk2rpmb</span>
</pre></div>
</div>
</li>
<li><p>eMMC设备的特征是它包含两个boot分区：(mmcblk2boot0; mmcblk2boot1)</p></li>
<li><p>Write the image to the phyCORE-i.MX 8M Plus eMMC (MMC device 2 without partition):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2
</pre></div>
</div>
</li>
<li><p>在完成写入后，您的开发板可以从eMMC启动。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在此之前，您需要将启动配置开关配置 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 设置为 <strong>默认SOM启动</strong>。</p>
</div>
</section>
</section>
<section id="flash-emmc-from-sd-card">
<h3><span class="section-number">4.2.4. </span>从SD卡烧写eMMC<a class="headerlink" href="#flash-emmc-from-sd-card" title="Link to this heading"></a></h3>
<p>即使没有可用的网络，您也可以更新eMMC。为此，您需要一个位于SD卡上的镜像文件（<code class="docutils literal notranslate"><span class="pre">*.wic</span></code>）。由于镜像文件相当大，您需要扩展SD卡以使用其全部空间（如果之前没有扩展的话）。有关如何扩展SD卡，请参阅调整 ext4 根文件系统的大小一节。</p>
<section id="flash-emmc-from-sd-card-in-u-boot-on-target">
<h4><span class="section-number">4.2.4.1. </span>在u-boot上从SD卡烧写eMMC<a class="headerlink" href="#flash-emmc-from-sd-card-in-u-boot-on-target" title="Link to this heading"></a></h4>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>此步骤仅在镜像文件大小小于1GB的情况下有效，因为在启用OPTEE后，Bootloader中可用的RAM大小有限。如果镜像文件太大，请使用“在目标上使用Linux从SD卡更新eMMC”一节。</p>
</div>
<ul>
<li><p>将一个可用的镜像烧写到SD卡，并创建一个FAT格式的第三分区。将WIC镜像（例如 phytec-qt5demo-image.wic）复制到该分区。</p></li>
<li><p>将启动模式开关配置为从SD卡启动，并插入SD卡。</p></li>
<li><p>给开发板上电并进入u-boot环境。</p></li>
<li><p>将您的WIC镜像（例如 phytec-qt5demo-image.wic）从SD卡烧写到eMMC。这将对卡进行分区，并将imx-boot、Image、dtb、dtbo和根文件系统复制到eMMC。</p></li>
<li><p>加载镜像：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; fatload mmc 1:3 ${loadaddr} phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic
reading
911842304 bytes read in 39253 ms (22.2 MiB/s)
</pre></div>
</div>
</li>
<li><p>切换mmc设备：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; mmc list
FSL_SDHC: 1 (SD)
FSL_SDHC: 2 (eMMC)
u-boot=&gt; mmc dev 2
switch to partitions #0, OK
mmc0(part 0) is current device
u-boot=&gt; setexpr nblk ${filesize} / 0x200
u-boot=&gt; mmc write ${loadaddr} 0x0 ${nblk}

MMC write: dev # 2, block # 0, count 1780942 ... 1780942 blocks written: OK
</pre></div>
</div>
</li>
<li><p>关闭电源，将启动模式开关切换到默认SOM启动，以从eMMC启动。</p></li>
</ul>
</section>
<section id="flash-emmc-from-sd-card-in-linux-on-target">
<h4><span class="section-number">4.2.4.2. </span>在开发板的linux环境中通过SD卡烧写eMMC<a class="headerlink" href="#flash-emmc-from-sd-card-in-linux-on-target" title="Link to this heading"></a></h4>
<p>您也可以在Linux上烧写eMMC。您只需在SD卡上保存一个完整的镜像（例如 phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic）。</p>
<ul>
<li><p>查看您在SD卡上保存的镜像文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ls
<span class="go">phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic</span>
</pre></div>
</div>
</li>
<li><p>显示可用的MMC设备列表：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ls<span class="w"> </span>/dev<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>mmc
<span class="go">mmcblk1</span>
<span class="go">mmcblk1p1</span>
<span class="go">mmcblk1p2</span>
<span class="go">mmcblk2</span>
<span class="go">mmcblk2boot0</span>
<span class="go">mmcblk2boot1</span>
<span class="go">mmcblk2p1</span>
<span class="go">mmcblk2p2</span>
<span class="go">mmcblk2rpmb</span>
</pre></div>
</div>
</li>
<li><p>eMMC设备的特征是它包含两个boot分区：(mmcblk2 <strong>boot0</strong>; mmcblk2 <strong>boot1</strong>)</p></li>
<li><p>Write the image to the phyCORE-i.MX 8M Plus eMMC (MMC device 2 <strong>without</strong>
partition):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2
</pre></div>
</div>
</li>
<li><p>在完成写入后，您的开发板可以从eMMC启动。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在此之前，您需要将 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 配置为默认SOM启动，以从eMMC启动。</p>
</div>
</section>
</section>
</section>
<section id="flash-spi-nor-flash">
<h2><span class="section-number">4.3. </span>烧写 SPI NOR Flash<a class="headerlink" href="#flash-spi-nor-flash" title="Link to this heading"></a></h2>
<p>phyCORE-i.MX 8M Plus 模块可选配SPI NOR Flash。要从SPI Flash启动，请将 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 设置为 <strong>QSPI启动</strong> 以从QSPI启动。SPI Flash通常容量较小。phyBOARD-Pollux-i.MX8MP套件仅配备32MB SPI NOR Flash。只能存储bootloader及其环境。内核、设备树和文件系统默认保存在eMMC。</p>
<p>SPI NOR Flash分区表在U-Boot环境变量中定义。可以通过以下命令打印：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; printenv mtdparts
mtdparts=30bb0000.spi:3840k(u-boot),128k(env),128k(env:redund),-(none)
</pre></div>
</div>
<section id="flash-spi-nor-flash-from-network">
<h3><span class="section-number">4.3.1. </span>通过网络烧写SPI NOR Flash<a class="headerlink" href="#flash-spi-nor-flash-from-network" title="Link to this heading"></a></h3>
<p>The SPI NOR can contain the bootloader and environment to boot from. The arm64
kernel can not decompress itself, the image size extends the SPI NOR flash
populated on the phyCORE-i.MX 8M Plus.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>需要保证设备和存储镜像的主机之间的网络正常！设置主机网络。</p>
</div>
<section id="flash-spi-nor-from-network-in-u-boot-on-target">
<h4><span class="section-number">4.3.1.1. </span>在开发板的u-boot环境中从网络烧写SPI NOR<a class="headerlink" href="#flash-spi-nor-from-network-in-u-boot-on-target" title="Link to this heading"></a></h4>
<p>与通过网络更新eMMC类似，请确保正确设置开发主机。IP需要设置为192.168.3.10，子网掩码设置为255.255.255.0，并且需要有一个TFTP服务器。在进行读写操作之前，需要对SPI-NOR Flash进行probe：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; sf probe
SF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB
</pre></div>
</div>
<ul>
<li><p>需要用特殊格式的SPI NOR Flash u-boot镜像。请确保使用正确的镜像文件。通过tftp加载镜像，擦除并将bootloader写入flash：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; tftp ${loadaddr} imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi
u-boot=&gt; sf update ${loadaddr} 0 ${filesize}
device 0 offset 0x0, size 0x1c0b20
1641248 bytes written, 196608 bytes skipped in 4.768s, speed 394459 B/s
</pre></div>
</div>
</li>
<li><p>同时需要擦除环境分区。这样，环境变量可以在从SPI NOR Flash启动后写入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; sf erase 0x400000 0x100000
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在写满后擦除整个SPI NOR Flash将需要相当长的时间。这可能会触发看门狗复位。因此，请在Linux中擦除整个闪存。</p>
</div>
</section>
<section id="flash-spi-nor-from-network-in-kernel-on-target">
<h4><span class="section-number">4.3.1.2. </span>在开发板linux环境中通过网络烧写SPI NOR Flash<a class="headerlink" href="#flash-spi-nor-from-network-in-kernel-on-target" title="Link to this heading"></a></h4>
<ul>
<li><p>将镜像从主机复制到开发板：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>scp<span class="w"> </span>imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi<span class="w"> </span>root@192.168.3.11:/root
</pre></div>
</div>
</li>
<li><p>找到U-boot分区的擦除块数量：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mtdinfo<span class="w"> </span>/dev/mtd0
<span class="go">mtd0</span>
<span class="go">Name:                           u-boot</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          60 (3932160 bytes, 3.7 MiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:0</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>
</pre></div>
</div>
</li>
<li><p>擦除u-boot分区并烧写：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>flash_erase<span class="w"> </span>/dev/mtd0<span class="w"> </span>0x0<span class="w"> </span><span class="m">60</span>
<span class="gp">target:~$ </span>flashcp<span class="w"> </span>imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi<span class="w"> </span>/dev/mtd0
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="flash-spi-nor-flash-from-sd-card">
<h3><span class="section-number">4.3.2. </span>从SD卡烧写SPI NOR Flash<a class="headerlink" href="#flash-spi-nor-flash-from-sd-card" title="Link to this heading"></a></h3>
<p>SPI NOR Flash上的bootloader也可以通过SD卡进行烧写。</p>
<section id="flash-spi-nor-from-sd-card-in-u-boot-on-target">
<h4><span class="section-number">4.3.2.1. </span>在开发板的u-boot环境中从SD卡烧写SPI NOR<a class="headerlink" href="#flash-spi-nor-from-sd-card-in-u-boot-on-target" title="Link to this heading"></a></h4>
<ul>
<li><p>将SPI NOR Flash的U-boot镜像imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi复制到SD卡的FAT分区。在进行读写操作之前，需要对SPI-NOR flash进行probe：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; sf probe
SF: Detected n25q256ax1 with page size 256 Bytes, erase size 64 KiB, total 32 MiB
</pre></div>
</div>
</li>
<li><p>SPI NOR Flash需要使用特殊格式的U-Boot镜像，请确保使用正确的镜像文件。从SD卡加载镜像，擦除并将bootloader写入flash：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; mmc dev 1
u-boot=&gt; fatload mmc 1:1 ${loadaddr} imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi
u-boot=&gt; sf update ${loadaddr} 0 ${filesize}
</pre></div>
</div>
</li>
<li><p>同时需要擦除环境分区。这样，环境变量可以在从SPI NOR Flash启动后写入：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; sf erase 0x400000 0x100000
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在写满后擦除整个SPI NOR Flash将需要相当长的时间。这可能会触发看门狗复位。因此，请在Linux中擦除整个闪存。</p>
</div>
</section>
<section id="flash-spi-nor-from-sd-card-in-kernel-on-target">
<h4><span class="section-number">4.3.2.2. </span>在开发板的linux环境中从SD卡烧写SPI NOR<a class="headerlink" href="#flash-spi-nor-from-sd-card-in-kernel-on-target" title="Link to this heading"></a></h4>
<ul>
<li><p>挂载SD卡：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>mount<span class="w"> </span>/dev/mmcblkp1<span class="w"> </span>/mnt
</pre></div>
</div>
</li>
<li><p>查找u-boot分区的擦除块数量：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$  </span>mtdinfo<span class="w"> </span>/dev/mtd0
<span class="go">mtd0</span>
<span class="go">Name:                           u-boot</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          60 (3932160 bytes, 3.7 MiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:0</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>
</pre></div>
</div>
</li>
<li><p>擦除u-boot分区并烧写：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>flash_erase<span class="w"> </span>/dev/mtd0<span class="w"> </span>0x0<span class="w"> </span><span class="m">60</span>
<span class="gp">target:~$ </span>flashcp<span class="w"> </span>/mnt/imx-boot-phyboard-pollux-imx8mp-3-fspi.bin-flash_evk_flexspi<span class="w"> </span>/dev/mtd0
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>
<section id="rauc">
<h2><span class="section-number">4.4. </span>RAUC<a class="headerlink" href="#rauc" title="Link to this heading"></a></h2>
<p>BSP支持RAUC（Robust Auto-Update Controller）。它管理设备固件更新的过程。这包括更新Linux内核、设备树和根文件系统。PHYTEC已撰写了一份在线手册，介绍如何在我们的BSP中集成RAUC：<a class="reference external" href="https://www.phytec.de/cdocuments/?doc=BKXvGQ">L-1006e.A3 RAUC 更新与设备管理手册</a>。</p>
</section>
</section>
<section id="development">
<span id="imx8mp-pd22-1-1-development"></span><h1><span class="section-number">5. </span>开发<a class="headerlink" href="#development" title="Link to this heading"></a></h1>
<section id="host-network-preparation">
<h2><span class="section-number">5.1. </span>主机网络准备<a class="headerlink" href="#host-network-preparation" title="Link to this heading"></a></h2>
<p>为了在bootloader中执行涉及网络的各种任务，需要配置一些主机服务。在开发主机上，必须安装和配置TFTP、NFS和DHCP服务。启动以太网所需的工具如下：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>tftpd-hpa<span class="w"> </span>nfs-kernel-server<span class="w"> </span>kea
</pre></div>
</div>
<section id="tftp-server-setup">
<h3><span class="section-number">5.1.1. </span>TFTP服务设置<a class="headerlink" href="#tftp-server-setup" title="Link to this heading"></a></h3>
<ul>
<li><p>首先，创建一个目录来存储TFTP文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>mkdir<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>然后将您的BSP镜像文件复制到此目录，并确保other用户也对tftp目录中的所有文件具有读取权限，否则将无法从开发板访问这些文件。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>chmod<span class="w"> </span>-R<span class="w"> </span>o+r<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>您还需要为相应的接口配置一个静态IP地址。PHYTEC开发板的默认IP地址是192.168.3.11。可以将主机地址设置为192.168.3.10，子网掩码为255.255.255.0</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>ip<span class="w"> </span>addr<span class="w"> </span>show<span class="w"> </span>&lt;network-interface&gt;
</pre></div>
</div>
<p>将 &lt;network-interface&gt; 替换为连接到开发板的网络接口。您可以通过不指定网络接口来显示所有可选网络接口。</p>
</li>
<li><p>返回的结果应包含以下内容：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inet 192.168.3.10/24 brd 192.168.3.255
</pre></div>
</div>
</li>
<li><p>创建或编辑 <code class="docutils literal notranslate"><span class="pre">/etc/default/tftpd-hpa</span></code> 文件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># /etc/default/tftpd-hpa

TFTP_USERNAME=&quot;tftp&quot;
TFTP_DIRECTORY=&quot;/srv/tftp&quot;
TFTP_ADDRESS=&quot;:69&quot;
TFTP_OPTIONS=&quot;-s -c&quot;
</pre></div>
</div>
</li>
<li><p>将 TFTP_DIRECTORY 设置为您的 TFTP 服务器根目录</p></li>
<li><p>将TFTP_ADDRESS设置为TFTP服务监听的主机地址（设置为0.0.0.0:69以监听69端口上所有IP）。</p></li>
<li><p>设置 TFTP_OPTIONS，以下命令显示可配置的选项：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>man<span class="w"> </span>tftpd
</pre></div>
</div>
</li>
<li><p>重新启动服务以应用配置更改：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>service<span class="w"> </span>tftpd-hpa<span class="w"> </span>restart
</pre></div>
</div>
</li>
</ul>
<p>现在将开发板的以太网端口连接到您的主机。我们还需要在开发板和运行TFTP服务的主机之间建立网络连接。TFTP服务器的IP地址应设置为192.168.3.10，子网掩码为255.255.255.0。</p>
<section id="nfs-server-setup">
<h4><span class="section-number">5.1.1.1. </span>NFS服务器设置<a class="headerlink" href="#nfs-server-setup" title="Link to this heading"></a></h4>
<ul>
<li><p>创建一个NFS目录：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>mkdir<span class="w"> </span>/srv/nfs
</pre></div>
</div>
</li>
<li><p>NFS服务对文件共享的路径没有限制，因此在大多数linux发行版中，我们只需修改文件 <code class="docutils literal notranslate"><span class="pre">/etc/exports</span></code> ，并将我们的根文件系统共享到网络。在这个示例文件中，整个目录被共享在主机地址为192.168.3.10的IP地址上。注意这个地址需要根据本地情况进行调整：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/srv/nfs 192.168.3.0/255.255.255.0(rw,no_root_squash,sync,no_subtree_check)
</pre></div>
</div>
</li>
<li><p>现在NFS服务器需要再次读取 <code class="docutils literal notranslate"><span class="pre">/etc/exportfs</span></code> 文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>exportfs<span class="w"> </span>-ra
</pre></div>
</div>
</li>
</ul>
</section>
<section id="dhcp-server-setup">
<h4><span class="section-number">5.1.1.2. </span>DHCP服务器设置<a class="headerlink" href="#dhcp-server-setup" title="Link to this heading"></a></h4>
<ul>
<li><p>创建或编辑 <code class="docutils literal notranslate"><span class="pre">/etc/kea/kea-dhcp4.conf</span></code> 文件；以内部子网为例，将 &lt;network-interface&gt; 替换为物理网络接口的名称：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;Dhcp4&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;interfaces-config&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;interfaces&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;&lt;network-interface&gt;/192.168.3.10&quot;</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;lease-database&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;memfile&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;persist&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/tmp/dhcp4.leases&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;valid-lifetime&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">28800</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;subnet4&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span>
<span class="w">        </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;next-server&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;192.168.3.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;subnet&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;192.168.3.0/24&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;pools&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;pool&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;192.168.3.1 - 192.168.3.255&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">}]</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在创建子网时请小心，因为这可能会扰乱公司网络政策。为了安全起见，请使用不同的子网，并通过 <code class="docutils literal notranslate"><span class="pre">interfaces</span></code> 配置选项指定该网络。</p>
</div>
<ul>
<li><p>现在DHCP服务需要重新读取 <code class="docutils literal notranslate"><span class="pre">/etc/kea/kea-dhcp4.conf</span></code> 文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>systemctl<span class="w"> </span>restart<span class="w"> </span>kea-dhcp4-server
</pre></div>
</div>
</li>
</ul>
<p>当您启动/重启主机时，如果kea-dhcp4配置中指定的网络接口未处于活动状态，kea-dhcp4-server将无法启动。因此请确保在连接接口后启动或者重启该systemd服务。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>DHCP server setup is only needed when using dynamic IP addresses. For our
vendor BSPs, static IP addresses are used by default.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; env print ip_dyn
ip_dyn=no
</pre></div>
</div>
<p>To use dynamic IP addresses for netboot, <code class="docutils literal notranslate"><span class="pre">ip_dyn</span></code> needs to be set to <code class="docutils literal notranslate"><span class="pre">yes</span></code>.</p>
</div>
</section>
</section>
</section>
<section id="booting-the-kernel-from-a-network">
<h2><span class="section-number">5.2. </span>从网络启动内核<a class="headerlink" href="#booting-the-kernel-from-a-network" title="Link to this heading"></a></h2>
<p>从网络启动意味着通过TFTP加载内核和设备树，并通过NFS加载根文件系统。但bootloader需要从另外的的启动设备加载。</p>
<section id="place-images-on-host-for-netboot">
<h3><span class="section-number">5.2.1. </span>在主机上放置网络启动的镜像<a class="headerlink" href="#place-images-on-host-for-netboot" title="Link to this heading"></a></h3>
<ul>
<li><p>将内核镜像复制到您的tftp目录中：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>cp<span class="w"> </span>Image<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>将设备树复制到您的tftp目录：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>cp<span class="w"> </span>oftree<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>将您想要使用的所有overlay文件复制到您的tftp目录中：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>cp<span class="w"> </span>*.dtbo<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>确保other用户对tftp目录中的所有文件具有读取权限，否则将无法从开发板访问它们：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>chmod<span class="w"> </span>-R<span class="w"> </span>o+r<span class="w"> </span>/srv/tftp
</pre></div>
</div>
</li>
<li><p>将根文件系统解压到您的NFS目录中：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>tar<span class="w"> </span>-xvzf<span class="w"> </span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.tar.gz<span class="w"> </span>-C<span class="w"> </span>/srv/nfs
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请确保使用sudo执行命令，以保留根文件系统中文件的所属权限。</p>
</div>
</section>
<section id="set-the-bootenv-txt-for-netboot">
<h3><span class="section-number">5.2.2. </span>设置网络启动的bootenv.txt文件<a class="headerlink" href="#set-the-bootenv-txt-for-netboot" title="Link to this heading"></a></h3>
<p>在您的tftp目录中创建一个bootenv.txt文件，并将以下变量写入其中。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bootfile=Image
fdt_file=oftree
nfsroot=/srv/nfs
overlays=&lt;overlayfilenames&gt;
</pre></div>
</div>
<p>&lt;overlayfilenames&gt; 必须替换为您想要使用的overlay设备树文件名。用空格分隔文件名。例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>overlays=example-overlay1.dtbo example-overlay2.dtbo
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>所有支持的设备树overlay在 <a class="reference internal" href="#imx8mp-pd22-1-1-device-tree"><span class="std std-ref">device tree</span></a> 章节中。</p>
</div>
</section>
<section id="network-settings-on-target">
<h3><span class="section-number">5.2.3. </span>开发板上的网络设置<a class="headerlink" href="#network-settings-on-target" title="Link to this heading"></a></h3>
<p>如果要自定义开发板上的以太网配置，请按照此处的说明进行操作： <a class="reference internal" href="#imx8mp-pd22-1-1-network"><span class="std std-ref">Network Environment Customization</span></a></p>
</section>
<section id="booting-from-an-embedded-board">
<h3><span class="section-number">5.2.4. </span>从开发板启动<a class="headerlink" href="#booting-from-an-embedded-board" title="Link to this heading"></a></h3>
<p>将开发板启动到U-boot，按任意键暂停。</p>
<ul>
<li><p>要从网络启动，请运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">u-boot=&gt; run netboot</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="working-with-uuu-tool">
<h2><span class="section-number">5.3. </span>使用UUU工具<a class="headerlink" href="#working-with-uuu-tool" title="Link to this heading"></a></h2>
<p>NXP的镜像更新工具（UUU-Tool）是一款在主机上运行的软件，用于通过SDP（串行下载协议）在开发板上下载并运行bootloader。有关详细信息，请访问 <a class="reference external" href="https://github.com/nxp-imx/mfgtools">https://github.com/nxp-imx/mfgtools</a> 或下载 <a class="reference external" href="https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/imx-processors/140261/1/UUU.pdf">官方UUU工具文档</a>。</p>
<section id="host-preparations-for-uuu-tool-usage">
<h3><span class="section-number">5.3.1. </span>使用UUU工具的准备<a class="headerlink" href="#host-preparations-for-uuu-tool-usage" title="Link to this heading"></a></h3>
<ul>
<li><p>请按照 <a class="reference external" href="https://github.com/nxp-imx/mfgtools#linux">https://github.com/nxp-imx/mfgtools#linux</a> 上的说明进行操作。</p></li>
<li><p>如果您要从源代码编译UUU，请将其添加到 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 中：</p>
<p>这个BASH命令只是暂时将UUU添加到 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 中。要永久添加，请将此行添加到 <code class="docutils literal notranslate"><span class="pre">~/.bashrc</span></code> 中。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">export PATH=~/mfgtools/uuu/:&quot;$PATH&quot;</span>
</pre></div>
</div>
</li>
<li><p>设置udev规则（在 <code class="docutils literal notranslate"><span class="pre">uuu</span> <span class="pre">-udev</span></code> 中有详细说明）：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>sh<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;uuu -udev &gt;&gt; /etc/udev/rules.d/70-uuu.rules&quot;</span>
<span class="gp">host:~$ </span>sudo<span class="w"> </span>udevadm<span class="w"> </span>control<span class="w"> </span>--reload
</pre></div>
</div>
</li>
</ul>
</section>
<section id="get-images">
<h3><span class="section-number">5.3.2. </span>获取镜像<a class="headerlink" href="#get-images" title="Link to this heading"></a></h3>
<p>可以从我们的服务器下载imx-boot，或者从Yocto编译目录中的build/deploy/images/phyboard-pollux-imx8mp-3/获取它。要将wic镜像烧写到eMMC，你还需要 phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic。</p>
</section>
<section id="prepare-target">
<h3><span class="section-number">5.3.3. </span>开发板准备<a class="headerlink" href="#prepare-target" title="Link to this heading"></a></h3>
<p>将 <a class="reference internal" href="#imx8mp-pd22-1-1-bootswitch"><span class="std std-ref">bootmode switch (S3)</span></a> 设置为 <strong>USB串行下载</strong>。同时，将 USB 端口 <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">X5 (upper connector)</span></a> 连接到主机。</p>
</section>
<section id="starting-bootloader-via-uuu-tool">
<h3><span class="section-number">5.3.4. </span>通过UUU工具启动bootloader<a class="headerlink" href="#starting-bootloader-via-uuu-tool" title="Link to this heading"></a></h3>
<p>执行并给开发板上电：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>uuu<span class="w"> </span>-b<span class="w"> </span>spl<span class="w"> </span>imx-boot
</pre></div>
</div>
<p>您可以像往常一样通过 <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">(X1)</span></a> 在终端上查看启动日志。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>UUU工具使用的默认启动命令为fastboot。如果您想更改此设置，请在U-Boot提示符下使用setenv bootcmd_mfg修改环境变量bootcmd_mfg。但是请注意，当开发板再次使用UUU工具启动时，默认环境变量会被加载，saveenv重启后不生效。如果您想永久的更改U-boot的启动命令，则需要更改U-Boot代码。</p>
</div>
</section>
<section id="flashing-u-boot-image-to-emmc-via-uuu-tool">
<h3><span class="section-number">5.3.5. </span>通过UUU工具将U-boot镜像烧写到eMMC<a class="headerlink" href="#flashing-u-boot-image-to-emmc-via-uuu-tool" title="Link to this heading"></a></h3>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>UUU将U-boot刷入eMMC BOOT（硬件）启动分区后，会在eMMC中设置BOOT_PARTITION_ENABLE。这带来一个问题，因为我们希望bootloader保存在eMMC 的USER分区中。如果烧写入新的包含U-boot的.wic镜像而不禁用BOOT_PARTITION_ENABLE位，将导致设备始终使用保存在BOOT分区中的U-boot。为了在U-Boot中解决此问题，需要：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">u-boot=&gt; mmc partconf 2 0 0 0</span>
<span class="go">u-boot=&gt; mmc partconf 2</span>
<span class="go">EXT_CSD[179], PARTITION_CONFIG:</span>
<span class="go">BOOT_ACK: 0x0</span>
<span class="go">BOOT_PARTITION_ENABLE: 0x0</span>
<span class="go">PARTITION_ACCESS: 0x0</span>
</pre></div>
</div>
<p>或者在linux中检查 <a class="reference internal" href="../../imx9/imx93/pd24.2.1.html#emmc-disable-boot-part"><span class="std std-ref">用从eMMC boot分区启动</span></a></p>
<p>这样bootloader虽然会被烧写到 eMMC 的BOOT分区，但在启动中不会被使用！</p>
<p>在使用 <strong>partup</strong> 工具和 <code class="docutils literal notranslate"><span class="pre">.partup</span></code> 包进行eMMC烧写时，上述过程是默认进行的，这是partup的优势，简化烧写过程。</p>
</div>
<p>执行并给开发板上电：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>uuu<span class="w"> </span>-b<span class="w"> </span>emmc<span class="w"> </span>imx-boot
</pre></div>
</div>
</section>
<section id="flashing-wic-image-to-emmc-via-uuu-tool">
<h3><span class="section-number">5.3.6. </span>通过UUU工具将wic镜像烧写到eMMC<a class="headerlink" href="#flashing-wic-image-to-emmc-via-uuu-tool" title="Link to this heading"></a></h3>
<p>执行并给开发板上电：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>uuu<span class="w"> </span>-b<span class="w"> </span>emmc_all<span class="w"> </span>imx-boot<span class="w"> </span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic
</pre></div>
</div>
</section>
</section>
<section id="standalone-build-preparation">
<h2><span class="section-number">5.4. </span>独立编译准备<a class="headerlink" href="#standalone-build-preparation" title="Link to this heading"></a></h2>
<p>In this section, we describe how to build the U-Boot and the Linux kernel
without using the <a class="reference external" href="https://www.yoctoproject.org/">Yocto Project</a>. This
procedure makes the most sense for development. The U-Boot source code,
the Linux kernel, and all other git repositories are available on <a class="reference external" href="https://github.com/phytec">GitHub
`Git server</a> at <a class="reference external" href="https://github.com/phytec">https://github.com/phytec</a>.</p>
<section id="git-repositories">
<h3><span class="section-number">5.4.1. </span>Git 仓库<a class="headerlink" href="#git-repositories" title="Link to this heading"></a></h3>
<ul>
<li><p>使用的 U-Boot 仓库：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>git://git.phytec.de/u-boot-imx
</pre></div>
</div>
</li>
<li><p>我们的U-Boot基于 u-boot-imx 并添加了一些硬件相关的补丁。</p></li>
<li><p>使用的 Linux 内核仓库：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>git://git.phytec.de/linux-imx
</pre></div>
</div>
</li>
<li><p>我们的 i.MX 8M Plus 内核是基于 linux-imx 内核。</p></li>
</ul>
<p>要找出核心板应使用的u-boot和kernel版本对应的git仓库tag标签，请查看您的BSP源文件夹：</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>meta-phytec/dynamic-layers/freescale-layer/recipes-kernel/linux/linux-imx_*.bb
meta-phytec/recipes-bsp/u-boot/u-boot-imx_*.bb
</pre></div>
</div>
</div></blockquote>
</section>
<section id="get-the-sdk">
<h3><span class="section-number">5.4.2. </span>获取SDK<a class="headerlink" href="#get-the-sdk" title="Link to this heading"></a></h3>
<p>您可以在此处下载SDK <a class="reference external" href="https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/sdk/ampliphy-vendor-xwayland/">这里</a>，或者使用Yocto去编译生成SDK：</p>
<ul>
<li><p>移动到Yocto的build目录：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">source</span><span class="w"> </span>sources/poky/oe-init-build-env
<span class="gp">host:~$ </span>bitbake<span class="w"> </span>-c<span class="w"> </span>populate_sdk<span class="w"> </span>phytec-qt5demo-image<span class="w"> </span><span class="c1"># or another image</span>
</pre></div>
</div>
</li>
</ul>
<p>在成功编译后，SDK安装包保存在  <code class="docutils literal notranslate"><span class="pre">build/deploy*/sdk</span></code>。</p>
</section>
<section id="install-the-sdk">
<h3><span class="section-number">5.4.3. </span>安装SDK<a class="headerlink" href="#install-the-sdk" title="Link to this heading"></a></h3>
<ul>
<li><p>设置正确的权限并安装SDK：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>chmod<span class="w"> </span>+x<span class="w"> </span>phytec-ampliphy-vendor-xwayland-glibc-x86_64-phytec-qt5demo-image-cortexa53-crypto-toolchain-BSP-Yocto-NXP-i.MX8MP-PD22.1.1.sh
<span class="gp">host:~$ </span>./phytec-ampliphy-vendor-xwayland-glibc-x86_64-phytec-qt5demo-image-cortexa53-crypto-toolchain-BSP-Yocto-NXP-i.MX8MP-PD22.1.1.sh
<span class="go">============================================================================================================</span>
<span class="go">Enter target directory for SDK (default: /opt/ampliphy-vendor-xwayland/BSP-Yocto-NXP-i.MX8MP-PD22.1.1):</span>
<span class="go">You are about to install the SDK to &quot;/opt/ampliphy-vendor-xwayland/BSP-Yocto-NXP-i.MX8MP-PD22.1.1&quot;. Proceed [Y/n]? Y</span>
<span class="go">Extracting SDK...done</span>
<span class="go">Setting it up...done</span>
<span class="go">SDK has been successfully set up and is ready to be used.</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="using-the-sdk">
<h3><span class="section-number">5.4.4. </span>使用SDK<a class="headerlink" href="#using-the-sdk" title="Link to this heading"></a></h3>
<p>通过在工具链目录中source <em>environment-setup</em> 文件来初始化您的 shell 交叉编译环境：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">source</span><span class="w"> </span>/opt/ampliphy-vendor-xwayland/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/environment-setup-cortexa53-crypto-phytec-linux
</pre></div>
</div>
</section>
<section id="installing-required-tools">
<h3><span class="section-number">5.4.5. </span>安装所需工具<a class="headerlink" href="#installing-required-tools" title="Link to this heading"></a></h3>
<p>独立编译Linux kernel和U-Boot需要主机安装一些额外的工具。对于Ubuntu，您可以使用以下命令安装它们：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>bison<span class="w"> </span>flex<span class="w"> </span>libssl-dev
</pre></div>
</div>
</section>
</section>
<section id="u-boot-standalone-build">
<span id="imx8mp-pd22-1-1-development-build-uboot"></span><h2><span class="section-number">5.5. </span>单独编译U-Boot<a class="headerlink" href="#u-boot-standalone-build" title="Link to this heading"></a></h2>
<section id="get-the-source-code">
<h3><span class="section-number">5.5.1. </span>获取源代码<a class="headerlink" href="#get-the-source-code" title="Link to this heading"></a></h3>
<ul>
<li><p>获取U-Boot源代码：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>git<span class="w"> </span>clone<span class="w"> </span>git://git.phytec.de/u-boot-imx
</pre></div>
</div>
</li>
<li><p>要获取正确的 <em>U-Boot</em> <strong>tag</strong>，您需要查看我们的release notes，可以在这里找到：<a class="reference external" href="https://git.phytec.de/phy2octo/tree/releasenotes?h=imx8mp">release notes</a></p></li>
<li><p>此版本的 <strong>tag</strong> 称为 v2021.04_2.2.0-phy13</p></li>
<li><p>查看所需的 <em>U-Boot</em> <strong>tag</strong>：</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">cd</span><span class="w"> </span>~/u-boot-imx/
<span class="gp">host:~$ </span>git<span class="w"> </span>fetch<span class="w"> </span>--all<span class="w"> </span>--tags
<span class="gp">host:~$ </span>git<span class="w"> </span>checkout<span class="w"> </span>tags/v2021.04_2.2.0-phy13
</pre></div>
</div>
<ul>
<li><p>从技术上讲，您现在可以编译U-Boot，但实际上还需要一些进一步的步骤：</p>
<ul>
<li><p>创建您自己的开发分支：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>git<span class="w"> </span>switch<span class="w"> </span>--create<span class="w"> </span>&lt;new-branch&gt;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>您可以根据您的需要自行命名您的开发分支，这只是一个示例。</p>
</div>
</li>
</ul>
</li>
<li><p>设置编译环境：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">source</span><span class="w"> </span>/opt/ampliphy-vendor-xwayland/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/environment-setup-cortexa53-crypto-phytec-linux
</pre></div>
</div>
</li>
<li><p>在编译镜像之前，请设置此环境变量：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">export</span><span class="w"> </span><span class="nv">ATF_LOAD_ADDR</span><span class="o">=</span>0x970000
</pre></div>
</div>
</li>
</ul>
</section>
<section id="get-the-needed-binaries">
<h3><span class="section-number">5.5.2. </span>获取所需的二进制文件<a class="headerlink" href="#get-the-needed-binaries" title="Link to this heading"></a></h3>
<p>要编译bootloader，您需要将这些文件复制到您的 u-boot-imx 编译目录，并将其重命名以适应 <em>mkimage</em> 脚本：</p>
<ul class="simple">
<li><p><strong>ARM Trusted firmware 二进制文件</strong> （ <em>mkimage 工具</em>  兼容格式 <strong>bl31.bin</strong> ）：bl31-imx8mp.bin</p></li>
<li><p><strong>OPTEE 镜像</strong> (可选的)：tee.bin</p></li>
<li><p><strong>DDR firmware files</strong> ( <em>mkimage 工具</em> 兼容格式 <strong>lpddr4_[i,d]mem_*d_*.bin</strong> ): lpddr4_dmem_1d_*.bin, lpddr4_dmem_2d_*.bin, lpddr4_imem_1d_*.bin, lpddr4_imem_2d_*.bin</p></li>
</ul>
<p>如果您已经使用Yocto编译了我们的BSP，您可以在yocto工程目录中获取 bl31-imx8mp.bin、tee.bin和lpddr4_*.bin：<a class="reference internal" href="#imx8mp-pd22-1-1-images"><span class="std std-ref">BSP Images</span></a></p>
<p>或者你可以在这里下载文件： <a class="reference external" href="https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/imx-boot-tools/">https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/imx-boot-tools/</a></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>确保您重命名所需的文件，以和 <em>mkimage tool</em> 兼容。</p>
</div>
</section>
<section id="build-the-bootloader">
<h3><span class="section-number">5.5.3. </span>编译bootloader<a class="headerlink" href="#build-the-bootloader" title="Link to this heading"></a></h3>
<ul>
<li><p>编译 flash.bin (imx-boot):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>make<span class="w"> </span>phycore-imx8mp_defconfig
<span class="gp">host:~$ </span>make<span class="w"> </span>flash.bin
</pre></div>
</div>
</li>
</ul>
</section>
<section id="flash-the-bootloader-to-a-block-device">
<h3><span class="section-number">5.5.4. </span>将bootloader烧写到块设备上<a class="headerlink" href="#flash-the-bootloader-to-a-block-device" title="Link to this heading"></a></h3>
<p>flash.bin 文件可以在 u-boot-imx/ 目录中找到。需要一个特定于芯片的偏移量：</p>
<table class="docutils align-default" id="offset-table">
<thead>
<tr class="row-odd"><th class="head"><p>SoC</p></th>
<th class="head"><p>User分区偏移量</p></th>
<th class="head"><p>Boot分区偏移量</p></th>
<th class="head"><p>eMMC设备</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>i.MX 8M Plus</p></td>
<td><p>32 kiB</p></td>
<td><p>0 kiB</p></td>
<td><p>/dev/mmcblk2</p></td>
</tr>
</tbody>
</table>
<p>例如，烧写SD卡：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>flash.bin<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/sd<span class="o">[</span>x<span class="o">]</span><span class="w"> </span><span class="nv">bs</span><span class="o">=</span><span class="m">1024</span><span class="w"> </span><span class="nv">seek</span><span class="o">=</span><span class="m">32</span><span class="w"> </span><span class="nv">conv</span><span class="o">=</span>fsync
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>如果您有我们的BSP Yocto工程代码，具体的偏移值也会在Yocto变量&quot;BOOTLOADER_SEEK&quot;和&quot;BOOTLOADER_SEEK_EMMC&quot;中声明。</p>
</div>
</section>
<section id="build-u-boot-with-a-fixed-ram-size">
<h3><span class="section-number">5.5.5. </span>使用固定内存大小编译U-Boot<a class="headerlink" href="#build-u-boot-with-a-fixed-ram-size" title="Link to this heading"></a></h3>
<p>如果您的系统因为EEPROM中的硬件信息损坏或丢失而无法启动，您可以创建一个具有固定RAM大小的flash.bin。但您仍应联系我们支持部门以烧写正确的EEPROM数据。</p>
<p>按照步骤获取U-boot源代码，并切换到 <strong>Build U-Boot</strong> 章节说明的分支。</p>
<p>编辑文件 configs/phycore-imx8mp_defconfig:</p>
<div class="highlight-kconfig notranslate"><div class="highlight"><pre><span></span>CONFIG_TARGET_PHYCORE_IMX8MP=y
CONFIG_PHYCORE_IMX8MP_RAM_SIZE_FIX=y
<span class="c1"># CONFIG_PHYCORE_IMX8MP_RAM_SIZE_1GB=y</span>
<span class="c1"># CONFIG_PHYCORE_IMX8MP_RAM_SIZE_2GB=y</span>
<span class="c1"># CONFIG_PHYCORE_IMX8MP_RAM_SIZE_4GB=y</span>
</pre></div>
</div>
<p>选择正确的RAM大小，确保与核心板上的贴装的器件一致，取消注释该RAM大小的行。保存更改后，按照 <a class="reference internal" href="#imx8mp-pd22-1-1-development-build-uboot"><span class="std std-ref">Build U-Boot</span></a> 章节的剩余步骤进行操作。</p>
</section>
</section>
<section id="kernel-standalone-build">
<h2><span class="section-number">5.6. </span>单独编译内核<a class="headerlink" href="#kernel-standalone-build" title="Link to this heading"></a></h2>
<section id="setup-sources">
<h3><span class="section-number">5.6.1. </span>配置源代码<a class="headerlink" href="#setup-sources" title="Link to this heading"></a></h3>
<ul>
<li><p>使用的 linux-imx 分支可以在 <a class="reference external" href="https://git.phytec.de/phy2octo/tree/releasenotes?h=imx8mp">release notes</a> 中找到</p></li>
<li><p>此版本所需的标签称为 v5.10.72_2.2.0-phy17</p></li>
<li><p>Check out 所需的 linux-imx 标签：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>git<span class="w"> </span>clone<span class="w"> </span>git://git.phytec.de/linux-imx
<span class="gp">host:~$ </span><span class="nb">cd</span><span class="w"> </span>~/linux-imx/
<span class="gp">host:~/linux-imx$ </span>git<span class="w"> </span>fetch<span class="w"> </span>--all<span class="w"> </span>--tags
<span class="gp">host:~/linux-imx$ </span>git<span class="w"> </span>checkout<span class="w"> </span>tags/v5.10.72_2.2.0-phy17
</pre></div>
</div>
</li>
<li><p>为了提交更改，强烈建议切换到一个新分支：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span>git<span class="w"> </span>switch<span class="w"> </span>--create<span class="w"> </span>&lt;new-branch&gt;
</pre></div>
</div>
</li>
<li><p>设置编译环境：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span><span class="nb">source</span><span class="w"> </span>/opt/ampliphy-vendor-xwayland/BSP-Yocto-NXP-i.MX8MP-PD22.1.1/environment-setup-cortexa53-crypto-phytec-linux
</pre></div>
</div>
</li>
</ul>
</section>
<section id="build-the-kernel">
<h3><span class="section-number">5.6.2. </span>编译内核<a class="headerlink" href="#build-the-kernel" title="Link to this heading"></a></h3>
<ul>
<li><p>编译Linux内核：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span>make<span class="w"> </span>imx_v8_defconfig<span class="w"> </span>imx8_phytec_distro.config<span class="w"> </span>imx8_phytec_platform.config
<span class="gp">host:~/linux-imx$ </span>make<span class="w"> </span>-j<span class="k">$(</span>nproc<span class="k">)</span>
</pre></div>
</div>
</li>
<li><p>安装内核模块，比如安装到 NFS 目录：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span>make<span class="w"> </span><span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>/home/&lt;user&gt;/&lt;rootfspath&gt;<span class="w"> </span>modules_install
</pre></div>
</div>
</li>
<li><p>镜像可以在 ~/linux-imx/arch/arm64/boot/Image 找到</p></li>
<li><p>dtb文件可以在 ~/linux-imx/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dtb 找到</p></li>
<li><p>要（重新）编译设备树和 -overlay 文件，只需运行</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span>make<span class="w"> </span>dtbs
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您遇到以下编译问题：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>scripts/dtc/yamltree.c:9:10: fatal error: yaml.h: No such file or directory
</pre></div>
</div>
<p>确保您在主机系统上安装了 <em>&quot;libyaml-dev&quot;</em> 包：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>libyaml-dev
</pre></div>
</div>
</div>
</section>
<section id="copy-kernel-to-sd-card">
<h3><span class="section-number">5.6.3. </span>将内核复制到SD卡<a class="headerlink" href="#copy-kernel-to-sd-card" title="Link to this heading"></a></h3>
<p>内核及module和对应的设备树二进制文件可以用以下方式复制到已挂载的SD卡上。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/linux-imx$ </span>cp<span class="w"> </span>arch/arm64/boot/Image<span class="w"> </span>/path/to/sdcard/boot/
<span class="gp">host:~/linux-imx$ </span>cp<span class="w"> </span>arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dtb<span class="w"> </span>/path/to/sdcard/boot/oftree
<span class="gp">host:~/linux-imx$ </span>make<span class="w"> </span><span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>/path/to/sdcard/root/<span class="w"> </span>modules_install
</pre></div>
</div>
</section>
</section>
<section id="accessing-the-development-states">
<h2><span class="section-number">5.7. </span>获取BSP开发中版本<a class="headerlink" href="#accessing-the-development-states" title="Link to this heading"></a></h2>
<section id="development-state-of-current-release">
<h3><span class="section-number">5.7.1. </span>当前release的开发中版本<a class="headerlink" href="#development-state-of-current-release" title="Link to this heading"></a></h3>
<p>这些release manifest文件是为了让您访问 <em>Yocto</em> BSP的开发版本。它们不会在phyLinux选择菜单中显示，需要手动选择。可以使用以下命令行来完成此操作：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>./phyLinux<span class="w"> </span>init<span class="w"> </span>-p<span class="w"> </span>imx8mp<span class="w"> </span>-r<span class="w"> </span>BSP-Yocto-NXP-i.MX8MP-PD22.1.y
</pre></div>
</div>
<p>这将初始化一个BSP，用于跟踪当前版本（ BSP-Yocto-NXP-i.MX8MP-PD22.1.1 ）的最新开发版本。从现在开始，在此文件夹中执行 <em>repo sync</em> 将从我们的Git仓库中拉取所有最新的更改：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>repo<span class="w"> </span>sync
</pre></div>
</div>
</section>
<section id="development-state-of-upcoming-release">
<h3><span class="section-number">5.7.2. </span>即将发布版本的开发中版本<a class="headerlink" href="#development-state-of-upcoming-release" title="Link to this heading"></a></h3>
<p>即将发布版本的开发中版本可以通过这种方式访问。请执行以下命令，并查找一个比最新版本（ BSP-Yocto-NXP-i.MX8MP-PD22.1.1 ）的PDXX.Y数字更高的版本，并且以 <code class="docutils literal notranslate"><span class="pre">.y</span></code> 结尾：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>./phyLinux<span class="w"> </span>init<span class="w"> </span>-p<span class="w"> </span>imx8mp
</pre></div>
</div>
</section>
</section>
<section id="accessing-the-latest-upstream-support">
<h2><span class="section-number">5.8. </span>获取最新的Upstream支持<a class="headerlink" href="#accessing-the-latest-upstream-support" title="Link to this heading"></a></h2>
<p>我们有一个使用Yocto主分支（不是NXP发布的）的manifest，他使用upstream的Linux和U-Boot。这可以用来测试最新的upstream kernel/U-Boot。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>master分支的manifest反映了最新的开发状态。有时会出现一些bug。我们会定期修复master分支。</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>./phyLinux<span class="w"> </span>init<span class="w"> </span>-p<span class="w"> </span>imx8mp<span class="w"> </span>-r<span class="w"> </span>BSP-Yocto-Ampliphy-i.MX8MP-master
</pre></div>
</div>
</section>
<section id="format-sd-card">
<h2><span class="section-number">5.9. </span>Format SD card<a class="headerlink" href="#format-sd-card" title="Link to this heading"></a></h2>
<p>使用单一的SD卡启动盘对存储介质进行烧写是开发过程中的常见任务。本章节针对此场景提供基础说明。大多数镜像的大小超过了默认的root分区剩余容量。要使用SD卡进行烧写，根文件系统需要扩展或创建一个单独的分区。有几种不同的方法可以格式化SD卡。最简单的方法是使用Gparted。</p>
<section id="gparted">
<h3><span class="section-number">5.9.1. </span>Gparted<a class="headerlink" href="#gparted" title="Link to this heading"></a></h3>
<ul>
<li><p>获取 GParted：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>gparted
</pre></div>
</div>
</li>
<li><p>Insert the SD card into your host and get the device name:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>dmesg<span class="w"> </span><span class="p">|</span><span class="w"> </span>tail
<span class="go">...</span>
<span class="go">[30436.175412] sd 4:0:0:0: [sdb] 62453760 512-byte logical blocks: (32.0 GB/29.8 GiB)</span>
<span class="go">[30436.179846]  sdb: sdb1 sdb2</span>
<span class="go">...</span>
</pre></div>
</div>
</li>
<li><p>Unmount all SD card partitions.</p></li>
<li><p>启动 GParted：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>gparted
</pre></div>
</div>
</li>
</ul>
<img alt="../../../_images/gparted1.png" src="../../../_images/gparted1.png" />
<section id="expand-rootfs">
<h4><span class="section-number">5.9.1.1. </span>扩展根文件系统<a class="headerlink" href="#expand-rootfs" title="Link to this heading"></a></h4>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>使用resize2fs版本1.46.6及更早版本的PC系统（例如Ubuntu 22.04）无法烧写在Mickledore以及更新的yocto版本上创建的partup软件包。这个是因为resize2fs新增了默认选项而导致的兼容性问题。有关详细信息，请参阅 <a class="reference external" href="https://e2fsprogs.sourceforge.net/e2fsprogs-release.html#1.47.0">发布说明</a> 。</p>
</div>
<ul class="simple">
<li><p>Choose your SD card device at the drop-down menu on the top right</p></li>
<li><p>选择 ext4 根分区并点击调整大小：</p></li>
</ul>
<img alt="../../../_images/gparted5.png" src="../../../_images/gparted5.png" />
<img alt="../../../_images/gparted2.png" src="../../../_images/gparted2.png" />
<ul class="simple">
<li><p>您可以根据需要拖动滑块或手动输入大小。</p></li>
</ul>
<img alt="../../../_images/gparted3.png" src="../../../_images/gparted3.png" />
<ul class="simple">
<li><p>通过点击“Change Size”按钮确认您的输入。</p></li>
</ul>
<img alt="../../../_images/gparted4.png" src="../../../_images/gparted4.png" />
<ul>
<li><p>要应用您的更改，请按绿色勾号。</p></li>
<li><p>现在您可以挂载根分区并将 phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic 镜像复制到其中。然后再卸载它：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>cp<span class="w"> </span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic<span class="w"> </span>/mnt/<span class="w"> </span><span class="p">;</span><span class="w"> </span>sync
<span class="gp">host:~$ </span>umount<span class="w"> </span>/mnt
</pre></div>
</div>
</li>
</ul>
</section>
<section id="create-the-third-partition">
<h4><span class="section-number">5.9.1.2. </span>创建第三个分区<a class="headerlink" href="#create-the-third-partition" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Choose your SD card device at the drop-down menu on the top right</p></li>
</ul>
<img alt="../../../_images/gparted1.png" src="../../../_images/gparted1.png" />
<ul class="simple">
<li><p>选择更大的未分配区域，然后点击&quot;New&quot;：</p></li>
</ul>
<img alt="../../../_images/gparted6.png" src="../../../_images/gparted6.png" />
<ul class="simple">
<li><p>点击&quot;Add&quot;</p></li>
</ul>
<img alt="../../../_images/gparted7.png" src="../../../_images/gparted7.png" />
<ul class="simple">
<li><p>按绿色勾确认更改。</p></li>
</ul>
<img alt="../../../_images/gparted8.png" src="../../../_images/gparted8.png" />
<ul>
<li><p>现在您可以挂载新的分区并将 phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic 镜像复制到其中。然后卸载它：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>mount<span class="w"> </span>/dev/sde3<span class="w"> </span>/mnt
<span class="gp">host:~$ </span>sudo<span class="w"> </span>cp<span class="w"> </span>phytec-qt5demo-image-phyboard-pollux-imx8mp-3.wic<span class="w"> </span>/mnt/<span class="w"> </span><span class="p">;</span><span class="w"> </span>sync
<span class="gp">host:~$ </span>umount<span class="w"> </span>/mnt
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>
</section>
<section id="device-tree-dt">
<span id="imx8mp-pd22-1-1-device-tree"></span><h1><span class="section-number">6. </span>设备树 (DT)<a class="headerlink" href="#device-tree-dt" title="Link to this heading"></a></h1>
<section id="introduction">
<h2><span class="section-number">6.1. </span>介绍<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>以下文本简要描述了设备树，关于设备树的相关文档可以在Linux kernel文档中找到（<a class="reference external" href="https://docs.kernel.org/devicetree/usage-model.html">https://docs.kernel.org/devicetree/usage-model.html</a>）。</p>
<p>“Open Firmware Device Tree”或简称设备树（DT）是一种用于描述硬件的数据结构和语言。更具体地说，它是一个可由操作系统读取的硬件描述，以便操作系统不需要对machine的细节进行硬编码</p>
<p>内核文档是学习设备树的一个非常好的资源。关于设备树数据格式的概述可以在 <a class="reference external" href="https://www.devicetree.org/">devicetree.org</a> 的设备树使用页面找到。</p>
</section>
<section id="phytec-soc-bsp-device-tree-concept">
<h2><span class="section-number">6.2. </span>PHYTEC i.MX 8M Plus BSP设备树概念<a class="headerlink" href="#phytec-soc-bsp-device-tree-concept" title="Link to this heading"></a></h2>
<p>以下部分说明了PHYTEC配置基于 i.MX 8M Plus 的核心板设备树的一些规则。</p>
<section id="device-tree-structure">
<h3><span class="section-number">6.2.1. </span>设备树结构<a class="headerlink" href="#device-tree-structure" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><em>Module.dtsi</em> - 文件包括所有安装在核心板上的设备，例如PMIC和RAM。</p></li>
<li><p><em>Carrierboard.dtsi</em> - 包括来自于 i.MX 8M Plus SoC 的外设，在底板上使用的外设的设备树配置包含在这个 dtsi 中。</p></li>
<li><p><em>Board.dts</em> - include the carrier board and module dtsi files. There may also
be some hardware configuration nodes enabled on the carrier board or the
module (i.e. the Board .dts shows the special characteristics of the board
configuration). For example, there are phyCORE-i.MX 8M Plus SOMs which may or may not
have a MIPI DSI to LVDS converter mounted. The converter is enabled (if
available) in the Board .dts and not in the Module .dtsi</p></li>
</ul>
<p>在Linux内核的根目录下，我们的 i.MX 8 平台的设备树文件可以在 <code class="docutils literal notranslate"><span class="pre">arch/arm64/boot/dts/freescale/</span></code> 找到。</p>
</section>
<section id="device-tree-overlay">
<h3><span class="section-number">6.2.2. </span>设备树Overlay<a class="headerlink" href="#device-tree-overlay" title="Link to this heading"></a></h3>
<p>设备树Overlay是可以在启动时合并到设备树中的设备树片段。例如扩展板的硬件描述。对比源码中的include，overlay是用覆盖的方式来生效。overlay也可以根据节点是否连接来设置节点状态。设备树Overlay与我们Linux内核仓库中的其他设备树文件一起放在子文件夹 <code class="docutils literal notranslate"><span class="pre">arch/arm64/boot/dts/freescale/overlays</span></code> 中。</p>
<p>phyboard-pollux-imx8mp-3.conf 可用的overlay文件有：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>imx8mp-isi-csi1.dtbo
imx8mp-isi-csi2.dtbo
imx8mp-isp-csi1.dtbo
imx8mp-isp-csi2.dtbo
imx8mp-phyboard-pollux-peb-av-010.dtbo
imx8mp-phyboard-pollux-peb-av-012.dtbo
imx8mp-phyboard-pollux-peb-wlbt-05.dtbo
imx8mp-phycore-no-eth.dtbo
imx8mp-phycore-no-rtc.dtbo
imx8mp-phycore-no-spiflash.dtbo
imx8mp-phycore-rpmsg.dtbo
imx8mp-vm016-csi1.dtbo
imx8mp-vm016-csi1-fpdlink.dtbo
imx8mp-vm016-csi2.dtbo
imx8mp-vm016-csi2-fpdlink.dtbo
imx8mp-vm017-csi1.dtbo
imx8mp-vm017-csi1-fpdlink.dtbo
imx8mp-vm017-csi2.dtbo
imx8mp-vm017-csi2-fpdlink.dtbo
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>phyboard-pollux-imx8mp-2.conf还有一个可用的overlay文件：imx8mp-phyboard-pollux-1552.1.dtbo</p>
</div>
<p id="imx8mp-pd22-1-1-ubootexternalenv">可以在Linux或U-Boot环境下配置overlay。overlay是在引导命令调用后、内核加载之前生效。接下来的部分将更详细地解释配置方法。</p>
<section id="set-overlays-variable">
<h4><span class="section-number">6.2.2.1. </span>设置 <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量<a class="headerlink" href="#set-overlays-variable" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> U-Boot 环境变量包含一个以空格分隔的overlay文件列表，这些overlay文件将在启动过程中应用。根据启动源，overlay文件必须放置在 eMMC/SD 卡的启动分区中，或者通过 tftp 加载。在 $KERNEL_DEVICETREE 这个 Yocto machine 变量中设置的 overlay 文件将自动添加到最终 WIC 镜像的启动分区中。</p>
<p><code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量可以直接在U-Boot环境中设置，也可以作为外部 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 环境文件的一部分。默认情况下， <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量来自位于启动分区的 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 文件。您可以在已启动的开发板上从Linux读取和写入该文件：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/boot/bootenv.txt
<span class="go">overlays=imx8mp-phyboard-pollux-rdk-peb-eval-01.dtbo imx8mp-phyboard-pollux-peb-av-010.dtbo</span>
</pre></div>
</div>
<p>更改将在下次重启后生效。如果没有可用的 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 文件，可以直接在U-Boot环境中设置overlay变量。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv overlays imx8mp-phyboard-pollux-peb-av-010.dtbo
u-boot=&gt; printenv overlays
overlays=imx8mp-phyboard-pollux-peb-av-010.dtbo
u-boot=&gt; boot
</pre></div>
</div>
<p>如果用户定义了 <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量，同时存在 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 文件，则需要设置 <code class="docutils literal notranslate"><span class="pre">${no_bootenv}</span></code> 变量：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv no_bootenv 1
u-boot=&gt; setenv overlays imx8mp-phyboard-pollux-peb-av-010.dtbo
u-boot=&gt; boot
</pre></div>
</div>
<p>有关环境的更多信息，请参见 U-boot External Environment subsection of the
<a class="reference internal" href="#imx8mp-pd22-1-1-ubootexternalenv"><span class="std std-ref">device tree overlay section</span></a>。</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量来描述在运行时无法自动检测的扩展板和摄像头。如果想禁用 <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量中列出的overlay，可以在U-Boot的环境中将 <code class="docutils literal notranslate"><span class="pre">${no_overlays}</span></code> 变量设置为 <cite>1</cite>。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv no_overlays 1
u-boot=&gt; boot
</pre></div>
</div>
</section>
<section id="extension-command">
<h4><span class="section-number">6.2.2.2. </span>扩展命令<a class="headerlink" href="#extension-command" title="Link to this heading"></a></h4>
<p>使用U-Boot扩展命令能够轻松加载由回调函数  <a class="reference external" href="https://git.phytec.de/u-boot-imx/tree/board/phytec/phycore_imx8mp/phycore-imx8mp.c?h=v2021.04_2.2.0-phy13#n239">extension_board_scan()</a> 检测并添加到列表中的overlay。以这种方式应用的overlay会禁用核心板上未贴装的组件。检测是通过读取出厂EEPROM数据（EEPROM SoM Detection）来实现的。</p>
<p>核心板型号会决定是否应用设备树overlay。要在U-Boot环境中查询是否会应用某个overlay，请运行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; extension scan
Found 1 extension board(s).
u-boot=&gt; extension list
Extension 0: phyCORE-soc no SPI flash
        Manufacturer:           PHYTEC
        Version:
        Devicetree overlay:     imx8mp-phycore-no-spiflash.dtbo
        Other information:      SPI flash not populated on SoM
</pre></div>
</div>
<p>如果没有可用的EEPROM数据，则不加载任何设备树overlay。</p>
<p>为了禁止在启动时自动运行扩展命令，可以在bootloader环境中将 <code class="docutils literal notranslate"><span class="pre">${no_extensions}</span></code> 变量设置为 <cite>1</cite> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv no_extensions 1
u-boot=&gt; boot
</pre></div>
</div>
</section>
</section>
<section id="u-boot-external-environment">
<h3><span class="section-number">6.2.3. </span>U-boot外部环境<a class="headerlink" href="#u-boot-external-environment" title="Link to this heading"></a></h3>
<p>在Linux内核启动时，外部环境 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 文本文件将从MMC设备的boot分区或通过TFTP加载。该文件的主要目的是存储 <code class="docutils literal notranslate"><span class="pre">${overlays}</span></code> 变量。这可以针对不同的machine在Yocto中预定义不同的overlay配置。文件的内容在meta-phytec中的Yocto recipe中的bootenv中定义： <a class="extlink-yocto-bootenv reference external" href="https://git.phytec.de/meta-phytec/tree/recipes-bsp/bootenv?h=hardknott">https://git.phytec.de/meta-phytec/tree/recipes-bsp/bootenv?h=hardknott</a></p>
<p>该文件中也可以设置其他变量。这些变量将覆盖环境中现有的设置。但只有对boot命令后进行计算的变量生效，例如 <code class="docutils literal notranslate"><span class="pre">${nfsroot}</span></code> 或 <code class="docutils literal notranslate"><span class="pre">${mmcargs}</span></code>。在文件中更改其他变量将不会有作用。以网络启动的用法作为示例。</p>
<p>如果无法加载外部环境，启动过程将继续进行，并使用自带的环境变量值。</p>
</section>
<section id="change-u-boot-environment-from-linux-on-target">
<h3><span class="section-number">6.2.4. </span>在Linux环境下更改开发板上的U-boot环境变量<a class="headerlink" href="#change-u-boot-environment-from-linux-on-target" title="Link to this heading"></a></h3>
<p>Libubootenv是我们镜像中包含的一个工具，用于在开发板linux上修改U-Boot环境。</p>
<p>使用以下命令打印U-Boot环境：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>fw_printenv
</pre></div>
</div>
<p>使用以下命令修改U-Boot环境：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>fw_setenv<span class="w"> </span>&lt;variable&gt;<span class="w"> </span>&lt;value&gt;
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>Libubootenv会读取配置文件中配置的环境变量。要修改的环境变量会被插入到该文件中，默认情况下使用eMMC中存储环境变量。</p>
<p>如果eMMC没有被烧写过或者eMMC环境被擦除，libubootenv将无法工作。您应该修改 <code class="docutils literal notranslate"><span class="pre">/etc/fw_env.config</span></code> 文件，以匹配您想要使用的环境源。</p>
</div>
</section>
</section>
</section>
<section id="accessing-peripherals">
<h1><span class="section-number">7. </span>访问外设<a class="headerlink" href="#accessing-peripherals" title="Link to this heading"></a></h1>
<p>To find out which boards and modules are supported by the release of PHYTEC's
phyCORE-i.MX 8M Plus BSP described herein, visit <a class="reference external" href="https://www.phytec.de/bsp-download/?bsp=BSP-Yocto-NXP-i.MX8MP-PD22.1.1">our BSP</a> web page and click
the corresponding BSP release in the download section. Here you can find all
hardware supported in the columns &quot;Hardware Article Number&quot; and the correct
machine name in the corresponding cell under &quot;Machine Name&quot;.</p>
<p>为了最大化软件的可复用性，Linux内核提供了一个巧妙的软件架构，软件会根据不同硬件组件来分层。BSP（板级支持包）尽可能地对套件的功能进行模块化。当定制开发板或自定义核心板时，大部分软件配置可以简单的复制粘贴。与具体的开发板相关的内核代码可以在内核代码仓库中的设备树（DT）中找到，路径为 <code class="docutils literal notranslate"><span class="pre">arch/arm64/boot/dts/freescale/*.dts</span></code> 。</p>
<p>实际上，软件复用是Linux内核最重要的特性之一，尤其是在ARM架构中，它必须应对大量复杂且不同的系统级芯片（SoC）。整个开发板的硬件在设备树（DT）中描述，独立于内核镜像。硬件描述在一个单独的二进制文件中，称为设备树二进制文件（Device Tree Blob，DTB）（参见 <a class="reference internal" href="#imx8mp-pd22-1-1-device-tree"><span class="std std-ref">device tree</span></a>）。</p>
<p>请阅读PHYTEC i.MX 8M Plus BSP设备树概念部分，以了解我们的 i.MX 8 BSP设备树模型。</p>
<p>以下部分概述了 i.MX 8 平台上支持的硬件组件及其对应操作系统驱动程序。客户可以根据自身的需求进行更改。</p>
<section id="soc-pin-muxing">
<h2><span class="section-number">7.1. </span>i.MX 8M Plus 引脚复用<a class="headerlink" href="#soc-pin-muxing" title="Link to this heading"></a></h2>
<p>该 i.MX 8M Plus Soc包含许多外设接口。为了在保持最大功能性的同时减少封装尺寸和降低整体系统成本，许多 i.MX 8M Plus 引脚可以多路复用为多达八种信号功能。尽管存在许多可能的引脚多路复用组合，但由于时序限制，只有一定数量的组合被称为有效的 IO 集合。这些有效的 IO 集合经过精心挑选，以为用户提供尽可能多的应用场景。</p>
<p>请参考我们的硬件手册或NXP i.MX 8M Plus 参考手册，以获取有关特定引脚和复用能力的更多信息。</p>
<p>IO 集合的配置，也称为复用（muxing），是在设备树中完成的。驱动程序pinctrl-single读取设备树的节点fsl,pins，并进行引脚复用配置。</p>
<p>以下是imx8mp-phyboard-pollux.dtsi中UART1的引脚复用示例：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pinctrl_uart1: uart1grp {
        fsl,pins = &lt;
                MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX     0x49
                MX8MP_IOMUXC_UART1_TXD_UART1_DCE_TX     0x49
        &gt;;
};
</pre></div>
</div>
<p>字符串的第一部分 MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX 指定了引脚（在这个例子中是 UART1_RXD）。字符串的第二部分（UART1_DCE_RX）是该引脚所选的复用项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部拉电阻是否被激活。在当前情况下，内部拉电阻被禁用。</p>
</section>
<section id="rs232-rs485">
<h2><span class="section-number">7.2. </span>RS232/RS485<a class="headerlink" href="#rs232-rs485" title="Link to this heading"></a></h2>
<p>The phyCORE-i.MX 8M Plus supports up to 4 UART units. On the phyBOARD-Pollux, TTL level signals
of UART1 (the standard console) and UART4 are routed to Silicon Labs CP2105 UART
to USB converter expansion. This USB is brought out at Micro-USB connector X1.
UART3 is at X6 (Expansion Connector) at TTL level. UART2 is connected to a
multi-protocol transceiver for RS-232 and RS-485, available at pin header
connector <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">X2</span></a> at the RS-232 level, or at the RS-485 level. The
configuration of the multi-protocol transceiver is done by jumpers <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">JP3</span></a> and
<a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">JP4</span></a> on the baseboard. For more information about the correct setup please
refer to the phyCORE-i.MX 8M Plus/phyBOARD-Pollux Hardware Manual section UARTs.</p>
<p>对于RS-232和RS-485，使用相同的设备树节点。RS485模式可以通过ioctl TIOCSRS485 来启用。双向通讯支持也可以通过ioctl进行配置。请查看我们的小示例应用程序rs485test，该程序也包含在BSP中。需要设置跳线 <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">JP3</span></a> 和 <a class="reference internal" href="#imx8mp-pd22-1-1-components"><span class="std std-ref">JP4</span></a> 。</p>
<section id="rs232">
<h3><span class="section-number">7.2.1. </span>RS232<a class="headerlink" href="#rs232" title="Link to this heading"></a></h3>
<ul>
<li><p>以人类可读的格式显示终端的当前设置：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>stty<span class="w"> </span>-a
</pre></div>
</div>
</li>
<li><p>UART接口的配置可以通过stty命令完成。例如：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>stty<span class="w"> </span>-F<span class="w"> </span>/dev/ttymxc1<span class="w"> </span><span class="m">115200</span><span class="w"> </span>crtscts<span class="w"> </span>raw<span class="w"> </span>-echo
</pre></div>
</div>
</li>
<li><p>通过简单的echo和cat，可以测试基本的通信。示例：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">123</span><span class="w"> </span>&gt;<span class="w"> </span>/dev/ttymxc1
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>cat<span class="w"> </span>/dev/ttyUSB2
</pre></div>
</div>
</li>
</ul>
<p>主机应打印出 &quot;123&quot;。</p>
</section>
<section id="rs485">
<h3><span class="section-number">7.2.2. </span>RS485<a class="headerlink" href="#rs485" title="Link to this heading"></a></h3>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>在使用较长电缆时，请记得在总线两端各使用120欧姆的终端电阻。</p>
</div>
<p>为了方便测试，请查看linux-serial-test。这个工具会通过调用RS485的IOCTL，发送恒定的数据流。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>linux-serial-test<span class="w"> </span>-p<span class="w"> </span>/dev/ttymxc1<span class="w"> </span>-b<span class="w"> </span><span class="m">115200</span><span class="w"> </span>--rs485<span class="w"> </span><span class="m">0</span>
</pre></div>
</div>
<p>有关linux-serial-test工具及其参数的更多信息，请访问此链接：<a class="reference external" href="https://github.com/cbrake/linux-serial-test">linux-serial-test</a></p>
<p>linux-serial-test会自动设置ioctl，也可以通过rs485conf手动设置。</p>
<p>你可以用以下命令显示当前配置：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>rs485conf<span class="w"> </span>/dev/ttymxc1
</pre></div>
</div>
<p>您可以通过以下方式列出帮助选项：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>rs485conf<span class="w"> </span>/dev/ttymxc1<span class="w"> </span>-h
</pre></div>
</div>
<p>Linux kernel文档描述了如何在C代码中调用IOCTL： <a class="reference external" href="https://www.kernel.org/doc/Documentation/serial/serial-rs485.txt">https://www.kernel.org/doc/Documentation/serial/serial-rs485.txt</a></p>
<p>RS232和RS485的设备树：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n331">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n331</a></p>
</section>
</section>
<section id="ethernet">
<span id="imx8mp-pd22-1-1-network"></span><h2><span class="section-number">7.3. </span>Ethernet<a class="headerlink" href="#ethernet" title="Link to this heading"></a></h2>
<p>phyBOARD-Pollux-i.MX 8M Plus 提供两个以太网接口。我们的核心板和底板各提供一个千兆以太网接口。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>硬件中的以太网接口命名约定（ethernet0 和 ethernet1）与Linux中的网络接口（eth0 和 eth1）不一致。因此，请注意这些差异：</p>
<div class="line-block">
<div class="line">ethernet1 = eth0</div>
<div class="line">ethernet0 = eth1</div>
</div>
</div>
<p>所有接口都提供一个标准的Linux网络端口，可以使用BSD套接字接口进行编程。整个网络配置由systemd-networkd守护进程管理。相关的配置文件可以在开发板的 <code class="docutils literal notranslate"><span class="pre">/lib/systemd/network/</span></code> 目录中找到，以及在BSP中的 <code class="docutils literal notranslate"><span class="pre">meta-ampliphy/recipes-core/systemd/systemd-conf</span></code> 目录中。</p>
<p>IP addresses can be configured within *.network files. The interfaces are
configured to static IP as default. The default IP address and netmask for eth0
is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0: 192.168.3.11/24
</pre></div>
</div>
<p>To configure eth0 to dynamic IP over DHCP, go to
<code class="docutils literal notranslate"><span class="pre">/lib/systemd/network/\*-eth0.network</span></code> and delete the line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Address=192.168.3.11/24
</pre></div>
</div>
<p>The DT Ethernet setup might be split into two files depending on your hardware
configuration: the module DT and the board-specific DT. The device tree set up
for the ethernet where the PHY is populated on the SoM can be found here:
<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n41">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n41</a>.</p>
<p>The device tree set up for EQOS Ethernet IP core where the PHY is populated
on the phyBOARD-Pollux can be found here:
<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n141">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n141</a>.</p>
<section id="network-environment-customization">
<h3><span class="section-number">7.3.1. </span>网络配置<a class="headerlink" href="#network-environment-customization" title="Link to this heading"></a></h3>
<section id="u-boot-network-environment">
<h4><span class="section-number">7.3.1.1. </span>U-boot网络环境<a class="headerlink" href="#u-boot-network-environment" title="Link to this heading"></a></h4>
<ul>
<li><p>要在bootloader中查找以太网设置：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; printenv ipaddr serverip netmask
</pre></div>
</div>
</li>
<li><p>在将主机设置为IP 192.168.3.10和子网掩码255.255.255.0的情况下，开发板应该返回：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; printenv ipaddr serverip netmask
ipaddr=192.168.3.11
serverip=192.168.3.10
netmask=255.225.255.0
</pre></div>
</div>
</li>
<li><p>如果您需要进行任何更改：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv &lt;parameter&gt; &lt;value&gt;
</pre></div>
</div>
<p>&lt;parameter&gt; 应该是 ipaddr、netmask、gatewayip 或 serverip 中的一个。&lt;value&gt; 将是所选参数的设定值。</p>
</li>
<li><p>您所做的更改目前是临时的。要保存这些更改：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; saveenv
</pre></div>
</div>
</li>
</ul>
<p>在这里，您也可以将IP地址更改为DHCP，而不是使用静态IP地址。</p>
<ul>
<li><p>配置：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv ip dhcp
</pre></div>
</div>
</li>
<li><p>设置 TFTP 和 NFS 的路径。修改可以如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; setenv nfsroot /home/user/nfssrc
</pre></div>
</div>
</li>
</ul>
<p>请注意，这些修改只会影响bootloader的设置。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>像nfsroot和netargs这样的变量可以被U-boot外部环境重新赋值。对于网络启动，外部环境将通过tftp加载。例如，要在 <code class="docutils literal notranslate"><span class="pre">bootenv.txt</span></code> 文件中设置nfsroot变量，请在tftproot目录修改：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nfsroot=/home/user/nfssrc
</pre></div>
</div>
<p>无需在开发板上存储这些信息。请注意，U-boot外部环境对于像 ipaddr 或 serveraddr 这样的变量不起作用，因为它们在加载外部环境之前已经被设置完成。</p>
</div>
</section>
<section id="kernel-network-environment">
<h4><span class="section-number">7.3.1.2. </span>内核网络环境<a class="headerlink" href="#kernel-network-environment" title="Link to this heading"></a></h4>
<ul>
<li><p>在开发板中查找eth0的以太网设置：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>-statistics<span class="w"> </span>address<span class="w"> </span>show<span class="w"> </span>eth0
<span class="go">2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span>
<span class="go">    link/ether 50:2d:f4:19:d6:33 brd ff:ff:ff:ff:ff:ff</span>
<span class="go">    RX:  bytes packets errors dropped  missed   mcast</span>
<span class="go">             0       0      0       0       0       0</span>
<span class="go">    TX:  bytes packets errors dropped carrier collsns</span>
<span class="go">             0       0      0       0       0       0</span>
</pre></div>
</div>
</li>
<li><p>临时调整eth0的配置：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>address<span class="w"> </span>add<span class="w"> </span><span class="m">192</span>.168.3.11/24<span class="w"> </span>dev<span class="w"> </span>eth0
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>
<section id="wlan-bluetooth">
<h2><span class="section-number">7.4. </span>WLAN/Bluetooth<a class="headerlink" href="#wlan-bluetooth" title="Link to this heading"></a></h2>
<p>在 phyBOARD-Pollux 上，WLAN和蓝牙由PEB-WLBT-05扩展板提供。PEB-WLBT-05的 phyBOARD-Pollux 快速入门指南向您展示了如何安装PEB-WLBT-05。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>对于BSP版本PD22.1及更新版本，需要先激活PEB-WLBT-05 Overlay，否则PEB-WLBT-05将无法被识别。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>vi<span class="w"> </span>/boot/bootenv.txt
</pre></div>
</div>
<p>之后，bootenv.txt 文件应该如下所示（它还可以包含其他设备树overlay！）：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>overlays=imx8mp-phyboard-pollux-peb-wlbt-05.dtbo
</pre></div>
</div>
<p>更改将在重启后应用：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>reboot
</pre></div>
</div>
<p>有关设备树overlay的更多信息，请阅读 <a class="reference internal" href="#imx8mp-pd22-1-1-device-tree"><span class="std std-ref">device tree</span></a> 章节。</p>
</div>
<p>为了支持WLAN和蓝牙，我们使用来自LSR的Sterling-LWB模块。该模块支持2.4 GHz，并且可以在多种模式下运行，如客户端模式、使用WEP、WPA、WPA2加密的接入点（AP）模式等。有关该模块的更多信息，请访问 <a class="reference external" href="https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf">https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf</a></p>
<section id="connecting-to-a-wlan-network">
<h3><span class="section-number">7.4.1. </span>连接到WLAN网络<a class="headerlink" href="#connecting-to-a-wlan-network" title="Link to this heading"></a></h3>
<p>首先设置您所在国家的正确监管域：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>iw<span class="w"> </span>reg<span class="w"> </span><span class="nb">set</span><span class="w"> </span>DE
<span class="gp">target:~$ </span>iw<span class="w"> </span>reg<span class="w"> </span>get
</pre></div>
</div>
<p>你将会看到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>country DE: DFS-ETSI
   (2400 - 2483 @ 40), (N/A, 20), (N/A)
   (5150 - 5250 @ 80), (N/A, 20), (N/A), NO-OUTDOOR
   (5250 - 5350 @ 80), (N/A, 20), (0 ms), NO-OUTDOOR, DFS
   (5470 - 5725 @ 160), (N/A, 26), (0 ms), DFS
   (57000 - 66000 @ 2160), (N/A, 40), (N/A)
</pre></div>
</div>
<p>设置无线接口：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>link
<span class="gp">target:~$ </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>up<span class="w"> </span>dev<span class="w"> </span>wlan0
</pre></div>
</div>
<p>现在您可以扫描可用的网络：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>iw<span class="w"> </span>wlan0<span class="w"> </span>scan<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>SSID
</pre></div>
</div>
<p>您可以使用一个跨平台的客户端，名为wpa_supplicant，支持WEP、WPA和WPA2，以建立加密连接。</p>
<p>为此，请将网络凭据添加到文件 <code class="docutils literal notranslate"><span class="pre">/etc/wpa_supplicant.conf</span></code> 中：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>country=DE
network={
    ssid=&quot;&lt;SSID&gt;&quot;
    proto=WPA2
    psk=&quot;&lt;KEY&gt;&quot;
}
</pre></div>
</div>
<p>现在可以建立连接：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>wpa_supplicant<span class="w"> </span>-D<span class="w"> </span>nl80211<span class="w"> </span>-c<span class="w"> </span>/etc/wpa_supplicant.conf<span class="w"> </span>-i<span class="w"> </span>wlan0<span class="w"> </span>-B
</pre></div>
</div>
<p>这会得到如下输出：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...
ENT-CONNECTED - Connection to 88:33:14:5d:db:b1 completed [id=0 id_str=]
</pre></div>
</div>
<p>要完成配置，您可以配置DHCP以接收IP地址（大多数WLAN接入点都支持）。有关其他可能的IP配置，请参阅 <a class="reference external" href="https://www.phytec.de/cdocuments/?doc=UIHsG">L-813e.A12 Yocto Reference Manual (Hardknott)</a> 中的“更改网络配置”部分。</p>
<p>首先，创建目录：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mkdir<span class="w"> </span>-p<span class="w"> </span>/etc/systemd/network/
</pre></div>
</div>
<p>然后在 <code class="docutils literal notranslate"><span class="pre">/etc/systemd/network/10-wlan0.network</span></code> 中添加以下配置片段：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># file /etc/systemd/network/10-wlan0.network
[Match]
Name=wlan0

[Network]
DHCP=yes
</pre></div>
</div>
<p>现在，请重启网络守护进程以使配置生效：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>restart<span class="w"> </span>systemd-networkd
</pre></div>
</div>
</section>
</section>
<section id="bluetooth">
<h2><span class="section-number">7.5. </span>蓝牙<a class="headerlink" href="#bluetooth" title="Link to this heading"></a></h2>
<p>开发板 phyBOARD-Pollux 可以通过PEB-WLBT-05扩展板支持蓝牙。如何在系统中使能它在WLAN部分中有描述。</p>
<p>蓝牙连接到 UART3 接口。有关该模块的更多信息，请访问 <a class="reference external" href="https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf">https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf</a>。蓝牙设备需要手动设置：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>up

<span class="gp">target:~$ </span>hciconfig<span class="w"> </span>-a

<span class="go">hci0:   Type: Primary  Bus: UART</span>
<span class="go">        BD Address: 00:25:CA:2F:39:96  ACL MTU: 1021:8  SCO MTU: 64:1</span>
<span class="go">        UP RUNNING PSCAN</span>
<span class="go">        RX bytes:1392 acl:0 sco:0 events:76 errors:0</span>
<span class="go">        TX bytes:1198 acl:0 sco:0 commands:76 errors:0</span>
<span class="go">        ...</span>
</pre></div>
</div>
<p>现在您可以扫描环境中的可见蓝牙设备。在默认配置下，蓝牙是不可见的。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hcitool<span class="w"> </span>scan
<span class="go">Scanning ...</span>
<span class="go">       XX:XX:XX:XX:XX:XX       &lt;SSID&gt;</span>
</pre></div>
</div>
<section id="visibility">
<h3><span class="section-number">7.5.1. </span>可见性<a class="headerlink" href="#visibility" title="Link to this heading"></a></h3>
<p>要激活可见性：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>piscan
</pre></div>
</div>
<p>要禁用可见性：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>noscan
</pre></div>
</div>
</section>
<section id="connect">
<h3><span class="section-number">7.5.2. </span>连接<a class="headerlink" href="#connect" title="Link to this heading"></a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>bluetoothctl
<span class="gp">[bluetooth]# </span>discoverable<span class="w"> </span>on
<span class="go">Changing discoverable on succeeded</span>
<span class="gp">[bluetooth]# </span>pairable<span class="w"> </span>on
<span class="go">Changing pairable on succeeded</span>
<span class="gp">[bluetooth]# </span>agent<span class="w"> </span>on
<span class="go">Agent registered</span>
<span class="gp">[bluetooth]# </span>default-agent
<span class="go">Default agent request successful</span>
<span class="gp">[bluetooth]# </span>scan<span class="w"> </span>on
<span class="go">[NEW] Device XX:XX:XX:XX:XX:XX &lt;name&gt;</span>
<span class="gp">[bluetooth]# </span>connect<span class="w"> </span>XX:XX:XX:XX:XX:XX
</pre></div>
</div>
<p>Bluetooth is connected to UART3 interface.
The Bluetooth device needs to be set up manually:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>up

<span class="gp">target:~$ </span>hciconfig<span class="w"> </span>-a

<span class="go">hci0:   Type: Primary  Bus: UART</span>
<span class="go">        BD Address: 00:25:CA:2F:39:96  ACL MTU: 1021:8  SCO MTU: 64:1</span>
<span class="go">        UP RUNNING PSCAN</span>
<span class="go">        RX bytes:1392 acl:0 sco:0 events:76 errors:0</span>
<span class="go">        TX bytes:1198 acl:0 sco:0 commands:76 errors:0</span>
<span class="go">        ...</span>
</pre></div>
</div>
<p>现在您可以扫描环境中的可见蓝牙设备。在默认配置下，蓝牙是不可见的。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hcitool<span class="w"> </span>scan
<span class="go">Scanning ...</span>
<span class="go">       XX:XX:XX:XX:XX:XX       &lt;SSID&gt;</span>
</pre></div>
</div>
</section>
<section id="id1">
<h3><span class="section-number">7.5.3. </span>可见性<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>要激活可见性：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>piscan
</pre></div>
</div>
<p>要禁用可见性：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hciconfig<span class="w"> </span>hci0<span class="w"> </span>noscan
</pre></div>
</div>
</section>
<section id="id2">
<h3><span class="section-number">7.5.4. </span>连接<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>bluetoothctl
<span class="gp">[bluetooth]# </span>discoverable<span class="w"> </span>on
<span class="go">Changing discoverable on succeeded</span>
<span class="gp">[bluetooth]# </span>pairable<span class="w"> </span>on
<span class="go">Changing pairable on succeeded</span>
<span class="gp">[bluetooth]# </span>agent<span class="w"> </span>on
<span class="go">Agent registered</span>
<span class="gp">[bluetooth]# </span>default-agent
<span class="go">Default agent request successful</span>
<span class="gp">[bluetooth]# </span>scan<span class="w"> </span>on
<span class="go">[NEW] Device XX:XX:XX:XX:XX:XX &lt;name&gt;</span>
<span class="gp">[bluetooth]# </span>connect<span class="w"> </span>XX:XX:XX:XX:XX:XX
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果连接失败并出现错误信息： &quot;Failed to connect: org.bluez.Error.Failed&quot;，请尝试使用以下命令重新启动PulseAudio：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>pulseaudio<span class="w"> </span>--start
</pre></div>
</div>
</div>
</section>
</section>
<section id="sd-card">
<h2><span class="section-number">7.6. </span>SD card<a class="headerlink" href="#sd-card" title="Link to this heading"></a></h2>
<p>The i.MX 8M Plus supports a slot for Secure Digital cards to be used as general-purpose
block devices. These devices can be used in the same way as any other block
device.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>这些设备是热插拔的。然而，您必须确保在设备仍然挂载时不要拔掉它。这可能会导致数据丢失！</p>
</div>
<p>After inserting an SD card, the kernel will generate new device nodes in /dev.
The full device can be reached via its /dev/mmcblk1 device node. SD card
partitions will show up as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/dev/mmcblk1p&lt;Y&gt;
</pre></div>
</div>
<p>&lt;Y&gt; 作为分区编号，从1开始计数，直到该设备的最大分区数量。分区可以使用任何类型的文件系统进行格式化，并且可以以标准方式进行处理，例如，可以使用mount 和 umount 命令进行分区挂载和卸载。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>这些分区设备节点要求SD卡包含有效的分区表（类似于“硬盘”）。如果没有分区表，则整个设备作为一个文件系统使用（类似于“软盘”）。在这种情况下，必须使用 /dev/mmcblk1 进行格式化和挂载。卡始终以可写方式挂载。</p>
</div>
<p>MMC（SD卡插槽）接口的DT配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n367">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n367</a></p>
<p>eMMC接口的DT配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n220">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n220</a></p>
</section>
<section id="emmc-devices">
<h2><span class="section-number">7.7. </span>eMMC设备<a class="headerlink" href="#emmc-devices" title="Link to this heading"></a></h2>
<p>PHYTEC modules like phyCORE-i.MX 8M Plus is populated with an eMMC memory chip as the
main storage. eMMC devices contain raw MLC memory cells combined with a memory
controller that handles ECC and wear leveling. They are connected via an SD/MMC
interface to the i.MX 8M Plus and are represented as block devices in the Linux kernel
like SD cards, flash drives, or hard disks.</p>
<p>电气和协议规范由JEDEC提供（<a class="reference external" href="https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc">https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc</a>）。eMMC制造商的数据手册相对较简单，旨在与支持的JEDEC eMMC标准版本一起阅读。</p>
<p>PHYTEC目前使用JEDEC版本5.0和5.1的eMMC芯片。</p>
<section id="extended-csd-register">
<h3><span class="section-number">7.7.1. </span>扩展CSD寄存器<a class="headerlink" href="#extended-csd-register" title="Link to this heading"></a></h3>
<p>通过扩展CSD寄存器可以读取eMMC设备其他的信息和配置。有关寄存器的详细列表，请参阅制造商的数据手册和JEDEC标准。</p>
<p>在Linux用户空间中，您可以查询寄存器：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>extcsd<span class="w"> </span><span class="nb">read</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p>你将会看到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>=============================================
   Extended CSD rev 1.7 (MMC 5.0)
=============================================

 Card Supported Command sets [S_CMD_SET: 0x01]
 [...]
</pre></div>
</div>
</section>
<section id="enabling-background-operations-bkops">
<h3><span class="section-number">7.7.2. </span>使能后台操作 (BKOPS)<a class="headerlink" href="#enabling-background-operations-bkops" title="Link to this heading"></a></h3>
<p>与原始NAND Flash相比，eMMC设备包含一个闪存传输层（FTL），负责处理原始MLC单元的磨损平衡、块管理和错误纠正码（ECC）。这需要定期进行一些维护任务（例如擦除未使用的块）。这些任务被称为 <strong>后台操作（BKOPS）</strong> 。</p>
<p>默认情况下（取决于芯片），后台操作可能会定期执行，也可能不会，他影响读写的最大延迟时间。</p>
<p>JEDEC标准自版本v4.41起规定了一种方法，主机可以手动触发BKOPS。有关更多详细信息，请参阅JEDEC标准章节“Background Operations”以及eMMC数据手册中寄存器BKOPS_EN（寄存器：163）和BKOPS_START（寄存器：164）的描述。</p>
<p>寄存器 BKOPS_EN（寄存器：163）的位 MANUAL_EN（位 0）的含义：</p>
<ul class="simple">
<li><p>值 0：主机不支持手动触发 BKOPS。设备写入性能会受到影响。</p></li>
<li><p>值1：主机支持手动触发BKOPS。当主机不进行设备读写时，它会不时触发BKOPS。</p></li>
</ul>
<p>自v3.7版本以来，Linux内核已经实现了触发后台操作的机制。您只需在eMMC设备上启用BKOPS_EN（详细信息见下文）。</p>
<p>JEDEC标准v5.1引入了一种新的自动BKOPS功能。它使主机能够定期触发后台操作，因为设备在空闲时会自动启动BKOPS（请参见寄存器BKOPS_EN（寄存器：163）中位AUTO_EN的描述）。</p>
<p>mmc这个linux工具目前不支持启用自动BKOPS功能。</p>
<ul>
<li><p>要检查 <em>BKOPS_EN</em> 是否已设置，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>extcsd<span class="w"> </span><span class="nb">read</span><span class="w"> </span>/dev/mmcblk2<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>BKOPS_EN
</pre></div>
</div>
<p>输出将会是，例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enable background operations handshake [BKOPS_EN]: 0x01
#OR
Enable background operations handshake [BKOPS_EN]: 0x00
</pre></div>
</div>
<p>值0x00表示BKOPS_EN被禁用，设备的写入性能受到影响。值0x01表示BKOPS_EN被启用，主机将不时发起后台操作。</p>
</li>
<li><p>要设置BKOPS_EN位，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>bkops<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
</li>
<li><p>为了确保新设置生效并且内核能够自动触发BKOPS，请先关闭系统：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>poweroff
</pre></div>
</div>
</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>BKOPS_EN位是一次性可编程的，无法恢复。</p>
</div>
</section>
<section id="reliable-write">
<h3><span class="section-number">7.7.3. </span>可靠写入<a class="headerlink" href="#reliable-write" title="Link to this heading"></a></h3>
<p>有两种不同的可靠写入选项：</p>
<ol class="arabic simple">
<li><p>对整个eMMC设备/分区的可靠写入方式。</p></li>
<li><p>单次写的可靠写入方式。</p></li>
</ol>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>不要将 eMMC 分区与 DOS、MBR 或 GPT 分区表的分区混淆（请参阅前一节）。</p>
</div>
<p>The first Reliable Write option is mostly already enabled on the eMMCs mounted
on the phyCORE-i.MX 8M Plus SoMs. To check this on the running target:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>extcsd<span class="w"> </span><span class="nb">read</span><span class="w"> </span>/dev/mmcblk2<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-A<span class="w"> </span><span class="m">5</span><span class="w"> </span>WR_REL_SET
<span class="go">Write reliability setting register [WR_REL_SET]: 0x1f</span>
<span class="go"> user area: the device protects existing data if a power failure occurs during a write o</span>
<span class="go">peration</span>
<span class="go"> partition 1: the device protects existing data if a power failure occurs during a write</span>
<span class="go"> operation</span>
<span class="go"> partition 2: the device protects existing data if a power failure occurs during a write</span>
<span class="go"> operation</span>
<span class="go"> partition 3: the device protects existing data if a power failure occurs during a write</span>
<span class="go"> operation</span>
<span class="go"> partition 4: the device protects existing data if a power failure occurs during a write</span>
<span class="go"> operation</span>
<span class="go">--</span>
<span class="go"> Device supports writing EXT_CSD_WR_REL_SET</span>
<span class="go"> Device supports the enhanced def. of reliable write</span>
</pre></div>
</div>
<p>如果默认没有启用，可以使用mmc工具启用它：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>--help

<span class="go">[...]</span>
<span class="go">mmc write_reliability set &lt;-y|-n&gt; &lt;partition&gt; &lt;device&gt;</span>
</pre></div>
</div>
<p>第二个可靠写入方式是命令CMD23中的配置位Reliable Write Request parameter（可靠写入请求参数）（位31）。自内核版本v3.0起，文件系统（例如ext4的日志）和用户空间应用程序（如fdisk的分区表）会通过内核使用该可靠写功能。在Linux内核源代码中，它通过标志REQ_META进行处理。</p>
<p><strong>结论</strong>：使用挂载选项 data=journal 的 ext4 文件系统在断电情况下是安全的。文件系统检查可以在断电后恢复文件系统，但在断电前刚写入的数据可能会丢失。在各种情况下，都可以恢复文件系统的正常状态。为了确保应用程序文件的正常保存，应用程序中应使用系统函数 fdatasync 或 fsync。</p>
</section>
<section id="resizing-ext4-root-filesystem">
<h3><span class="section-number">7.7.4. </span>调整 ext4 根文件系统的大小<a class="headerlink" href="#resizing-ext4-root-filesystem" title="Link to this heading"></a></h3>
<p>在将SD卡镜像写入eMMC时，ext4文件系统分区没有扩展到eMMC的末尾。可以使用parted来扩展根分区。这个示例适用于任何块设备，例如eMMC、SD卡或硬盘。</p>
<ul>
<li><p>获取当前设备大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>parted<span class="w"> </span>/dev/mmcblk2<span class="w"> </span>print
</pre></div>
</div>
</li>
<li><p>输出如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Model: MMC Q2J55L (sd/mmc)
Disk /dev/mmcblk2: 7617MB
Sect[ 1799.850385]  mmcblk2: p1 p2
or size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type     File system  Flags
 1      4194kB  72.4MB  68.2MB  primary  fat16        boot, lba
 2      72.4MB  537MB   465MB   primary  ext4
</pre></div>
</div>
</li>
<li><p>使用parted将文件系统分区调整为设备的最大大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>parted<span class="w"> </span>/dev/mmcblk2<span class="w"> </span>resizepart<span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">100</span>%
<span class="go">Information: You may need to update /etc/fstab.</span>

<span class="gp">target:~$ </span>parted<span class="w"> </span>/dev/mmcblk2<span class="w"> </span>print
<span class="go">Model: MMC Q2J55L (sd/mmc)</span>
<span class="go">Disk /dev/mmcblk2: 7617MB</span>
<span class="go">Sector size (logical/physical): 512[ 1974.191657]  mmcblk2: p1 p2</span>
<span class="go">B/512B</span>
<span class="go">Partition Table: msdos</span>
<span class="go">Disk Flags:</span>

<span class="go">Number  Start   End     Size    Type     File system  Flags</span>
<span class="go"> 1      4194kB  72.4MB  68.2MB  primary  fat16        boot, lba</span>
<span class="go"> 2      72.4MB  7617MB  7545MB  primary  ext4</span>
</pre></div>
</div>
</li>
</ul>
<p>在文件系统挂载时可以增加其大小。但您也可以从SD卡启动板，然后在eMMC分区未挂载时调整文件系统的大小。</p>
<ul>
<li><p>将文件系统调整为新的分区大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>resize2fs<span class="w"> </span>/dev/mmcblk2p2
<span class="go">resize2fs 1.46.1 (9-Feb-2021)</span>
<span class="go">Filesystem at /dev/mmcblk2p2 is mounted on /; on-line resizing required</span>
<span class="go">[ 131.609512] EXT4-fs (mmcblk2p2): resizing filesystem</span>
<span class="go">from 454136 to 7367680 blocks</span>
<span class="go">old_desc_blocks = 4, new_desc_blocks = 57</span>
<span class="go">[ 131.970278] EXT4-fs (mmcblk2p2): resized filesystem to 7367680</span>
<span class="go">The filesystem on /dev/mmcblk2p2 is now 7367680 (1k) blocks long</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="enable-pseudo-slc-mode">
<h3><span class="section-number">7.7.5. </span>启用伪SLC模式<a class="headerlink" href="#enable-pseudo-slc-mode" title="Link to this heading"></a></h3>
<p>eMMC设备使用 <a class="reference external" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E5%8D%95%E5%85%83">多层单元内存（MLC）</a> 来存储数据。与NAND Flash中使用的单层单元（SLC）内存单元相比，MLC内存单元具有更低的可靠性和更高的错误率，但成本更低。</p>
<p>如果您更喜欢可靠性而不是存储容量，可以启用伪SLC模式或SLC模式。这个方法采用了增强属性，该属性在JEDEC标准中有所描述，可以对设备的一个连续区域设置。JEDEC标准并未规定增强属性的实现细节和保证，这由芯片制造商自行决定。对于美光（Micron）芯片，增强属性提高了可靠性，但也将容量减半。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在设备上启用增强属性时，所有数据将被丢失。</p>
</div>
<p>以下步骤展示了如何启用增强属性。</p>
<ul>
<li><p>首先使用以下命令获取eMMC设备的当前大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>parted<span class="w"> </span>-m<span class="w"> </span>/dev/mmcblk2<span class="w"> </span>unit<span class="w"> </span>B<span class="w"> </span>print
</pre></div>
</div>
<p>你将收到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BYT;
/dev/mmcblk2:63652757504B:sd/mmc:512:512:unknown:MMC S0J58X:;
</pre></div>
</div>
<p>如您所见，该设备的容量为 63652757504 字节 = 60704 MiB。</p>
</li>
<li><p>要获取启用伪SLC模式后的设备的大小，请使用：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>extcsd<span class="w"> </span><span class="nb">read</span><span class="w"> </span>/dev/mmcblk2<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>ENH_SIZE_MULT<span class="w"> </span>-A<span class="w"> </span><span class="m">1</span>
</pre></div>
</div>
<p>例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Max Enhanced Area Size [MAX_ENH_SIZE_MULT]: 0x000764
i.e. 3719168 KiB
--
Enhanced User Data Area Size [ENH_SIZE_MULT]: 0x000000
i.e. 0 KiB
</pre></div>
</div>
<p>这里的最大大小是3719168 KiB = 3632 MiB。</p>
</li>
<li><p>现在，您可以通过输入以下命令为整个设备设置增强属性，例如 3719168 KiB：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>enh_area<span class="w"> </span><span class="nb">set</span><span class="w"> </span>-y<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">3719168</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p>你将获得：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Done setting ENH_USR area on /dev/mmcblk2
setting OTP PARTITION_SETTING_COMPLETED!
Setting OTP PARTITION_SETTING_COMPLETED on /dev/mmcblk2 SUCCESS
Device power cycle needed for settings to take effect.
Confirm that PARTITION_SETTING_COMPLETED bit is set using &#39;extcsd read&#39; after power cycle
</pre></div>
</div>
</li>
<li><p>为了确保新设置已生效，请关闭系统：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>poweroff
</pre></div>
</div>
<p>并进行上下电。建议您现在确认设置是否正确。</p>
</li>
<li><p>首先，检查ENH_SIZE_MULT的值，它必须是3719168 KiB：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>extcsd<span class="w"> </span><span class="nb">read</span><span class="w"> </span>/dev/mmcblk2<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>ENH_SIZE_MULT<span class="w">  </span>-A<span class="w"> </span><span class="m">1</span>
</pre></div>
</div>
<p>您应该看到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Max Enhanced Area Size [MAX_ENH_SIZE_MULT]: 0x000764
i.e. 3719168 KiB
--
Enhanced User Data Area Size [ENH_SIZE_MULT]: 0x000764
i.e. 3719168 KiB
</pre></div>
</div>
</li>
<li><p>最后，检查设备的大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>parted<span class="w"> </span>-m<span class="w"> </span>/dev/mmcblk2<span class="w"> </span>unit<span class="w"> </span>B<span class="w"> </span>print
<span class="go">BYT;</span>
<span class="go">/dev/mmcblk2:31742492672B:sd/mmc:512:512:unknown:MMC S0J58X:;</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="erasing-the-device">
<h3><span class="section-number">7.7.6. </span>擦除设备<a class="headerlink" href="#erasing-the-device" title="Link to this heading"></a></h3>
<p>可以直接擦除eMMC设备，而不是用零覆盖它。eMMC块管理算法将会擦除MLC存储单元或将这些块标记为丢弃。设备上的数据将丢失，并且读取为零。</p>
<ul>
<li><p>SD卡启动后执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>blkdiscard<span class="w"> </span>-f<span class="w"> </span>--secure<span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p>选项 --secure 确保命令在 eMMC 设备擦除所有块之前会等待。-f (强制) 选项强制擦写，当 eMMC 设备包含有效数据分区时需要使用-f选项。</p>
</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/dev/zero<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2<span class="w"> </span><span class="nv">conv</span><span class="o">=</span>fsync
</pre></div>
</div>
<p>该命令也会擦除设备上的所有信息，但这个命令不利于设备的磨损均衡，并且需要花费更长的时间！</p>
</div>
</section>
<section id="e-mmc-boot-partitions">
<h3><span class="section-number">7.7.7. </span>e.MMC Boot Partitions<a class="headerlink" href="#e-mmc-boot-partitions" title="Link to this heading"></a></h3>
<p>An e.MMC device contains four different hardware partitions: user, boot1, boot2,
and rpmb.</p>
<p>The user partition is called the User Data Area in the JEDEC standard and is the
main storage partition. The partitions boot1 and boot2 can be used to host the
bootloader and are more reliable. Which partition the i.MX 8M Plus uses to load
the bootloader is controlled by the boot configuration of the e.MMC device. The
partition rpmb is a small partition and can only be accessed via a trusted
mechanism.</p>
<p>此外，User分区可以分为四个自定义的一般用途分区。对此功能的解释不在本文件涵盖的范围。有关更多信息，请参阅JEDEC标准第7.2章分区管理。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>Do not confuse e.MMC partitions with partitions of a DOS, MBR, or GPT
partition table.</p>
</div>
<p>The current PHYTEC BSP does not use the extra partitioning feature of e.MMC
devices. The U-Boot is flashed at the beginning of the user partition.
The U-Boot environment is placed at a fixed location after the U-Boot. An MBR
partition table is used to create two partitions, a FAT32 boot, and ext4 rootfs
partition. They are located right after the U-Boot and the U-Boot environment.
The FAT32 boot partition contains the kernel and device tree.</p>
<p>With e.MMC flash storage it is possible to use the dedicated boot partitions for
redundantly storing the bootloader. The Bootloader environment still resides in
the user area before the first partition. The user area also still contains the
bootloader which the image first shipped during its initialization process.
Below is an example, to flash the bootloader to one of the two boot partitions
and switch the boot device via userspace commands.</p>
<section id="via-userspace-commands">
<h4><span class="section-number">7.7.7.1. </span>通过用户空间命令<a class="headerlink" href="#via-userspace-commands" title="Link to this heading"></a></h4>
<p>在主机上运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>scp<span class="w"> </span>&lt;bootloader&gt;<span class="w"> </span>root@192.168.3.11:/tmp/
</pre></div>
</div>
<p>默认情况下，boot1和boot2分区是只读的。要从用户空间写入它们，您必须在sysfs中禁用force_ro。</p>
<p>To manually write the bootloader to the e.MMC boot partitions, first disable the
write protection:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/block/mmcblk2boot0/force_ro
<span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/block/mmcblk2boot1/force_ro
</pre></div>
</div>
<p>Write the bootloader to the e.MMC boot partitions:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/tmp/&lt;bootloader&gt;<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2boot0
<span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/tmp/&lt;bootloader&gt;<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/dev/mmcblk2boot1
</pre></div>
</div>
<p>下表是 i.MX 8M Plus SoC的偏移量：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SoC</p></th>
<th class="head"><p>User分区偏移量</p></th>
<th class="head"><p>Boot分区偏移量</p></th>
<th class="head"><p>eMMC设备</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>i.MX 8M Plus</p></td>
<td><p>32 kiB</p></td>
<td><p>0 kiB</p></td>
<td><p>/dev/mmcblk2</p></td>
</tr>
</tbody>
</table>
<p>之后使用mmc工具从用户空间设置引导分区：</p>
<p>(对于 'boot0') :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>bootpart<span class="w"> </span><span class="nb">enable</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p>(对于'boot1')：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>bootpart<span class="w"> </span><span class="nb">enable</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p id="emmc-disable-boot-part">To disable booting from the e.MMC boot partitions simply enter the following
command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>bootpart<span class="w"> </span><span class="nb">enable</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
<p>返回到User分区启动：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>mmc<span class="w"> </span>bootpart<span class="w"> </span><span class="nb">enable</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
</section>
</section>
<section id="id3">
<h3><span class="section-number">7.7.8. </span>调整 ext4 根文件系统的大小<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>fdisk可以用来扩展根文件系统。这个例子适用于任何块设备，比如eMMC、SD卡或硬盘。</p>
<ul>
<li><p>获取当前设备大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>fdisk<span class="w"> </span>-l<span class="w"> </span>/dev/mmcblk2
</pre></div>
</div>
</li>
<li><p>输出如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Disk /dev/mmcblk2: 7264 MB, 7616856064 bytes, 14876672 sectors 116224 cylinders, 4 heads, 32 sectors/track
Units: sectors of 1 * 512 = 512 bytes

Device       Boot StartCHS        EndCHS      StartLBA     EndLBA    Sectors   Size   Id Type
/dev/mmcblk2p1 *    128,0,1       1023,3,32    16384       140779     124396   60.7M   c Win95 FAT32 (LBA)
/dev/mmcblk2p2      1023,3,32     1023,3,32    141312      2192013    2050702  1001M  83 Linux
</pre></div>
</div>
</li>
<li><p>使用fdisk删除并创建一个最大化使用设备容量的分区：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>fdisk<span class="w"> </span>/dev/mmcblk2

<span class="go">The number of cylinders for this disk is set to 116224.</span>
<span class="go">There is nothing wrong with that, but this is larger than 1024,</span>
<span class="go">and could in certain setups cause problems with:</span>
<span class="go">1) software that runs at boot time (e.g., old versions of LILO)</span>
<span class="go">2) booting and partitioning software from other OSs</span>
<span class="go">   (e.g., DOS FDISK, OS/2 FDISK)</span>

<span class="go">Command (m for help): p</span>
<span class="go">Disk /dev/mmcblk2: 7264 MB, 7616856064 bytes, 14876672 sectors</span>
<span class="go">116224 cylinders, 4 heads, 32 sectors/track</span>
<span class="go">Units: sectors of 1 * 512 = 512 bytes</span>

<span class="go">Device       Boot   StartCHS        EndCHS      StartLBA     EndLBA    Sectors   Size   Id Type</span>
<span class="go">/dev/mmcblk2p1 *     128,0,1     1023,3,32         16384     140779     124396  60,7M    c Win95 FAT32 (LBA)</span>
<span class="go">/dev/mmcblk2p2     1023,3,32     1023,3,32        141312    2192013    2050702  1001M   83 Linux</span>

<span class="go">Command (m for help): d</span>
<span class="go">Partition number (1-4): 2</span>

<span class="go">Command (m for help): p</span>
<span class="go">Disk /dev/mmcblk2: 7264 MB, 7616856064 bytes, 14876672 sectors</span>
<span class="go">116224 cylinders, 4 heads, 32 sectors/track</span>
<span class="go">Units: sectors of 1 * 512 = 512 bytes</span>

<span class="go">Device       Boot StartCHS    EndCHS          StartLBA     EndLBA    Sectors  Size   Id Type</span>
<span class="go">/dev/mmcblk2p1 *  128,0,1     1023,3,32          16384     140779     124396  60.7M   c Win95 FAT32 (LBA)</span>

<span class="go">Command (m for help): n</span>
<span class="go">Partition type</span>
<span class="go">   p   primary partition (1-4)</span>
<span class="go">   e   extended</span>
<span class="go">p</span>
<span class="go">Partition number (1-4): 2</span>
<span class="go">First sector (32-14876671, default 32): 141456</span>
<span class="go">Last sector or +size{,K,M,G,T} (141456-14876671, default 14876671):</span>
<span class="go">Using default value 14876671</span>

<span class="go">Command (m for help): p</span>
<span class="go">Disk /dev/mmcblk2: 7264 MB, 7616856064 bytes, 14876672 sectors</span>
<span class="go">116224 cylinders, 4 heads, 32 sectors/track</span>
<span class="go">Units: sectors of 1 * 512 = 512 bytes</span>

<span class="go">Device       Boot StartCHS      EndCHS        StartLBA     EndLBA    Sectors  Size   Id Type</span>
<span class="go">/dev/mmcblk2p1 *   128,0,1      1023,3,32        16384     140779     124396  60.7M   c Win95 FAT32 (LBA)</span>
<span class="go">/dev/mmcblk2p2   1023,3,32      1023,3,32       141456   14876671   14735216  7194M  83 Linux</span>
</pre></div>
</div>
</li>
</ul>
<p>可以在文件系统挂载时修改文件系统的大小。这是一个在线调整大小的操作。但您也可以从SD卡启动，然后在eMMC分区未挂载时调整其文件系统的大小。此外，必须重启板子，以便读取新的分区表。</p>
</section>
</section>
<section id="spi-master">
<h2><span class="section-number">7.8. </span>SPI主设备<a class="headerlink" href="#spi-master" title="Link to this heading"></a></h2>
<p>i.MX 8M Plus 控制器包含一个 FlexSPI 和一个 ECSPI IP 核。FlexSPI 主控制器支持两个 SPI 通道，最多可连接 4 个设备。每个通道支持单通道/双通道/四通道/八通道模式的数据传输（1/2/4/8 条数据线）。ECSPI 控制器支持 3 个 SPI 接口，每个接口都有一个专用的CS（chip select）引脚。由于CS也可通过 GPIO 实现，因此每个通道上可以连接多个设备。</p>
<section id="spi-nor-flash">
<h3><span class="section-number">7.8.1. </span>SPI NOR 烧写<a class="headerlink" href="#spi-nor-flash" title="Link to this heading"></a></h3>
<p>phyCORE-i.MX 8M Plus is equipped with a QSPI NOR Flash which connects to the i.MX 8M Plus's
FlexSPI interface. The QSPI NOR Flash is suitable for booting. Please see
different sections for flashing and bootmode setup. Due to limited space on the
SPI NOR Flash, only the bootloader is stored inside. By default, the kernel,
device tree, and rootfs are taken from eMMC.</p>
<p>bootloader程序通过EEPROM数据检测是否安装了SPI Flash。如果没有安装SPI Flash，则在启动期间应用设备树overlay，通过扩展命令禁用SPI Flash设备树节点。如果没有可用的EEPROM数据，SPI NOR Flash节点将始终启用。有关更多信息，请参阅设备树overlay部分。</p>
<p>bootloader程序还可以通过内核的mtdparts启动参数修改设备树，将SPI MTD分区表传递给Linux。BSP中的默认分区布局设置为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mtdparts=30bb0000.spi:3840k(u-boot),128k(env),128k(env_redund),-(none)
</pre></div>
</div>
<p>这是一个预定义的bootloader环境变量，可以在运行时更改。从Linux用户空间，可以通过/dev/mtd&lt;N&gt;设备访问NOR Flash分区，其中&lt;N&gt;是与要访问的NOR Flash分区相关联的MTD设备编号。要找到分区的正确MTD设备编号，请在目标上运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@phyboard-pollux-imx8mp-3:~$ </span>mtdinfo<span class="w"> </span>--all
<span class="go">Count of MTD devices:           4</span>
<span class="go">Present MTD devices:            mtd0, mtd1, mtd2, mtd3</span>
<span class="go">Sysfs interface supported:      yes</span>

<span class="go">mtd0</span>
<span class="go">Name:                           u-boot</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          60 (3932160 bytes, 3.7 MiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:0</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>

<span class="go">mtd1</span>
<span class="go">Name:                           env</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          2 (131072 bytes, 128.0 KiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:2</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>

<span class="go">mtd2</span>
<span class="go">Name:                           env_redund</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          2 (131072 bytes, 128.0 KiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:4</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>

<span class="go">mtd3</span>
<span class="go">Name:                           none</span>
<span class="go">Type:                           nor</span>
<span class="go">Eraseblock size:                65536 bytes, 64.0 KiB</span>
<span class="go">Amount of eraseblocks:          448 (29360128 bytes, 28.0 MiB)</span>
<span class="go">Minimum input/output unit size: 1 byte</span>
<span class="go">Sub-page size:                  1 byte</span>
<span class="go">Character device major/minor:   90:6</span>
<span class="go">Bad blocks are allowed:         false</span>
<span class="go">Device is writable:             true</span>
</pre></div>
</div>
<p>它列出了所有MTD设备及其对应的分区名称。闪存节点在模块DTS中的SPI主节点内定义。SPI节点包含连接到此SPI总线的所有设备，在这种情况下只有SPI NOR Flash。</p>
<p>设备树中SPI主节点的定义可以在这里找到：</p>
<p><a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n72">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n72</a></p>
</section>
</section>
<section id="gpios">
<h2><span class="section-number">7.9. </span>GPIOs<a class="headerlink" href="#gpios" title="Link to this heading"></a></h2>
<p>phyBOARD-Pollux 具有一组专门用于GPIO的引脚。这些引脚直接连接到 i.MX 8M Plus 引脚，并被复用为 GPIO。它们可以直接在 Linux 用户空间中使用。处理器将其 GPIO 组织为5个GPIO组（GPIO1 – GPIO5），每个组包含 32 个GPIO。gpiochip0、gpiochip32、gpiochip64、gpiochip96 和 gpiochip128 是这些内部 i.MX 8M Plus GPIO 组 GPIO1 – GPIO5 的 sysfs 表示。</p>
<p>GPIO被标识为GPIO&lt;X&gt;_&lt;Y&gt;（例如：GPIO5_07）。&lt;X&gt;表示GPIO Bank，从1计数到5，而&lt;Y&gt;表示该Bank内的GPIO。&lt;Y&gt;从0计数到31（每个bank有32个GPIO）。</p>
<p>相比之下，Linux内核使用一个单一的整数来枚举系统中所有可用的GPIO。计算正确数字的公式是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Linux GPIO number: &lt;N&gt; = (&lt;X&gt; - 1) * 32 + &lt;Y&gt;
</pre></div>
</div>
<p>从用户空间访问GPIO将使用libgpiod。它提供了一个库和工具，用于与Linux GPIO字符设备进行交互。以下是一些工具的用法示例：</p>
<ul>
<li><p>检测芯片上的gpiochips：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gpiodetect
<span class="go">gpiochip0 [30200000.gpio] (32 lines)</span>
<span class="go">gpiochip1 [30210000.gpio] (32 lines)</span>
<span class="go">gpiochip2 [30220000.gpio] (32 lines)</span>
<span class="go">gpiochip3 [30230000.gpio] (32 lines)</span>
<span class="go">gpiochip4 [30240000.gpio] (32 lines)</span>
</pre></div>
</div>
</li>
<li><p>显示关于gpiochips的详细信息，包括它们的名称、consumer、方向、活动状态和附加flag：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gpioinfo<span class="w"> </span>gpiochip0
</pre></div>
</div>
</li>
<li><p>读取GPIO的值（例如从gpiochip0的GPIO 20）：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gpioget<span class="w"> </span>gpiochip0<span class="w"> </span><span class="m">20</span>
</pre></div>
</div>
</li>
<li><p>将gpiochip0上的GPIO 20的值设置为0并退出工具：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gpioset<span class="w"> </span>--mode<span class="o">=</span><span class="nb">exit</span><span class="w"> </span>gpiochip0<span class="w"> </span><span class="nv">20</span><span class="o">=</span><span class="m">0</span>
</pre></div>
</div>
</li>
<li><p>gpioset的帮助文本显示了可能的选项：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gpioset<span class="w"> </span>--help
<span class="go">Usage: gpioset [OPTIONS] &lt;chip name/number&gt; &lt;offset1&gt;=&lt;value1&gt; &lt;offset2&gt;=&lt;value2&gt; ...</span>
<span class="go">Set GPIO line values of a GPIO chip</span>

<span class="go">Options:</span>
<span class="go">  -h, --help:           display this message and exit</span>
<span class="go">  -v, --version:        display the version and exit</span>
<span class="go">  -l, --active-low:     set the line active state to low</span>
<span class="go">  -m, --mode=[exit|wait|time|signal] (defaults to &#39;exit&#39;):</span>
<span class="go">                tell the program what to do after setting values</span>
<span class="go">  -s, --sec=SEC:        specify the number of seconds to wait (only valid for --mode=time)</span>
<span class="go">  -u, --usec=USEC:      specify the number of microseconds to wait (only valid for --mode=time)</span>
<span class="go">  -b, --background:     after setting values: detach from the controlling terminal</span>

<span class="go">Modes:</span>
<span class="go">  exit:         set values and exit immediately</span>
<span class="go">  wait:         set values and wait for user to press ENTER</span>
<span class="go">  time:         set values and sleep for a specified amount of time</span>
<span class="go">  signal:       set values and wait for SIGINT or SIGTERM</span>

<span class="go">Note: the state of a GPIO line controlled over the character device reverts to default</span>
<span class="go">when the last process referencing the file descriptor representing the device file exits.</span>
<span class="go">This means that it&#39;s wrong to run gpioset, have it exit and expect the line to continue</span>
<span class="go">being driven high or low. It may happen if given pin is floating but it must be interpreted</span>
<span class="go">as undefined behavior.</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>某些GPIO用于特殊功能。在使用某个GPIO之前，请参考您板子的原理图或硬件手册，以确保该IO未被其他功能占用。</p>
</div>
<section id="gpios-via-sysfs">
<h3><span class="section-number">7.9.1. </span>通过sysfs访问GPIO<a class="headerlink" href="#gpios-via-sysfs" title="Link to this heading"></a></h3>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>通过sysfs访问GPIO已经过时了，我们建议使用libgpiod。</p>
</div>
<p>默认情况下不再支持通过sysfs访问GPIO。只有手动在内核配置中启用 <code class="docutils literal notranslate"><span class="pre">CONFIG_GPIO_SYSFS</span></code> 后才能支持。要在menuconfig中使 <code class="docutils literal notranslate"><span class="pre">CONFIG_GPIO_SYSFS</span></code> 可见，必须首先启用选项 <code class="docutils literal notranslate"><span class="pre">CONFIG_EXPERT</span></code> 。</p>
<p>您也可以将此选项添加到您在 Linux 内核源代码 <code class="docutils literal notranslate"><span class="pre">arch/arm64/configs/</span></code> 目录下使用的 defconfig 中。例如，我们基于 NXP 的BSP版本，这个defconfig可以是  <code class="docutils literal notranslate"><span class="pre">imx8_phytec_distro.config</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>..
CONFIG_EXPERT=y
CONFIG_GPIO_SYSFS=y
..
</pre></div>
</div>
<p>您也可以创建一个新的config片段。有关详细信息，请参阅我们的《Yocto参考手册&lt;<a class="reference external" href="https://www.phytec.de/cdocuments/?doc=UIHsG#YoctoReferenceManualHardknottL813e-A12-KernelandBootloaderConfiguration">yocto-ref-manual-kernel-and-bootloader-config</a>&gt;》。</p>
</section>
</section>
<section id="leds">
<h2><span class="section-number">7.10. </span>LED灯<a class="headerlink" href="#leds" title="Link to this heading"></a></h2>
<p>如果有任何LED灯连接到GPIO管脚，您可以通过特定的LED驱动程序接口访问它们，而不是使用通用的GPIO接口（请参见GPIO部分）。您将通过 <code class="docutils literal notranslate"><span class="pre">/sys/class/leds/</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">/sys/class/gpio/</span></code> 来访问它们。LED的最大亮度可以从 <code class="docutils literal notranslate"><span class="pre">max_brightness</span></code> 文件中读取。brightness文件将设置LED的亮度（取值范围从0到max_brightness）。大多数LED硬件上不支持调整亮度，所以在所有非零亮度下都会点亮。</p>
<p>下面是一个简单的例子。</p>
<p>要获取所有可用的LED，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ls<span class="w"> </span>/sys/class/leds
<span class="go">mmc1::@    mmc2::@    user-led1@ user-led2@ user-led3@</span>
</pre></div>
</div>
<p>这里的 LED 灯包括蓝色的 mmc、绿色的 心跳和红色的 emmc，它们都在 phyBOARD-Pollux 上。</p>
<ul>
<li><p>打开LED灯：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">255</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/leds/user-led1/brightness
</pre></div>
</div>
</li>
<li><p>关闭LED：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/leds/user-led1/brightness
</pre></div>
</div>
</li>
</ul>
<p>GPIO的设备树配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n216">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n216</a></p>
</section>
<section id="i2c-bus">
<h2><span class="section-number">7.11. </span>I²C总线<a class="headerlink" href="#i2c-bus" title="Link to this heading"></a></h2>
<p>该 i.MX 8M Plus 包含多个多主支持快速模式的 I²C模块。PHYTEC板提供了许多不同的I²C设备，这些设备连接到 i.MX 8M Plus 的I²C模块。 本节描述了我们 phyBOARD-Pollux 中集成的一些I²C设备的基本设备使用及其设备树（DT）表示。</p>
<p>i2c的设备树节点包含一些设置，例如时钟频率，用于设置总线频率，以及引脚控制设置，包括scl-gpios和sda-gpios，这些是用于总线恢复的备用引脚配置。</p>
<p>I²C1总线DT配置（例如 imx8mp-phycore-som.dtsi）： <a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n105">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n105</a></p>
<p>I²C2总线DT配置（例如 imx8mp-phyboard-pollux-rdk.dts）: <a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n201">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n201</a></p>
</section>
<section id="eeprom">
<h2><span class="section-number">7.12. </span>EEPROM<a class="headerlink" href="#eeprom" title="Link to this heading"></a></h2>
<p>在 phyCORE-i.MX 8M Plus 上有一个i2c EEPROM闪存。它有两个地址。主EEPROM空间（总线：I2C-0 地址：0x51）和ID页（总线：I2C-0 地址：0x59）可以通过Linux中的sysfs接口进行访问。主EEPROM和ID页的前256个字节用于板检测，不可被覆盖。覆盖保留的空间将导致启动问题。</p>
<section id="i2c-eeprom-on-som">
<h3><span class="section-number">7.12.1. </span>phyCORE-i.MX 8M Plus 上的I2C EEPROM<a class="headerlink" href="#i2c-eeprom-on-som" title="Link to this heading"></a></h3>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>EEPROM ID页面（总线：I2C-0 地址：0x59）和正常EEPROM区域的前256个字节（总线：I2C-0 地址：0x51）不可被擦除或修改。这将影响bootloader的行为。板子可能无法正确启动。</p>
</div>
<p>phyCORE-i.MX 8M Plus SoM上的I2C EEPROM连接到I2C-0总线的I2C地址0x51。可以直接对该设备进行读写操作：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hexdump<span class="w"> </span>-c<span class="w"> </span>/sys/class/i2c-dev/i2c-0/device/0-0051/eeprom
</pre></div>
</div>
<p>要读取并以十六进制打印 EEPROM 的前 1024 字节，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/sys/class/i2c-dev/i2c-0/device/0-0051/eeprom<span class="w"> </span><span class="nv">bs</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">1024</span><span class="w">  </span><span class="p">|</span><span class="w"> </span>od<span class="w"> </span>-x
</pre></div>
</div>
<p>要用零填充4KiB的EEPROM（总线：I2C-0 地址：0x51），并保留EEPROM数据，请使用：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/dev/zero<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/sys/class/i2c-dev/i2c-0/device/0-0051/eeprom<span class="w"> </span><span class="nv">seek</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">bs</span><span class="o">=</span><span class="m">256</span><span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">15</span>
</pre></div>
</div>
</section>
<section id="eeprom-som-detection">
<h3><span class="section-number">7.12.2. </span>EEPROM SoM 检测<a class="headerlink" href="#eeprom-som-detection" title="Link to this heading"></a></h3>
<p>在 phyCORE-i.MX 8M Plus 上配置的I2C EEPROM具有一个可通过I2C地址0x59在i2c0上寻址的独立ID页面，以及一个可通过I2C地址0x51在i2c0上寻址的正常区域。PHYTEC使用这个32字节的数据区域来存储关于SoM的信息，包括PCB版本和配置。</p>
<p>在启动的早期阶段读取EEPROM数据。它用于选择正确的DDR RAM配置。这使得可以使用相同的bootloader镜像来支持不同的RAM大小，并自动选择正确的DTS overlay。</p>
<p>如果EEPROM ID页面数据和正常区域的前256个字节被删除，bootloader程序将回退到 phyCORE-i.MX 8M Plus Kit RAM设置，即 2GiB RAM。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>EEPROM ID页面（总线：I2C-0 地址：0x59）和正常EEPROM区域的前256个字节（总线：I2C-0 地址：0x51）不可被擦除或修改。这将影响bootloader的行为。板子可能无法正确启动。</p>
</div>
<p>使用API修订版2数据格式烧写的核心板将在早期启动阶段打印出有关模块的信息。</p>
</section>
<section id="rescue-eeprom-data">
<h3><span class="section-number">7.12.3. </span>恢复EEPROM数据<a class="headerlink" href="#rescue-eeprom-data" title="Link to this heading"></a></h3>
<p>硬件数据已预先写入两个EEPROM数据空间。如果您不小心删除或覆盖了Normal区域，可以将ID区域的硬件检查数据复制到正常区域。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/sys/class/i2c-dev/i2c-0/device/0-0059/eeprom<span class="w"> </span><span class="nv">of</span><span class="o">=</span>/sys/class/i2c-dev/i2c-0/device/0-0051/eeprom<span class="w"> </span><span class="nv">bs</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您删除了两个EEPROM空间，请联系我们的支持团队！</p>
</div>
<p>DT representation, e.g. in phyCORE-i.MX 8M Plus file imx8mp-phycore-som.dtsi can be
found in our PHYTEC git:
<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n201">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n201</a></p>
</section>
</section>
<section id="rtc">
<h2><span class="section-number">7.13. </span>RTC<a class="headerlink" href="#rtc" title="Link to this heading"></a></h2>
<p>RTC可以通过 <code class="docutils literal notranslate"><span class="pre">/dev/rtc*</span></code> 访问。由于PHYTEC板通常有多个RTC，因此可能会有多个RTC设备文件。</p>
<ul>
<li><p>要找到RTC设备的名称，可以通过以下方式读取其sysfs条目：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/class/rtc/rtc*/name
</pre></div>
</div>
</li>
<li><p>例如，你将得到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rtc-rv3028 0-0052
snvs_rtc 30370000.snvs:snvs-rtc-lp
</pre></div>
</div>
</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>这将列出所有实时时钟（RTC），包括非I²C接口的RTC。如果存在设备树/aliases条目，Linux会根据这些条目分配RTC设备ID。</p>
</div>
<p>日期和时间可以通过 <code class="docutils literal notranslate"><span class="pre">hwclock</span></code> 工具和date命令进行操作。要显示目标上设置的当前日期和时间：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>date
<span class="go">Thu Jan  1 00:01:26 UTC 1970</span>
</pre></div>
</div>
<p>使用日期命令更改日期和时间。日期命令以以下语法设置时间：&quot;YYYY-MM-DD hh:mm:ss (+|-)hh:mm&quot;：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>date<span class="w"> </span>-s<span class="w"> </span><span class="s2">&quot;2022-03-02 11:15:00 +0100&quot;</span>
<span class="go">Wed Mar  2 10:15:00 UTC 2022</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>您的时区（在此示例中为 +0100）可能会有所不同。</p>
</div>
<p>使用date命令并不会改变实时时钟（RTC）的时间和日期，因此如果我们重启开发板，这些更改将会被丢弃。要写入RTC，我们需要使用 <code class="docutils literal notranslate"><span class="pre">hwclock</span></code> 命令。使用 <code class="docutils literal notranslate"><span class="pre">hwclock</span></code> 工具将当前的日期和时间（通过date命令设置）写入RTC，然后重启开发板以检查更改是否已应用到RTC上：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hwclock<span class="w"> </span>-w
<span class="gp">target:~$ </span>reboot
<span class="go">    .</span>
<span class="go">    .</span>
<span class="go">    .</span>
<span class="gp">target:~$ </span>date
<span class="go">Wed Mar  2 10:34:06 UTC 2022</span>
</pre></div>
</div>
<p>要从实时时钟（RTC）设置系统时间和日期，请使用：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>date
<span class="go">Thu Jan  1 01:00:02 UTC 1970</span>
<span class="gp">target:~$ </span>hwclock<span class="w"> </span>-s
<span class="gp">target:~$ </span>date
<span class="go">Wed Mar  2 10:45:01 UTC 2022</span>
</pre></div>
</div>
<section id="rtc-wakealarm">
<h3><span class="section-number">7.13.1. </span>RTC唤醒alarm<a class="headerlink" href="#rtc-wakealarm" title="Link to this heading"></a></h3>
<p>可以从实时时钟（RTC）发出中断以唤醒系统。该格式使用Unix纪元时间，即自1970年1月1日UTC午夜以来的秒数。要在从挂起到RAM状态后的4分钟唤醒系统，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;+240&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/rtc/rtc0/wakealarm
<span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>mem<span class="w"> </span>&gt;<span class="w"> </span>/sys/power/state
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>内部唤醒alarm时间将被向上舍入到下一个分钟，因为alarm功能不支持秒。</p>
</div>
<p>I²C RTC的设备树表示：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n207">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n207</a></p>
</section>
</section>
<section id="usb-host-controller">
<h2><span class="section-number">7.14. </span>USB主控制器<a class="headerlink" href="#usb-host-controller" title="Link to this heading"></a></h2>
<p>i.MX 8M Plus SoC的USB控制器为众多消费类便携设备提供了一种低成本的连接解决方案，实现USB设备之间的数据传输，传输速度可达4 Gbit/s（超高速'SS'）。USB子系统具有两个独立的USB控制器。这两个控制器都能够作为USBDevice或USB Host使用。每个核心都连接到一个USB 3.0物理层（PHY）。</p>
<p>BSP支持大容量存储设备（优盘）和键盘。其他与USB相关的设备驱动程序必须根据需要在内核配置中启用。由于udev，所有连接的存储设备都会获得唯一的ID，并可以在 <code class="docutils literal notranslate"><span class="pre">/dev/disk/by-id</span></code> 中找到。这些ID可以在 <code class="docutils literal notranslate"><span class="pre">/etc/fstab</span></code> 中用于以不同的方式挂载不同的USB存储设备。</p>
<p>USB Host的DT配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n341">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n341</a></p>
</section>
<section id="can-fd">
<h2><span class="section-number">7.15. </span>CAN FD<a class="headerlink" href="#can-fd" title="Link to this heading"></a></h2>
<p>phyBOARD-Pollux 支持两个 flexCAN 接口，支持 CAN FD。这些接口支持 Linux 标准 CAN 框架，该框架建立在 Linux 网络层之上。使用这个框架，CAN 接口表现得像普通的 Linux 网络设备，同时具备一些 CAN 特有的附加功能。更多信息可以在 Linux 内核文档中找到：<a class="reference external" href="https://www.kernel.org/doc/html/latest/networking/can.html">https://www.kernel.org/doc/html/latest/networking/can.html</a></p>
<ul>
<li><p>使用：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>link
</pre></div>
</div>
<p>查看接口的状态。两个CAN接口显示为can0和can1。</p>
</li>
<li><p>要获取有关can0的信息，例如比特率和错误计数器，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>-d<span class="w"> </span>-s<span class="w"> </span>link<span class="w"> </span>show<span class="w"> </span>can0
</pre></div>
</div>
<p>can0的信息将如下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2: can0: &lt;NOARP,UP,LOWER_UP,ECHO&gt; mtu 16 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 10
    link/can  promiscuity 0 minmtu 0 maxmtu 0
    can state ERROR-ACTIVE (berr-counter tx 0 rx 0) restart-ms 0
          bitrate 500000 sample-point 0.875
          tq 50 prop-seg 17 phase-seg1 17 phase-seg2 5 sjw 1
          mcp25xxfd: tseg1 2..256 tseg2 1..128 sjw 1..128 brp 1..256 brp-inc 1
          mcp25xxfd: dtseg1 1..32 dtseg2 1..16 dsjw 1..16 dbrp 1..256 dbrp-inc 1
          clock 20000000
          re-started bus-errors arbit-lost error-warn error-pass bus-off
          0          0          0          0          0          0         numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535
    RX: bytes  packets  errors  dropped overrun mcast
    0          0        0       0       0       0
    TX: bytes  packets  errors  dropped carrier collsns
    0          0        0       0       0       0
</pre></div>
</div>
</li>
</ul>
<p>输出包含一组标准参数，这些参数也适用于以太网接口，因此并非所有参数对于CAN都是相关的（例如MAC地址）。以下输出参数包含有用的信息：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>can0</p></th>
<th class="head"><p>接口名称</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NOARP</p></td>
<td><p>CAN无法使用ARP协议</p></td>
</tr>
<tr class="row-odd"><td><p>MTU</p></td>
<td><p>最大传输单元</p></td>
</tr>
<tr class="row-even"><td><p>RX packets</p></td>
<td><p>接收的数据包数量</p></td>
</tr>
<tr class="row-odd"><td><p>TX packets</p></td>
<td><p>发送的数据包数量</p></td>
</tr>
<tr class="row-even"><td><p>RX bytes</p></td>
<td><p>接收字节数</p></td>
</tr>
<tr class="row-odd"><td><p>TX bytes</p></td>
<td><p>发送字节数</p></td>
</tr>
<tr class="row-even"><td><p>errors...</p></td>
<td><p>总线错误统计信息</p></td>
</tr>
</tbody>
</table>
<p>CAN配置是在systemd配置文件 <code class="docutils literal notranslate"><span class="pre">/lib/systemd/network/can0.network</span></code> 中完成的。为了持久化更改（例如，默认比特率），请在BSP中更改根文件系统下的 <code class="docutils literal notranslate"><span class="pre">./meta-ampliphy/recipes-core/systemd/systemd-conf/can0.network</span></code> 中的配置，并重新编译根文件系统。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[Match]
Name=can0

[Can]
BitRate=500000
</pre></div>
</div>
<p>比特率也可以手动更改，例如，设置为灵活比特率（flexible bitrate）：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>can0<span class="w"> </span>down
<span class="gp">target:~$ </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>can0<span class="w"> </span>txqueuelen<span class="w"> </span><span class="m">10</span><span class="w"> </span>up<span class="w"> </span><span class="nb">type</span><span class="w"> </span>can<span class="w"> </span>bitrate<span class="w"> </span><span class="m">500000</span><span class="w"> </span>sample-point<span class="w"> </span><span class="m">0</span>.75<span class="w"> </span>dbitrate<span class="w"> </span><span class="m">4000000</span><span class="w"> </span>dsample-point<span class="w"> </span><span class="m">0</span>.8<span class="w"> </span>fd<span class="w"> </span>on
</pre></div>
</div>
<p>您可以使用cansend发送消息，或使用candump接收消息：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cansend<span class="w"> </span>can0<span class="w"> </span><span class="m">123</span><span class="c1">#45.67</span>
<span class="gp">target:~$ </span>candump<span class="w"> </span>can0
</pre></div>
</div>
<p>要生成用于测试目的的随机CAN流量，请使用cangen：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cangen
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cansend</span> <span class="pre">--help</span></code> 和 <code class="docutils literal notranslate"><span class="pre">candump</span> <span class="pre">--help</span></code> 提供了关于选项和用法的帮助信息。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>mcp2518fd SPI到CAN FD只支持从125kB/s开始的波特率。可以选择更慢的速率，但可能无法正常工作。</p>
</div>
<p>imx8mp-phyboard-pollux.dtsi的CAN设备树配置： <a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n165">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n165</a></p>
</section>
<section id="pcie">
<h2><span class="section-number">7.16. </span>PCIe<a class="headerlink" href="#pcie" title="Link to this heading"></a></h2>
<p>The phyCORE-i.MX 8M Plus has one Mini-PCIe slot. In general, PCIe autodetects new
devices on the bus. After connecting the device and booting up the system, you
can use the command lspci to see all PCIe devices recognized.</p>
<ul>
<li><p>输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>lspci<span class="w"> </span>-v
</pre></div>
</div>
</li>
<li><p>你将收到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>00:00.0 PCI bridge: Synopsys, Inc. Device abcd (rev 01) (prog-if 00 [Normal decode])
        Flags: bus master, fast devsel, latency 0, IRQ 218
        Memory at 18000000 (64-bit, non-prefetchable) [size=1M]
        Bus: primary=00, secondary=01, subordinate=ff, sec-latency=0
        I/O behind bridge: None
        Memory behind bridge: 18100000-181fffff [size=1M]
        Prefetchable memory behind bridge: None
        [virtual] Expansion ROM at 18200000 [disabled] [size=64K]
        Capabilities: [40] Power Management version 3
        Capabilities: [50] MSI: Enable+ Count=1/1 Maskable+ 64bit+
        Capabilities: [70] Express Root Port (Slot-), MSI 00
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [148] L1 PM Substates
        Kernel driver in use: dwc3-haps

01:00.0 Network controller: Intel Corporation WiFi Link 5100
        Subsystem: Intel Corporation WiFi Link 5100 AGN
        Flags: fast devsel
        Memory at 18100000 (64-bit, non-prefetchable) [disabled] [size=8K]
        Capabilities: [c8] Power Management version 3
        Capabilities: [d0] MSI: Enable- Count=1/1 Maskable- 64bit+
        Capabilities: [e0] Express Endpoint, MSI 00
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [140] Device Serial Number 00-24-d6-ff-ff-84-0d-1e
        Kernel modules: iwlwifi
</pre></div>
</div>
</li>
</ul>
<p>在这个例子中，PCIe设备是 <em>英特尔 WiFi Link 5100</em> 。</p>
<p>对于PCIe设备，您必须在内核配置中启用正确的驱动程序。例如，这款WLAN卡是由英特尔制造的。必须启用的驱动程序选项名为 <code class="docutils literal notranslate"><span class="pre">CONFIG_IWLWIFI</span></code> ，可以在内核配置中的 <em>Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate</em> 下找到。</p>
<ul class="simple">
<li><p>使能驱动的方法。请参阅我们的 <a class="reference external" href="https://www.phytec.de/cdocuments/?doc=UIHsG#YoctoReferenceManualHardknottL813e-A12-KernelandBootloaderConfiguration">Yocto Reference Manual</a>。</p>
<ul>
<li><p>linux-imx的表示为：<strong>virtual/kernel</strong></p></li>
</ul>
</li>
</ul>
<p>对于某些设备，如WLAN卡，需要额外的二进制固件文件。这些固件文件必须放置在 <code class="docutils literal notranslate"><span class="pre">/lib/firmware/</span></code> 目录中，才能使用该设备。</p>
<ul>
<li><p>输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>scp<span class="w"> </span>-r<span class="w"> </span>&lt;firmware&gt;<span class="w"> </span>root@192.168.3.11:/lib/firmware
</pre></div>
</div>
</li>
<li><p>例如，如果您尝试启动网络接口：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ip<span class="w"> </span>link<span class="w"> </span><span class="nb">set</span><span class="w"> </span>up<span class="w"> </span>wlp1s0
</pre></div>
</div>
</li>
<li><p>您将在串口控制台上获得以下输出：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[   58.682104] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled</span>
<span class="go">[   58.690822] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled</span>
<span class="go">[   58.696577] iwlwifi 0000:01:00.0: Radio type=0x1-0x2-0x0</span>
<span class="go">[   58.831022] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled</span>
<span class="go">[   58.839679] iwlwifi 0000:01:00.0: L1 Disabled - LTR Disabled</span>
<span class="go">[   58.845435] iwlwifi 0000:01:00.0: Radio type=0x1-0x2-0x0</span>
<span class="go">[   58.902797] IPv6: ADDRCONF(NETDEV_UP): wlp1s0: link is not ready</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>某些PCIe设备，例如以太网卡，即使没有从 <code class="docutils literal notranslate"><span class="pre">/lib/firmware/</span></code> 加载固件文件，也可能正常工作，而你收到了如上输出第一行所示的错误消息。这是因为一些制造商在板卡本身提供了固件作为后备。在这种情况下，设备的行为和输出在很大程度上依赖于制造商的固件。</p>
</div>
<p>imx8mm-phyboard-polis.dtsi的PCIe设备树配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n277">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n277</a></p>
</section>
<section id="audio">
<h2><span class="section-number">7.17. </span>音频<a class="headerlink" href="#audio" title="Link to this heading"></a></h2>
<p>支持的播放设备包括HDMI和PEB-AV-10连接器上的TI TLV320AIC3007音频编解码器（CODEC）IC。在AV连接器上，有一个符合OMTP标准的3.5mm耳机插孔和一个8针排针。8针排针包含单声道扬声器、耳机和line-in信号。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>使用PEB-AV-10连接器进行显示输出时，不支持通过HDMI作为音频输出。音频输出设备必须与视频输出设备匹配。</p>
</div>
<p>要检查您的声卡驱动程序是否正确加载以及设备名称，请输入以下命令以查看播放设备：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>aplay<span class="w"> </span>-L
</pre></div>
</div>
<p>或输入录音设备：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>arecord<span class="w"> </span>-L
</pre></div>
</div>
<section id="alsamixer">
<h3><span class="section-number">7.17.1. </span>Alsamixer<a class="headerlink" href="#alsamixer" title="Link to this heading"></a></h3>
<p>要检查声卡的功能，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>alsamixer
</pre></div>
</div>
<p>您应该会看到很多选项，因为音频IC具有许多可以配置的功能选项。通过SSH打开alsamixer可能比通过串口控制台更好，因为控制台的图形效果更佳。您可以为所有混合点使用单声道或立体声增益控制。“MM”表示该功能被静音（左右输出均为静音），可以通过按 <strong>m</strong> 键切换。您还可以通过按'<strong>&lt;</strong>'键切换左声道和'<strong>&gt;</strong>'键切换右声道。使用 <strong>tab</strong> 键，您可以在播放和录音的控制之间切换。</p>
</section>
<section id="alsa-configuration">
<h3><span class="section-number">7.17.2. </span>ALSA配置<a class="headerlink" href="#alsa-configuration" title="Link to this heading"></a></h3>
<p>我们的BSP附带一个ALSA配置文件 <code class="docutils literal notranslate"><span class="pre">/etc/asound.conf</span></code> 。</p>
<p>ALSA配置文件可以根据需要进行编辑或删除，它并不是ALSA正常工作所必需的。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>vi<span class="w"> </span>/etc/asound.conf
</pre></div>
</div>
<p>要将PEB-AV-10设置为输出，请将 <em>playback.pcm</em> 从 &quot;dummy&quot; 设置为 &quot;pebav10&quot;:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[...]

pcm.asymed {
        type asym
        playback.pcm &quot;pebav10&quot;
        capture.pcm &quot;dsnoop&quot;
}

[...]
</pre></div>
</div>
<p>如果听不到声音，请将播放设备更改为软件音量控制播放设备，将 <em>playback.pcm</em> 设置为相应的软音量播放设备，选择 &quot;softvol_hdmi&quot; 或 &quot;softvol_pebav10&quot;。使用 alsamixer 控件来调整音量水平。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[...]

pcm.asymed {
        type asym
        playback.pcm &quot;softvol_hdmi&quot;
        capture.pcm &quot;dsnoop&quot;
}

[...]
</pre></div>
</div>
</section>
<section id="pulseaudio-configuration">
<h3><span class="section-number">7.17.3. </span>PulseAudio 配置<a class="headerlink" href="#pulseaudio-configuration" title="Link to this heading"></a></h3>
<p>对于使用Pulseaudio的应用程序，请检查可用的输出设备：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>pactl<span class="w"> </span>list<span class="w"> </span>short<span class="w"> </span>sinks
<span class="go">0   alsa_output.platform-snd_dummy.0.stereo-fallback    module-alsa-card.c  s16le 2ch 44100Hz   SUSPENDED</span>
<span class="go">1   alsa_output.platform-sound-peb-av-10.stereo-fallback    module-alsa-card.c  s16le 2ch 44100Hz   SUSPENDED</span>
</pre></div>
</div>
<p>要选择PEB-AV-10，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>pactl<span class="w"> </span>set-default-sink<span class="w"> </span><span class="m">1</span>
</pre></div>
</div>
</section>
<section id="playback">
<h3><span class="section-number">7.17.4. </span>播放<a class="headerlink" href="#playback" title="Link to this heading"></a></h3>
<p>运行speaker-test以检查播放功能：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>speaker-test<span class="w"> </span>-c<span class="w"> </span><span class="m">2</span><span class="w"> </span>-t<span class="w"> </span>wav
</pre></div>
</div>
<p>要播放简单的音频流，您可以使用aplay。例如，要播放ALSA测试音频：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>aplay<span class="w"> </span>/usr/share/sounds/alsa/*
</pre></div>
</div>
<p>要播放其他格式，例如mp3，您可以使用Gstreamer：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gst-launch-1.0<span class="w"> </span>playbin<span class="w"> </span><span class="nv">uri</span><span class="o">=</span>file:/path/to/file.mp3
</pre></div>
</div>
</section>
<section id="capture">
<h3><span class="section-number">7.17.5. </span>录音<a class="headerlink" href="#capture" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">arecord</span></code> 是一个命令行工具，用于录制音频流，默认输入源为线路输入。要选择不同的音频源，可以使用 <code class="docutils literal notranslate"><span class="pre">alsamixer</span></code>。例如，打开 <em>右侧 PGA 混音器 Mic3R</em> 和 <em>左侧 PGA 混音器 Mic3R</em>，以便通过 3.5mm 插孔录制来自 TLV320 编解码器的麦克风输入音频。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>amixer<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;sndpebav10&quot;</span><span class="w"> </span>sset<span class="w"> </span><span class="s1">&#39;Left PGA Mixer Mic3R&#39;</span><span class="w"> </span>on
<span class="gp">target:~$ </span>amixer<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;sndpebav10&quot;</span><span class="w"> </span>sset<span class="w"> </span><span class="s1">&#39;Right PGA Mixer Mic3R&#39;</span><span class="w"> </span>on
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>arecord<span class="w"> </span>-t<span class="w"> </span>wav<span class="w"> </span>-c<span class="w"> </span><span class="m">2</span><span class="w"> </span>-r<span class="w"> </span><span class="m">44100</span><span class="w"> </span>-f<span class="w"> </span>S16_LE<span class="w"> </span>test.wav
</pre></div>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>由于播放和录音共享硬件接口，因此无法在同时进行播放和录音操作时使用不同的采样率和格式。</p>
</div>
<p>音频的设备树配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n57">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n57</a></p>
</section>
</section>
<section id="video">
<h2><span class="section-number">7.18. </span>视频<a class="headerlink" href="#video" title="Link to this heading"></a></h2>
<section id="videos-with-gstreamer">
<h3><span class="section-number">7.18.1. </span>视频与Gstreamer<a class="headerlink" href="#videos-with-gstreamer" title="Link to this heading"></a></h3>
<p>这个视频在BSP中默认安装：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gst-launch-1.0<span class="w"> </span>playbin<span class="w"> </span><span class="nv">uri</span><span class="o">=</span>file:///usr/share/phytec-qtdemo/videos/caminandes.webm
</pre></div>
</div>
<ul class="simple">
<li><p>或者：</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gst-launch-1.0<span class="w"> </span>-v<span class="w"> </span>filesrc<span class="w"> </span><span class="nv">location</span><span class="o">=</span>&lt;video.mp4&gt;<span class="w"> </span><span class="se">\</span>
<span class="se">\!</span><span class="w"> </span>qtdemux<span class="w">  </span><span class="se">\!</span><span class="w"> </span>h264parse<span class="w"> </span><span class="se">\!</span><span class="w"> </span>queue<span class="w"> </span><span class="se">\!</span><span class="w"> </span>vpudec<span class="w"> </span><span class="se">\!</span><span class="w"> </span>waylandsink<span class="w"> </span><span class="nv">async</span><span class="o">=</span><span class="nb">false</span><span class="w"> </span>enable-last-sample<span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="se">\</span>
<span class="nv">qos</span><span class="o">=</span><span class="nb">false</span><span class="w"> </span><span class="nv">sync</span><span class="o">=</span><span class="nb">false</span>
</pre></div>
</div>
<ul class="simple">
<li><p>或者：</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>gplay-1.0<span class="w"> </span>/usr/share/phytec-qtdemo/videos/caminandes.webm
</pre></div>
</div>
</section>
<section id="kmssink-plugin-id-evaluation">
<h3><span class="section-number">7.18.2. </span>kmssink 插件 ID 确认<a class="headerlink" href="#kmssink-plugin-id-evaluation" title="Link to this heading"></a></h3>
<p>kmssink插件需要一个连接器ID。要获取连接器ID，您可以使用工具modetest。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>modetest<span class="w"> </span>-c<span class="w"> </span>imx-drm
</pre></div>
</div>
<p>输出如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Connectors:
id  encoder status      name        size (mm)   modes   encoders
35  34  connected   LVDS-1          216x135     1   34
  modes:
    index name refresh (Hz) hdisp hss hse htot vdisp vss vse vtot
  #0 1280x800 59.07 1280 1380 1399 1440 800 804 808 823 70000 flags: phsync, pvsync; type: preferred, driver
  props:
    1 EDID:
        flags: immutable blob
        blobs:

        value:
    2 DPMS:
        flags: enum
        enums: On=0 Standby=1 Suspend=2 Off=3
        value: 0
    5 link-status:
        flags: enum
        enums: Good=0 Bad=1
        value: 0
    6 non-desktop:
        flags: immutable range
        values: 0 1
        value: 0
    4 TILE:
        flags: immutable blob
        blobs:

        value:
</pre></div>
</div>
</section>
</section>
<section id="display">
<h2><span class="section-number">7.19. </span>显示<a class="headerlink" href="#display" title="Link to this heading"></a></h2>
<p>该 phyBOARD-Pollux 支持多达4种不同的显示输出。可以同时使用三种。下表显示了不同接口所需的扩展板和设备树overlay。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>接口</p></th>
<th class="head"><p>扩展板</p></th>
<th class="head"><p>设备树overlay</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>HDMI</p></td>
<td><p>phyBOARD-Pollux</p></td>
<td><p>不需要overlay（默认启用）</p></td>
</tr>
<tr class="row-odd"><td><p>LVDS0</p></td>
<td><p>PEB-AV-10</p></td>
<td><p>imx8mp-phyboard-pollux-peb-av-010.dtbo（默认加载）</p></td>
</tr>
<tr class="row-even"><td><p>LVDS1</p></td>
<td><p>phyBOARD-Pollux</p></td>
<td><p>如果使用PEB-AV-10 overlay，则禁用</p></td>
</tr>
<tr class="row-odd"><td><p>MIPI</p></td>
<td><p>PEB-AV-12 (MIPI到LVDS)</p></td>
<td><p>imx8mp-phyboard-pollux-peb-av-012.dtbo</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<ul class="simple">
<li><p>如果启用了LVDS1（板载），HDMI将无法工作。</p></li>
<li><p>在更改Weston输出时，请确保音频输出也相匹配。</p></li>
<li><p>LVDS0 (使用PEB-AV-10扩展) 和 LVDS1 (板载) 不能同时使用。</p></li>
</ul>
</div>
<p>HDMI在设备树中始终启用。其他接口可以通过设备树overlay进行启用。</p>
<p>默认启用的接口是HDMI和LVDS0（PEB-AV-010）。我们的PEB-AV-10和PEB-AV-12扩展板支持10英寸edt,etml1010g0dka显示屏。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当前的显示驱动程序将连接到LVDS的LCD的像素时钟限制为74.25MHz（或其分频）。如果这满足不了您的需求，请联系支持团队以获得进一步的帮助。</p>
</div>
<section id="weston-configuration">
<h3><span class="section-number">7.19.1. </span>Weston 配置<a class="headerlink" href="#weston-configuration" title="Link to this heading"></a></h3>
<p>为了让Weston正确的显示，需要进行正确的配置。这将在/etc/xdg/weston/weston.ini中完成。</p>
<section id="single-display">
<h4><span class="section-number">7.19.1.1. </span>单一显示器<a class="headerlink" href="#single-display" title="Link to this heading"></a></h4>
<p>在我们的BSP中，默认的Weston输出设置为HDMI.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[output]
name=HDMI-A-1
mode=current
</pre></div>
</div>
</section>
</section>
<section id="qt-demo">
<h3><span class="section-number">7.19.2. </span>Qt Demo<a class="headerlink" href="#qt-demo" title="Link to this heading"></a></h3>
<p>使用phytec-qt5demo-image时，Weston会在启动时启动。可以通过以下命令停止phytec-qt5demo：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>stop<span class="w"> </span>phytec-qtdemo
</pre></div>
</div>
<ul>
<li><p>要重新开始Demo，请运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>start<span class="w"> </span>phytec-qtdemo
</pre></div>
</div>
</li>
<li><p>要禁用Demo的自动启动，请运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>disable<span class="w"> </span>phytec-qtdemo
</pre></div>
</div>
</li>
<li><p>要启用Demo的自动启动，请运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>phytec-qtdemo
</pre></div>
</div>
</li>
<li><p>Weston可以通过以下方式停止：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>stop<span class="w"> </span>weston
</pre></div>
</div>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在关闭Weston之前，必须先关闭Qt Demo。</p>
</div>
</section>
<section id="backlight-control">
<h3><span class="section-number">7.19.3. </span>背光控制<a class="headerlink" href="#backlight-control" title="Link to this heading"></a></h3>
<p>如果LCD连接到PHYTEC开发板，可以通过Linux内核的sysfs接口控制其背光。系统中所有可用的背光设备可以在文件夹/sys/class/backlight中找到。读取相应的文件并向其写入数据可以控制背光。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>一些具有多显示的开发板在 /sys/class/backlight 有多个背光控制。比如：backlight0和backlight1</p>
</div>
<ul>
<li><p>例如，要获取最大亮度级别（max_brightness），请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/class/backlight/backlight/max_brightness
</pre></div>
</div>
<p>有效的亮度值范围是 0 到 &lt;max_brightness&gt;。</p>
</li>
<li><p>要获取当前亮度级别，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/class/backlight/backlight/brightness
</pre></div>
</div>
</li>
<li><p>写入文件brightness以更改亮度：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/backlight/backlight/brightness
</pre></div>
</div>
<p>例如，关闭背光。</p>
<p>有关所有文件的文档，请参见 <a class="reference external" href="https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-class-backlight">https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-class-backlight</a>。</p>
</li>
</ul>
<p>LVDS-1和HDMI的设备树： <a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n255">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n255</a> <a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n180">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n180</a></p>
<p>PEB-AV-10上LVDS-0的设备树配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n132">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n132</a></p>
</section>
</section>
<section id="power-management">
<h2><span class="section-number">7.20. </span>电源管理<a class="headerlink" href="#power-management" title="Link to this heading"></a></h2>
<section id="cpu-core-frequency-scaling">
<h3><span class="section-number">7.20.1. </span>CPU核心频率调节<a class="headerlink" href="#cpu-core-frequency-scaling" title="Link to this heading"></a></h3>
<p>i.MX 8M Plus SoC中的CPU能够调整时钟频率和电压。这用于在不需要CPU的全部性能时节省电力。调整频率和电压被称为“动态电压和频率调整”（DVFS）。i.MX 8M Plus BSP支持DVFS功能。Linux内核提供了一个DVFS框架，允许每个CPU核心设置最小或最大频率和一个管理其运行的governor。根据使用的 i.MX 8 型号，支持几种不同的频率。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>尽管DVFS框架为每个CPU核心提供了频率设置，但一个CPU核心的频率更改会影响其他CPU核心。因此，所有CPU核心始终共享相同的DVFS设置。每个核心的单独DVFS设置是不可能的。</p>
</div>
<ul>
<li><p>要获取完整列表，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
</pre></div>
</div>
<p>例如 i.MX 8MPlus CPU，最高可达约 1.6 GHz，则结果将是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1200000 1600000
</pre></div>
</div>
</li>
<li><p>要查询当前的频率输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq
</pre></div>
</div>
</li>
</ul>
<p>governor 会根据它们的目标自动选择这些频率中的一个。</p>
<ul>
<li><p>列出所有可用的 governor，使用以下命令：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
</pre></div>
</div>
<p>结果是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>conservative ondemand userspace powersave performance schedutil
</pre></div>
</div>
</li>
<li><p><strong>conservative</strong> governor 与 ondemand governor 非常相似。只是它的行为有所不同，它会更保守地增减CPU速度，而不是在CPU有任何负载的瞬间就跳到最大速度。</p></li>
<li><p><strong>ondemand</strong> （默认）根据当前系统负载在可能的CPU核心频率之间切换。当系统负载超过特定值时，它会立即提高CPU核心频率。</p></li>
<li><p><strong>powersave</strong> 始终选择最低的CPU核心频率。</p></li>
<li><p><strong>performance</strong> 始终选择最高的CPU核心频率。</p></li>
<li><p><strong>userspace</strong> 允许以root身份运行的用户或用户空间程序设置特定频率（例如，设置为1600000）。输入：</p></li>
<li><p>要查询当前的 governor，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</pre></div>
</div>
<p>您通常会得到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ondemand
</pre></div>
</div>
</li>
<li><p>切换到另一个governor（例如，userspace）可以通过以下方式完成：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>userspace<span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</pre></div>
</div>
</li>
<li><p>现在你可以设置频率：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">1600000</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed
</pre></div>
</div>
</li>
</ul>
<p>有关governor的更详细信息，请参阅Linux内核代码库中的Linux内核文档，路径为 <code class="docutils literal notranslate"><span class="pre">Documentation/admin-guide/pm/cpufreq.rst</span></code> 。</p>
</section>
<section id="cpu-core-management">
<h3><span class="section-number">7.20.2. </span>CPU核心管理<a class="headerlink" href="#cpu-core-management" title="Link to this heading"></a></h3>
<p>该 i.MX 8M Plus SoC 芯片上可以有多个处理器核心。例如，该 i.MX 8M Plus 具有 4 个 ARM 核心，可以在运行时单独开启和关闭。</p>
<ul>
<li><p>要查看系统中所有可用的核心，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>ls<span class="w"> </span>/sys/devices/system/cpu<span class="w">  </span>-1
</pre></div>
</div>
</li>
<li><p>这将显示，例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cpu0    cpu1   cpu2   cpu3   cpufreq
[...]
</pre></div>
</div>
<p>这里系统有四个处理器核心。默认情况下，系统中所有可用的核心都被启用，以获得最佳性能。</p>
</li>
<li><p>要关闭某个核，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu3/online
</pre></div>
</div>
<p>作为确认，您将看到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[  110.505012] psci: CPU3 killed
</pre></div>
</div>
<p>现在核心已关闭电源，并且该核心上不再安排任何进程。</p>
</li>
<li><p>您可以使用 top 命令查看核心和进程的图形概览：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>htop
</pre></div>
</div>
</li>
<li><p>要重新启用核心，请执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/system/cpu/cpu3/online
</pre></div>
</div>
</li>
</ul>
</section>
<section id="suspend-to-ram">
<h3><span class="section-number">7.20.3. </span>挂起到RAM<a class="headerlink" href="#suspend-to-ram" title="Link to this heading"></a></h3>
<p>phyCORE-i.MX 8M Plus 支持基本的挂起和恢复。可以使用不同的唤醒源。挂起/恢复可以通过以下方式实现：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>mem<span class="w"> </span>&gt;<span class="w"> </span>/sys/power/state
<span class="gp">#</span>resume<span class="w"> </span>with<span class="w"> </span>pressing<span class="w"> </span>on/off<span class="w"> </span>button
</pre></div>
</div>
<p>要通过串行控制台唤醒，请运行</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>enabled<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/tty/ttymxc0/power/wakeup
<span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>mem<span class="w"> </span>&gt;<span class="w"> </span>/sys/power/state
</pre></div>
</div>
</section>
</section>
<section id="thermal-management">
<h2><span class="section-number">7.21. </span>热管理<a class="headerlink" href="#thermal-management" title="Link to this heading"></a></h2>
<section id="u-boot">
<h3><span class="section-number">7.21.1. </span>U-Boot<a class="headerlink" href="#u-boot" title="Link to this heading"></a></h3>
<p>之前U-Boot中的温度控制不够理想。现在，U-Boot增加了温度关机功能，以防止在启动过程中板子过热。关机发生的温度与内核中的温度一致。</p>
<p>当前温度的各个温度范围在启动日志中显示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU:   Industrial temperature grade (-40C to 105C) at 33C
</pre></div>
</div>
</section>
<section id="kernel">
<h3><span class="section-number">7.21.2. </span>内核<a class="headerlink" href="#kernel" title="Link to this heading"></a></h3>
<p>Linux内核集成了热管理功能，能够监测芯片（SoC）温度，降低CPU频率，控制风扇，通知其他驱动程序减少功耗，并在最坏的情况下关闭系统（<a class="reference external" href="https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt">https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt</a>）。</p>
<p>本节描述了如何在 i.MX 8M Plus SoC 平台上使用热管理内核 API。 i.MX 8 具有用于 SoC 的内部温度传感器。</p>
<ul>
<li><p>当前温度可以以毫摄氏度为单位读取：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>cat<span class="w"> </span>/sys/class/thermal/thermal_zone0/temp
</pre></div>
</div>
</li>
<li><p>例如，你将得到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>49000
</pre></div>
</div>
</li>
</ul>
<p>imx_thermal内核驱动注册了两个触发点。这些触发点根据CPU型号的不同而有所不同。主要区分工业版和商业版。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>商业</p></th>
<th class="head"><p>工业</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>被动（警告）</p></td>
<td><p>85°C</p></td>
<td><p>95°C</p></td>
</tr>
<tr class="row-odd"><td><p>严重（关机）</p></td>
<td><p>90°C</p></td>
<td><p>100°C</p></td>
</tr>
</tbody>
</table>
<p>（请查看内核 sysfs 文件夹 <code class="docutils literal notranslate"><span class="pre">/sys/class/thermal/thermal_zone0/</span></code>）</p>
<p>内核热管理使用这些触发点来触发事件并实施冷却措施。内核中可用的热政策（也称为thermal governor）包括：Step Wise、Fair Share、Bang Bang和Userspace。BSP中使用的默认策略是Step Wise。如果sysfs文件temp中的SoC温度值高于 <em>trip_point_0</em> ，则CPU频率将设置为最低CPU频率。当SoC温度降到 <em>trip_point_0</em> 以下时，限制将被解除。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于我们安装了不同温度等级的CPU，因此热触发点的实际值可能会有所不同。</p>
</div>
</section>
<section id="gpio-fan">
<h3><span class="section-number">7.21.3. </span>GPIO风扇<a class="headerlink" href="#gpio-fan" title="Link to this heading"></a></h3>
<p>一个GPIO控制的风扇可以连接到 phyBOARD-Pollux-i.MX 8M Plus。该SoC包含一个温度传感器，该传感器被用于热频率调节。风扇无法通过内核进行控制。我们使用lmsensors和hwmon来实现这一点。lmsensors定期读取温度，并在可配置的阈值下启用或禁用风扇。对于  phyBOARD-Pollux-i.MX 8M Plus，这个阈值是60°C。</p>
<p>设置可以在配置文件中进行配置：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/etc/fancontrol
</pre></div>
</div>
<p>风扇控制在启动时由systemd服务启动。可以通过以下方式禁用它：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>systemctl<span class="w"> </span>disable<span class="w"> </span>fancontrol
</pre></div>
</div>
<p>GPIO风扇的设备树配置：<a class="extlink-imx-dt reference external" href="https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n26">https://git.phytec.de/linux-imx/tree/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n26</a></p>
</section>
</section>
<section id="watchdog">
<h2><span class="section-number">7.22. </span>看门狗<a class="headerlink" href="#watchdog" title="Link to this heading"></a></h2>
<p>PHYTEC i.MX 8M Plus 模块包含一个硬件看门狗，当系统挂起时能够重置开发板。看门狗在 U-Boot 中默认启动，超时时间为 60 秒。因此，即使在早期内核启动过程中，看门狗也已经开始运行。Linux 内核驱动程序控制看门狗，并确保它有被踢到。本节将解释如何使用 systemd 在 Linux 中配置看门狗，以避免系统挂起和重启期间的情况。</p>
<section id="watchdog-support-in-systemd">
<h3><span class="section-number">7.22.1. </span>Systemd中的看门狗支持<a class="headerlink" href="#watchdog-support-in-systemd" title="Link to this heading"></a></h3>
<p>Systemd 从版本 183 开始支持硬件看门狗。</p>
<ul>
<li><p>要启用看门狗支持，需要通过启用选项来配置 <code class="docutils literal notranslate"><span class="pre">/etc/systemd/</span></code> 中的文件system.conf文件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RuntimeWatchdogSec=60s
ShutdownWatchdogSec=10min
</pre></div>
</div>
</li>
</ul>
<p><em>RuntimeWatchdogSec</em> 定义了看门狗的超时时间，而 <em>ShutdownWatchdogSec</em> 定义了系统重启时的超时时间。有关 systemd 下硬件看门狗的更多详细信息，请访问 <a class="reference external" href="http://0pointer.de/blog/projects/watchdog.html">http://0pointer.de/blog/projects/watchdog.html</a>。更改将在重启后生效，或者运行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$  </span>systemctl<span class="w"> </span>daemon-reload
</pre></div>
</div>
</section>
</section>
<section id="snvs-power-key">
<h2><span class="section-number">7.23. </span>snvs电源按键<a class="headerlink" href="#snvs-power-key" title="Link to this heading"></a></h2>
<p>连接到开关按钮的 X_ONOFF 引脚可以长按以触发关机，而无需软件干预，或用于唤醒系统以退出挂起状态。使用 <em>snvs_pwrkey</em> 驱动程序时，当按下按钮时，KEY_POWER 事件也会报告给用户空间。默认情况下，systemd 被配置为忽略此类事件。关机而无需软件干预的功能以及从挂起状态唤醒的功能未被配置。可以在 <code class="docutils literal notranslate"><span class="pre">/etc/systemd/logind.conf</span></code> 中配置按下开/关按钮时通过 systemd 触发关机，配置方法如下：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HandlePowerKey=poweroff
</pre></div>
</div>
</section>
<section id="npu">
<h2><span class="section-number">7.24. </span>NPU<a class="headerlink" href="#npu" title="Link to this heading"></a></h2>
<p>The i.MX 8M Plus SoC contains a Neural Processing Unit up to 2.3 TOPS as an accelerator
for artificial intelligence operations. Refer to our latest phyCORE-i.MX 8M Plus AI Kit
Guide on the phyCORE-i.MX 8M Plus download section to get information about the
NPU: <a class="reference external" href="https://www.phytec.de/cdocuments/?doc=ZQBhDw">L-1015e.A0 phyCORE-i.MX 8M Plus AI Kit Guide</a></p>
<section id="nxp-examples-for-eiq">
<h3><span class="section-number">7.24.1. </span>NXP eIQ 示例<a class="headerlink" href="#nxp-examples-for-eiq" title="Link to this heading"></a></h3>
<p>NXP提供了一组使用Python3的针对eIQ的机器学习示例，。要添加一个预配置的机器学习软件包，请将其添加到你的local.conf中并编译你的BSP:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMAGE_INSTALL_append = &quot; packagegroup-imx-ml python3-pip python3-requests opencv&quot;
</pre></div>
</div>
<p>This will require about 1GB of additional space on the SD Card. Instructions
on how to install and use the NXP examples can be found at
<a class="reference external" href="https://community.nxp.com/t5/NXP-Tech-Blog/PyeIQ-3-x-Release-User-Guide/ba-p/1305998">https://community.nxp.com/t5/NXP-Tech-Blog/PyeIQ-3-x-Release-User-Guide/ba-p/1305998</a>.</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>使用pip3安装eiq示例需要互联网连接。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在某些Ubuntu 20.04主机上，cmake在编译python3-pybind11时使用主机的Python 3，而不是Yocto中的Python 3.7。（参见：<a class="reference external" href="https://community.nxp.com/t5/i-MX-Processors/Yocto-L5-4-70-2-3-0-build-image-failed/m-p/1219619">https://community.nxp.com/t5/i-MX-Processors/Yocto-L5-4-70-2-3-0-build-image-failed/m-p/1219619</a>）</p>
<p>可以用以下方法解决，修改python3-pybind11的recipe：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ devtool edit-recipe python3-pybind11
</pre></div>
</div>
<p>并将以下内容加入文件:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EXTRA_OECMAKE += &quot;-DPYTHON_EXECUTABLE=${RECIPE_SYSROOT_NATIVE}/usr/bin/python3-native/python3.7&quot;
</pre></div>
</div>
</div>
</section>
</section>
<section id="isp">
<h2><span class="section-number">7.25. </span>ISP<a class="headerlink" href="#isp" title="Link to this heading"></a></h2>
<p>i.MX 8M Plus SoC包含一个图像信号处理器（ISP）。有关更多信息，请参阅|sbc| i.MX 8M Plus 文档中的使用ISP部分。</p>
</section>
<section id="on-chip-otp-controller-ocotp-ctrl-efuses">
<h2><span class="section-number">7.26. </span>片上一次性可编程控制器 (OCOTP_CTRL) - eFuse<a class="headerlink" href="#on-chip-otp-controller-ocotp-ctrl-efuses" title="Link to this heading"></a></h2>
<p>该 i.MX 8M Plus 提供一次性可编程fuse，用于存储信息，例如 MAC 地址、启动配置和其他永久设置（在 i.MX 8M Plus reference manual中称为“片上 OTP 控制器 (OCOTP_CTRL)”）。以下列表摘自 i.MX 8M Plus reference manual，包括 OCOTP_CTRL 中的一些有用寄存器（基地址为0x30350000）：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>名称</p></th>
<th class="head"><p>Bank</p></th>
<th class="head"><p>字</p></th>
<th class="head"><p>内存偏移量为0x30350000</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OCOTP_MAC_ADDR0</p></td>
<td><p>9</p></td>
<td><p>0</p></td>
<td><p>0x640</p></td>
<td><p>包含ENET0 MAC地址的低32位</p></td>
</tr>
<tr class="row-odd"><td><p>OCOTP_MAC_ADDR1</p></td>
<td><p>9</p></td>
<td><p>1</p></td>
<td><p>0x650</p></td>
<td><p>包含ENET0 MAC地址的高16位和ENET1 MAC地址的低16位</p></td>
</tr>
<tr class="row-even"><td><p>OCOTP_MAC_ADDR2</p></td>
<td><p>9</p></td>
<td><p>2</p></td>
<td><p>0x660</p></td>
<td><p>包含 ENET1 MAC 地址的高 32 位</p></td>
</tr>
</tbody>
</table>
<p>关于OCOTP_CTRL中的fuse与启动配置之间的完整列表和详细映射，请参阅 i.MX 8M Plus Security Reference Manual中的 &quot;Fuse Map&quot; 部分。</p>
<section id="reading-fuse-values-in-uboot">
<h3><span class="section-number">7.26.1. </span>在uBoot中读取fuse的值<a class="headerlink" href="#reading-fuse-values-in-uboot" title="Link to this heading"></a></h3>
<p>您可以使用内存映射的shadow寄存器读取fuse寄存器。要计算内存地址，请使用以下公式计算：</p>
<p>OCOTP_MAC_ADDR:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; fuse read 9 0
</pre></div>
</div>
</section>
<section id="reading-fuse-values-in-linux">
<h3><span class="section-number">7.26.2. </span>在Linux中读取fuse值<a class="headerlink" href="#reading-fuse-values-in-linux" title="Link to this heading"></a></h3>
<p>要访问Linux中的fuse内容，NXP提供了NVMEM_IMX_OCOTP模块。所有内存映射的shadow寄存器的fuse内容可以通过sysfs访问：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span>hexdump<span class="w"> </span>/sys/devices/platform/soc@0/30000000.bus/30350000.efuse/imx-ocotp0/nvmem
</pre></div>
</div>
<p>除非*ocotp_root_clk*已启用，否则使用``/dev/mem``读取寄存器会导致系统挂起。要永久启用此时钟，请在设备树中添加：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&amp;clk {
        init-on-array = &lt;IMX8MP_CLK_OCOTP_ROOT&gt;;
};
</pre></div>
</div>
</section>
</section>
</section>
<section id="soc-mcore">
<h1><span class="section-number">8. </span>i.MX 8M Plus M7 Core<a class="headerlink" href="#soc-mcore" title="Link to this heading"></a></h1>
<p>除了Cortex-A53核心外，SoC中还集成了一个Cortex-M7 Core 作为MCU。我们的Yocto-Linux-BSP在A53核心上运行，而 M7 Core 可以作为辅助CPU，用于使用裸机或RTOS固件执行额外任务。两种核心都可以访问相同的外设，因此外设的使用需要在 M7 Core 的固件或Linux操作系统的设备树中进行限制。本节将描述如何编译固件示例以及如何在 phyBOARD-Pollux 上运行它们。</p>
<p>phyBOARD-Pollux 目前由 NXP MCUXpresso SDK 和 Zephyr 项目支持。本节仅描述 NXP MCUXpresso SDK，因为目前 MCUXpresso SDK 支持的功能更多。</p>
<p>如果您想在Zephyr项目中使用 M7 Core ，请参考Zephyr项目文档：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.zephyrproject.org/latest/boards/phytec/mimx8mp_phyboard_pollux/doc/index.html">https://docs.zephyrproject.org/latest/boards/phytec/mimx8mp_phyboard_pollux/doc/index.html</a></p></li>
</ul>
<section id="getting-the-firmware-examples">
<h2><span class="section-number">8.1. </span>获取固件示例<a class="headerlink" href="#getting-the-firmware-examples" title="Link to this heading"></a></h2>
<p>固件可以使用NXP MCUxpresso SDK和兼容的编译工具链通过命令行工具进行编译。</p>
<section id="getting-the-sources">
<h3><span class="section-number">8.1.1. </span>获取源代码<a class="headerlink" href="#getting-the-sources" title="Link to this heading"></a></h3>
<p>MCUX SDK以及 i.MX 8M Plus 的示例可以从PHYTEC的GitHub页面获取：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/phytec/mcux-sdk/">https://github.com/phytec/mcux-sdk/</a></p></li>
<li><p><a class="reference external" href="https://github.com/phytec/mcux-sdk-phytec-examples/">https://github.com/phytec/mcux-sdk-phytec-examples/</a></p></li>
</ul>
<ol class="arabic">
<li><p>通过west初始化MCUX SDK：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>west<span class="w"> </span>init<span class="w"> </span>-m<span class="w"> </span>https://github.com/phytec/mcux-sdk/<span class="w"> </span>--mr<span class="w"> </span>&lt;VERSION&gt;<span class="w"> </span>mcuxsdk
</pre></div>
</div>
<p>这将创建一个 mcuxsdk 目录，并在其中包含 mcux-sdk 仓库。<code class="docutils literal notranslate"><span class="pre">mcux-sdk-phytec-examples</span></code> 仓库将自动克隆到 mcuxsdk 目录中。给定的参数 &lt;VERSION&gt; 是 mcux-sdk 仓库的分支名称，代表 MCUX SDK 版本。要获取最新的测试版本，您可以使用 2.13.0。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">west</span></code> 是一个仓库管理工具，也是 Zephyr 项目的一部分。要安装 west，您可以使用 pip。在这个示例中，west 被安装在一个 Python 虚拟环境中:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host:~$ sudo apt install python3-venv python3-pip
host:~$ python3 -m venv west-env
host:~$ source west-env/bin/activate
(west-env) host:~$ pip3 install west
</pre></div>
</div>
</div>
</li>
<li><p>更新依赖项：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">cd</span><span class="w"> </span>mcuxsdk
<span class="gp">host:~/mcuxsdk$ </span>west<span class="w"> </span>update
</pre></div>
</div>
<p>目录 <code class="docutils literal notranslate"><span class="pre">examples-phytec</span></code> 包含了所有移植并测试过的示例，适用于 phyBOARD-Pollux 和版本为 2.13.0 的 MCUX。</p>
<p>要编译固件，需要一个编译器工具链和make/cmake。GNU ARM 嵌入式工具链可能在您的主机linux发行版的仓库中可用，例如Ubuntu。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>gcc-arm-none-eabi<span class="w"> </span>binutils-arm-none-eabi<span class="w"> </span>make<span class="w"> </span>cmake
</pre></div>
</div>
<p>编译器工具链也可以直接从 <a class="reference external" href="https://developer.arm.com/">https://developer.arm.com/</a> 获取。在解压缩文件后，必须将 <code class="docutils literal notranslate"><span class="pre">ARMGCC_DIR</span></code> 添加到环境变量中，例如，对于位于主目录中的 ARM toolchain 10-2020-q4-major 版本：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span><span class="nb">export</span><span class="w"> </span><span class="nv">ARMGCC_DIR</span><span class="o">=</span>~/gcc-arm-none-eabi-10-2020-q4-major
</pre></div>
</div>
</li>
</ol>
</section>
<section id="building-the-firmware">
<h3><span class="section-number">8.1.2. </span>编译固件<a class="headerlink" href="#building-the-firmware" title="Link to this heading"></a></h3>
<p>要编译PHYTEC示例，需要先设置环境</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~/mcuxsdk$ </span><span class="nb">source</span><span class="w"> </span>scripts/setenv
</pre></div>
</div>
<p>编译固件的脚本位于 &lt;sdk-directory&gt;/phytec-mcux-boards/phyboard-pollux/&lt;example_category&gt;/&lt;example&gt;/armgcc。每个可运行的内存位置都有相应的编译脚本，例如：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>./build_release.sh
</pre></div>
</div>
<p>要编译运行在 M7 Core 的 TCM 上的固件。输出将放置在 armgcc 目录下的 release/ 中。.bin 文件可以在 U-Boot 中运行，而 .elf 文件可以在 Linux 中运行。</p>
<p>要编译在DRAM上运行的固件，请运行脚本build_ddr_release。例如。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>./build_ddr_release.sh
</pre></div>
</div>
<p>输出将放置在armgcc目录下的ddr_release/中。.bin文件可以在U-Boot中运行，而.elf文件可以在Linux中运行。</p>
</section>
</section>
<section id="running-mcore-examples">
<h2><span class="section-number">8.2. </span>运行 M7 Core 示例<a class="headerlink" href="#running-mcore-examples" title="Link to this heading"></a></h2>
<p>有两种方法可以运行 M7 Core 的固件，在Linux中使用Remoteproc以及在U-Boot。</p>
<p>要接收调试信息，请在您的主机PC上启动您喜欢的终端软件（例如Minicom、Tio或Tera Term），并将其配置为115200波特率、8个数据位、无奇偶校验和1个停止位（8n1），且不使用握手。</p>
<p>一旦Micro USB电缆连接到 phyBOARD-Pollux 上的USB调试端口，就会注册两个ttyUSB设备。一个打印来自A53核心的调试UART的消息，另一个打印来自 M7 Core 的调试UART的消息。</p>
<section id="running-examples-from-u-boot">
<h3><span class="section-number">8.2.1. </span>从U-Boot运行示例<a class="headerlink" href="#running-examples-from-u-boot" title="Link to this heading"></a></h3>
<p>要使用bootloader U-Boot加载固件，可以使用bootaux命令：</p>
<ol class="arabic simple">
<li><p>准备一张烧写了BSP镜像的SD卡</p></li>
<li><p>将生成的 .bin 文件复制到 SD 卡的第一个分区</p></li>
<li><p>通过按任意键停止自动启动</p></li>
<li><p>根据固件类型输入命令：</p></li>
</ol>
<p>对于在 M7 Core 的TCM中运行的固件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; fatload mmc 1:1 0x48000000 firmware.bin;cp.b 0x48000000 0x7e0000 20000;
u-boot=&gt; bootaux 0x7e0000
## Starting auxiliary core stack = 0x20020000, pc = 0x000004CD...
</pre></div>
</div>
<p>用于在DRAM中运行的固件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; fatload mmc 1:1 0x80000000 firmware.bin
u-boot=&gt; dcache flush
u-boot=&gt; bootaux 0x80000000
## Starting auxiliary core stack = 0x80400000, pc = 0x80000539...
</pre></div>
</div>
<p>程序的输出应显示在 M7 Core 的调试UART上。</p>
</section>
<section id="running-examples-from-linux-using-remoteproc">
<h3><span class="section-number">8.2.2. </span>通过Remoteproc在Linux上运行示例<a class="headerlink" href="#running-examples-from-linux-using-remoteproc" title="Link to this heading"></a></h3>
<p>Remoteproc是一个模块，允许您在运行时从Linux控制 M7 Core 。可以加载为TCM编译的固件，并可以启动或停止执行。要使用Remoteproc，需要设置设备树Overlay：</p>
<p>在开发板的/boot目录中编辑bootenv.txt文件，添加 imx8mp-phycore-rpmsg.dtbo ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>overlays=imx8mp-phycore-rpmsg.dtbo
</pre></div>
</div>
<p>重启目标并在U-Boot中执行:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u-boot=&gt; run prepare_mcore
</pre></div>
</div>
<p>M7 Core 的固件 .elf 文件可以在 /lib/firmware 下找到。要加载固件，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>/lib/firmware/&lt;firmware&gt;.elf<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/remoteproc/remoteproc0/firmware
<span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>start<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/remoteproc/remoteproc0/state
</pre></div>
</div>
<p>要加载不同的固件，M7 Core 需要停止：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">target:~$ </span><span class="nb">echo</span><span class="w"> </span>stop<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/remoteproc/remoteproc0/state
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在开发板上找到的 <code class="docutils literal notranslate"><span class="pre">/lib/firmware</span></code> 中的例子来自NXP的Yocto层meta-imx。要使用您通过MCUX SDK自己编译的样本，请在编译后将它们复制到开发板的 <code class="docutils literal notranslate"><span class="pre">/lib/firmware</span></code> 中。</p>
</div>
</section>
<section id="debugging-using-j-link">
<h3><span class="section-number">8.2.3. </span>使用J-Link进行调试<a class="headerlink" href="#debugging-using-j-link" title="Link to this heading"></a></h3>
<p>Segger软件可以从https://www.segger.com/downloads/jlink/获取。从Segger软件的V7.20a版本开始，访问 i.MX 8M Plus 的 M7 Core 需要将额外的配置文件复制到J-Link软件目录中：NXP J-Link文件用于 i.MX 8M Plus</p>
<p>与J-Link一起，GDB服务器可用于运行和调试软件。在 phyBOARD-Pollux 上，JTAG引脚可以通过 X6 扩展连接器访问。最简单的方法是使用PEB-EVAL-01开发板，该开发板的顶部有一个JTAG接口。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>gdb<span class="w"> </span>gdb-multiarch
</pre></div>
</div>
<p>要启动J-Link软件，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>JLinkGDBServer<span class="w"> </span>-if<span class="w"> </span>JTAG<span class="w"> </span>-device<span class="w"> </span>MIMX8ML8_M7
<span class="go">...</span>
<span class="go">Connected to target</span>
<span class="go">Waiting for GDB connection...</span>
</pre></div>
</div>
<p>使用GDB调试运行固件，请输入：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">host:~$ </span>gdb-multiarch<span class="w"> </span>firmware.elf
<span class="go">...</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">target remote localhost:2331</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">monitor reset</span>
<span class="go">Resetting target</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">load</span>
<span class="go">...</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">monitor go</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="bsp-extensions">
<h1><span class="section-number">9. </span>BSP扩展<a class="headerlink" href="#bsp-extensions" title="Link to this heading"></a></h1>
<section id="chromium">
<h2><span class="section-number">9.1. </span>Chromium<a class="headerlink" href="#chromium" title="Link to this heading"></a></h2>
<p>我们的BSP支持Chromium。您只需几个步骤即可将其包含在 phytec-qt5demo-image 中。</p>
<section id="adding-chromium-to-your-local-conf">
<h3><span class="section-number">9.1.1. </span>将Chromium添加到您的local.conf文件中<a class="headerlink" href="#adding-chromium-to-your-local-conf" title="Link to this heading"></a></h3>
<p>要包含Chromium，您需要在您的local.conf中添加以下行。您可以在&lt;yocto_dir&gt;/build/conf/local.conf中找到这个配置文件。这将把Chromium添加到您下一个镜像编译中。:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IMAGE_INSTALL_append = &quot; chromium-ozone-wayland&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>编译Chromium需要很长时间。</p>
</div>
</section>
<section id="get-chromium-running-on-the-target">
<h3><span class="section-number">9.1.2. </span>在开发板上运行Chromium<a class="headerlink" href="#get-chromium-running-on-the-target" title="Link to this heading"></a></h3>
<p>要运行Chromium，需要一些参数来使用硬件图形加速：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>target$ chromium --use-gl=desktop --enable-features=VaapiVideoDecoder --no-sandbox
</pre></div>
</div>
<p>如果您想通过SSH启动Chromium，您必须首先定义运行Chromium的显示器。例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>target$ DISPLAY=:0
</pre></div>
</div>
<p>在您定义完这个之后，您可以通过上述所示的Weston虚拟终端启动它。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="pd22.1.2.html" class="btn btn-neutral float-left" title="1. PHYTEC 文档" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../imx8mp-fpsc/imx8mp-fpsc.html" class="btn btn-neutral float-right" title="Libra i.MX 8M Plus FPSC 手册" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2025, PHYTEC Messtechnik GmbH。</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    Languages
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>语言</dt>
        
          <dd><a href="https://phytec.github.io/doc-bsp-yocto/index.html">en</a></dd>
        
          <dd><a href="https://phytec.github.io/doc-bsp-yocto/zh_CN/index.html">zh_CN</a></dd>
        
    </dl>
    

    <div style="margin: 10px 0;"></div>
    <dl>
      <dt>Version</dt>
      <dd>imx95-alpha1-94-gf791886</dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>