Keys and Certificates Management
================================

Public Key Infrastructure Tree (PKI tree)
-----------------------------------------

To use a secure boot with a signed bootloader and a signed kernel image,
several keys and certificates are required to sign the images.
The key and certificate creation is a manual process and the public key
infrastructure (PKI) tree must be in place before you start your build.
This BSP includes the PHYTECD development pki-tree as an example. You are
obligated to create your own pki-tree with your own keys and certificates.

.. note::
   It is highly recommended to use different keys for different parts of your
   system to avoid a single point of failure regarding your security concept.

PHYTEC Development Keys (phytec-dev-ca)
---------------------------------------

The included phytec-dev-ca example consists of a self-signed main-ca and three
derived sub-ca's for bootloader, Fit-Image, and RAUC updates.

.. image:: images/phytec-pki.png

The recipes for Bootloader, FIT-Image, and RAUC depend on the
recipe phytec-dev-ca. If you build the BSP for the first time,
the PHYTEC development keys are downloaded from
`<https://github.com/phytec/phytec-dev-ca>`_ to yocto/phytec-dev-ca.
They are used to sign the Bootloader, FIT-Image, Kernel modules, and the RAUC
bundles.

+--------------------+-------------------------------------------------------+------------+
| Name               | Description                                           | Key Type   |
+====================+=======================================================+============+
| main-ca            | self-signed Certificate authority                     | RSA-4096   |
+--------------------+-------------------------------------------------------+------------+
| nxp_ahab_pki       | NXP HABv4 Key Authority for i.MX93                    | NIST P-521 |
+--------------------+-------------------------------------------------------+------------+
|| nxp_habv4_pki     || NXP HABv4 Key Authority for i.MX6/UL/ULL and         || RSA-4096  |
||                   || i.MX8M Nano/Mini/Plus                                ||           |
+--------------------+-------------------------------------------------------+------------+
| ti_k3              | TI K3 Key Authority for AM62 / AM64 / AM68            | RSA-4096   |
+--------------------+-------------------------------------------------------+------------+
| fit                | Kernel FIT-Image signing key and certificate          | RSA-4096   |
+--------------------+-------------------------------------------------------+------------+
|| kernel-modsign    || Key for the Linux kernel module signing facility,    || RSA-4096  |
||                   || independent of CA                                    ||           |
+--------------------+-------------------------------------------------------+------------+
|| rauc-intermediate || RAUC ca (intermediate ca) and                        || RSA-2048  |
||                   || RAUC ca sign development key for signing the bundles ||           |
+--------------------+-------------------------------------------------------+------------+
|| rauc-intermediate || RAUC ca for device certificates to encrypt           || RSA-4096  |
|| -crypt            || update bundles                                       ||           |
+--------------------+-------------------------------------------------------+------------+

The SOC specific nxp_ahab_pki, nxp_habv4_pki and ti_k3 are for signing the boot
container files,
which are verified with the SOC internal unit and SOC rom loader or dedicated
controllers in the SOC.

All keys and certificates are stored in an XCA database phytec-dev-ca.xdb,
which can be configured with the open-source application XCA from
`<https://hohnstaedt.de/xca/>`_.
The password for the phytec-dev-ca.xdb is: phytec-dev-ca

Only the necessary keys and certificates for the build process are exported to
the directory.

.. code-block:: console

   The phytec-dev-ca is installed in the directory
   /<path to>/yocto
   |--build
   |--phytec-dev-ca
   |--source

All keys and certificates are in an XCA database and are not copied to
different paths from the packages in the build folder.
The directory contains only the necessary certificates and keys for the
building process.

.. warning::
   * Use the PHYTEC development keys only for the first test.
   * The PHYTEC development keys are not secure!
   * Create and use your own keys and certificates!

Create Your Own PKI Tree
------------------------

Please create your PKI offline with a separate system.
For example, boot a read-only system from USB which you only use to create
the PKI. The phytec-dev-ca is created with XCA from
`<https://hohnstaedt.de/xca/>`_ , but you can use any other tool, too.

Change PKI-Tree from phytec-dev-ca to Your Own PKI
..................................................

In the configuration class *sources/meta-ampliphy/classes/secureboot.bbclass*,
the path to your PKI tree is initially defined:

.. code-block:: bash

   CERT_PATH ??= "${OEROOT}/../../phytec-dev-ca"

If you want to change the path, then reinit the CERT_PATH ?= in your layer or
overwrite the CERT_PATH in the conf/local.conf

The name of your PKI tree must have a name other than phytec-dev-ca. The recipe
for phytec-dev-ca uses the name "phytec-dev-ca" as a parameter for the clean
command.

After the CERT_PATH has been changed, you must clean and rebuild the
bootloader, FIT-Image, RAUC bundles, and the rootfs!

Create NXP AHAB / HABV4 Keys
----------------------------

NXP provided scripts to create keys and certificates for NXP AHAB or NXP HABV4.
The scripts are from the
`imx-code-signing-tool repository <https://gitlab.apertis.org/pkg/imx-code-signing-tool/-/tree/debian/unstable/keys?ref_type=heads>`_

You can use this script or a PKI application like the XCA to create the keys
and certificates to sign the bootloader or boot container.

For creation, the SRK table and SRK Fuses from the SRK certificates are scripts
in the imx-code-signing-tool repository in the folder add-ons
which used the srktool.
You can install the srktool with

.. code-block:: console

   host:~$ apt install imx-code-signing-tool
   # or build from source
   host:~$ make -C code/obj.linux64 OSTYPE=linux64 ENCRYPTION=yes

More information about cst and HAB4 API you can find in the doc folder of
the imx-code-signing-tool repository.

Create TI K3 keys
-----------------

Key Types Involved in Secure Boot

*  MEK (Manufacture Encryption Key): TI-provided, permanently fused, validates
   TI-signed artifacts.

*  SMPK (Secondary Manufacture Public Key): User-generated, fused into the
   device, used to validate user-signed bootloader images.

*  BMPK (Backup Manufacture Public Key): Optional, user-generated backup key.
   If the SMPK is ever lost or compromised, you can reconfigure the system to
   use the BMPK for bootloader signature verification. The BMPK is strongly
   recommended for robust device security lifecycle management.

Installing the SDK
..................

To create a copy of the OTP Keywriter that includes your own keys, you will
need TI's MCU Plus SDK, CCS, SYSCONFIG, and the OTP keywriter source code.

**For the TI AM62x**
   *  MCU Plus SDK for AM62x (11.01.00.16): https://www.ti.com/tool/download/MCU-PLUS-SDK-AM62X/11.01.00.16
   *  CCS (20.1.0): https://www.ti.com/tool/download/CCSTUDIO/20.1.0
   *  SYSCONFIG (1.24): https://www.ti.com/tool/download/SYSCONFIG/1.24.0.4150
   *  ARM-CGT-CLANG (4.0.1): https://www.ti.com/tool/de-de/download/ARM-CGT-CLANG/4.0.1.LTS
   *  Keywriter (11.01.00) source code must be requested from the AM62X-RESTRICTED-SW section of the AM62x downloads page: https://www.ti.com/tool/PROCESSOR-SDK-AM62X
   *  OTP keywriter firmware supports a maximum certificate length of 6144 bytes
   *  Once you have the MCU Plus SDK set up, install the keywriter source to ``<MCU_PLUS_SDK_DIRECTORY>/source/security``.

**For the TI AM64x**
   *  MCU Plus SDK for AM64x (09.00.00.35): https://www.ti.com/tool/download/MCU-PLUS-SDK-AM64X/09.00.00.35
   *  CCS (12.4.0): https://www.ti.com/tool/download/CCSTUDIO/12.4.0
   *  SYSCONFIG (1.17): https://www.ti.com/tool/download/SYSCONFIG/1.17.0.3128
   *  Keywriter (09.00.00.35) source code must be requested from the AM64X-HS-RESTRICTED-SW section of the AM64x downloads page: https://www.ti.com/secureresources/AM64X-HS-RESTRICTED-SW
   *  OTP keywriter firmware supports a maximum certificate length of 5400 bytes
   *  Once you have the MCU Plus SDK set up, install the keywriter source to ``<MCU_PLUS_SDK_DIRECTORY>/source/security``.

**For the TI AM68x/TDA4x**
   *  TI Processor SDK RTOS for J721S2 (10.01.00.04): https://www.ti.com/tool/download/PROCESSOR-SDK-RTOS-J721S2/10.01.00.04
   *  GCC Compiler (9.2-2019.12): https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
   *  CCS (12.4.0): https://www.ti.com/tool/download/CCSTUDIO/12.4.0
   *  OTP keywriter add-on package (10.01.00) must be requested from the J7X-RESTRICTED-SECURITY section: https://www.ti.com/secureresources/J7X-RESTRICTED-SECURITY
   *  OTP keywriter firmware supports a maximum certificate length of 6144 bytes
   *  Follow the Readme instructions of the OTP keywriter add-on package
   *  Additional installation step

   .. code-block:: console

      host:~$ cd <MCU_PLUS_SDK_DIRECTORY>
      host:~$ ./sdk_builder/scripts/setup_psdk_rtos.sh
      host:~$ cd <MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/scripts/
      host:~$ mkdir tifek
      host:~$ cp ti_fek_public.pem tifek/

.. note::
   Wait for your access request approval by TI, this usually takes 1-3 days.
   Building the keywriter has only been tested with the specified versions!

Before we begin programming keys, we need to make changes to the source code.

**For the TI AM62x**
   In ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/am62x-sk/r5fss0-0_nortos/main.c`` disable or remove line 76:

   Disable the voltage Vpp setting:

   .. code-block:: console

      //keywriter_setVpp();

   This is because there is a pin on the SoC that needs to be set high to write
   keys, and TI does this using I2C on their boards which requires this function
   to run. We will set this pin using a jumper on our board.

**For the TI AM64x**
   In ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/am64x-evm/r5fss0-0_nortos/main.c`` disable or remove line 61:

   Disable the voltage Vpp setting:

   .. code-block:: console

      //keywriter_setVpp();

   This is because there is a pin on the SoC that needs to be set high to write
   keys, and TI does this using I2C on their boards which requires this function
   to run. We will set this pin using a jumper on our board.

**For the TI AM68x/TDA4x**
   In ``<MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/soc/j721s2/keywriter_utils.c``

   Activate the voltage Vpp on the phyCORE-AM68x with this patch ``patch < diff.patch``

   .. code-block:: console

      --- keywriter_utils.c	2024-12-12 18:18:53.000000000 +0100
      +++ keywriter_utils.c	2025-08-25 11:41:59.935563549 +0200
      @@ -40,6 +40,9 @@

      #include "keywriter_utils.h"
      #include "board_utils.h"
      +#include "board_internal.h"
      +
      +#define MAIN_CTRL_BASE      (0x00100000U)

      static void keywr_leo_pmicb_set_params(Pmic_CoreCfg_t *pmicConfigData)
      {
      @@ -164,37 +167,21 @@
      */
      void OTP_VppEn(void)
      {
      -    Board_I2cInitCfg_t i2cCfg;
      -    Board_IDInfo_v2    info;
      -    Board_STATUS       status;
      -    bool               skBoardDet = BFALSE;
      -
      -    i2cCfg.i2cInst    = BOARD_I2C_EEPROM_INSTANCE;
      -    i2cCfg.socDomain  = BOARD_SOC_DOMAIN_WKUP;
      -    i2cCfg.enableIntr = BFALSE;
      -    Board_setI2cInitConfig(&i2cCfg);
      -
      -    /* Check if the board is SK */
      -    status = Board_getIDInfo_v2(&info, KEYWRITER_SK_EEPROM_SLAVE_ADDR);
      -    if(BOARD_SOK == status)
      -    {
      -        if(!(strncmp(info.boardInfo.boardName,
      -                     "AM68-SK-SOM",
      -                     BOARD_BOARD_NAME_LEN)))
      -        {
      -            UART_printf("AM68 SK Detected!!\n");
      -            skBoardDet = BTRUE;
      -        }
      -    }
      +    uint32_t regVal;

      -    if(BTRUE == skBoardDet)
      -    {
      -        /* Enable VPP for AM68 SK board */
      -        OTP_VppEn_SK();
      -    }
      -    else
      -    {
      -        /* Enable VPP for J721S2 EVM or a Custom board */
      -        OTP_VppEn_EVM();
      -    }
      +    UART_printf("OTP_VppEn_phyCORE-AM68x/TDV4 \n");
      +
      +    /* pinmux padconfig*/
      +    mmr_unlock(MAIN_CTRL_BASE,7);
      +    HW_WR_REG32(BOARD_MAIN_PMUX_CTRL_ADDR+PIN_MCAN12_RX, PIN_PULL_DISABLE | PIN_MODE(7));
      +
      +    /* Set the MAIN GPIO 0 Pin 2 direction to output */
      +    regVal = (HW_RD_REG32(CSL_GPIO0_BASE+0x10)) & (~(0x1 << 0x02));
      +    HW_WR_REG32(CSL_GPIO0_BASE+0x10, regVal);
      +
      +    /* Set the MAIN GPIO 0 Pin 2 value to high */
      +    regVal = (HW_RD_REG32(CSL_GPIO0_BASE+0x14)) | (0x1 << 0x02);
      +    HW_WR_REG32(CSL_GPIO0_BASE+0x14, regVal);
      +
      +    UART_printf("OTP Vpp is Enabled!\n");
      }

   This is because there is a pin on the SoC that needs to be set high to write
   keys and a GPIO is on use of the phyCORE-AM68x.

Generating keys
...............

The keywriter source comes with a tool to help generate your own keys.
To generate keys, go to

   *  AM62x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am62x``
   *  AM64x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am64x``
   *  AM68x: ``<MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/scripts``

and run

.. code-block:: console

   host:~$ ./gen_keywr_cert.sh -g

This will create a set of five keys in the ``keys/`` directory.

Alternatively you can copy the PHYTEC dummy keys to this folder,
which you can get from https://github.com/phytec/phytec-dev-ca/tree/main/ti_k3

You can use the keywriter to flash these keys to your hardware
and you will need to keep them safe to use for signing your images as well.

Building the Keywriter
......................

There are two methods for creating the keywriter. You can create one keywriter
that contains all of your keys and configuration (e.g. JTAG configuration),
or you can make one keywriter per key and configurations.
The all-at-once approach is more straightforward, but if your key certificates
end up with a certificate exceeding the maximum certificate length you may need
to use the incremental approach.

Generate Incremental Certificates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you end up with a certificate exceeding the maximum certificate length while
trying to build and program all the keys at once, you may need to flash the
keys incrementally. To do this you will need separate certificates for each key.
Starting in

   *  AM62x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am62x``,
   *  AM64x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am64x``,
   *  AM68x: ``<MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/scripts``,

.. note::
   Each certificate results in one programming step with a fresh boot of the
   device. Until the KEYREV value is set to either 1 or 2, the device is
   considered an HS-FS device, and key values can continue being programmed
   incrementally. So, programming the KEYREV should be left to the final step.

*  generate the first certificate for the Model Specific Value (MSV), the SMPK and
   the SMEK key:

   .. code-block:: console
      :caption: MSV+SMPK+SMEK

      host:~$  ./gen_keywr_cert.sh --msv 0xC0FFE -s keys/smpk.pem --smek keys/smek.key --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   *  Override parameter: ``--msv-ovrd, -s-ovrd, --smek-ovrd``
   *  Readout Protection: ``--msv-rp, -s-rp, --smek-rp``
   *  Overwrite Protection ``--msv-wp, --s-wp, --smek-wp``

*  generate a certificate for the backup key BMPK and BMEK.

   .. code-block:: console
      :caption: BMPK+BMEK

      host:~$  ./gen_keywr_cert.sh -b keys/bmpk.pem --bmek keys/bmek.key --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   *  Override parameter: ``-b-ovrd, --bmek-ovrd``
   *  Readout Protection: ``--b-rp, --bmek-rp``
   *  Overwrite Protection ``--b-wp, --bmek-wp``

*  generate a certificate to disable JTAG

   .. code-block:: console
      :caption: Disable JTAG

      host:~$  ./gen_keywr_cert.sh --jtag-disable --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   You can add this directly to the first certificate.

   *  Override parameter: ``--jtag-disable-ovrd``
   *  Readout Protection: ``--jtag-disable-rp``
   *  Overwrite Protection ``--jtag-disable-wp``

* generate a certificate for Secure Board Config

   `The Secure Board Configuration <https://software-dl.ti.com/tisci/esd/latest/3_boardcfg/BOARDCFG_SEC.html#>`_

   .. code-block:: console
      :caption: Secure Board Config

      host:~$  ./gen_keywr_cert.sh --sr-bcfg <board configuration> --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   *  Override parameter: ``--sr-bcfg-ovrd``
   *  Readout Protection: ``--sr-bcfg-rp``
   *  Overwrite Protection ``--sr-bcfg-wp``

*  Additionally, if the extended OTP needs to be programmed via keywriter
   (for USB/PCIE VID/PID), make sure to program the extended OTP before
   converting the device to an HS-SE device!

   .. code-block:: console
      :caption: Extended OTP

      host:~$  ./gen_keywr_cert.sh --ext-otp ext_otp_data.bin --ext-otp-indx 1 --ext-otp-size 3 --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   *  Readout and Overwrite Protection: ``---ext-otp-wprp``

*  generate certificate to set keycnt and keyref to enable the HS-SE device with
   secure boot

   *  keycnt = 1 for only SMPK, keycnt = 2 for using SMPK and BMPK
   *  keyrev = 1for active SMPK, keyrev = 2 for active BMPK

   .. code-block:: console
      :caption: Activate Secure Boot

      host:~$  ./gen_keywr_cert.sh --keycnt 2 --keyrev 1 --aes256 keys/aes256.key -t tifek/ti_fek_public.pem

   *  Override parameter: ``--keycnt-ovrd, --keyrev-ovrd``
   *  Readout Protection: ``--keycnt-rp, --keyrev-rp``
   *  Overwrite Protection ``--keycnt-wp, --keyrev-wp``

If you create one certificate, then generate the keywriter and run it on the
device.

Generate One Shot Certificate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using the keys generated in the previous step, we can now generate a
certificate to sign our hardware and enable secure boot. Go to

   *  AM62x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am62x``
   *  AM64x: ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/am64x``
   *  AM68x: ``<MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/scripts``

and run the following:

.. code-block:: console

   host:~$ ./gen_keywr_cert.sh -t tifek/ti_fek_public.pem --msv 0xC0FFE -s keys/smpk.pem --smek keys/smek.key -b keys/bmpk.pem --bmek keys/bmek.key --jtag-disable --keycnt 2 --keyrev 1

.. note::
   Please add Readout and Overwrite protection for the field.

This generates a certificate containing our keys (primary_cert.bin).
Please note the maximum certificate length limit, which requires incremental
certificates writing.

Build the keywriter
~~~~~~~~~~~~~~~~~~~

**For the TI AM62x**
   .. code-block:: console

      host:~$  cd <MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/am62x-sk/r5fss0-0_nortos/ti-arm-clang/
      host:~$  make -sj PROFILE=debug clean
      host:~$  make -sj PROFILE=debug

   The keywriter for the certificate has now been built and is in the
   ``tiboot3.bin`` file in ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/am62x-sk/r5fss0-0_nortos/ti-arm-clang``.

**For the TI AM64x**
   .. code-block:: console

      host:~$  cd <MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/scripts/cert_gen/x509cert
      host:~$  python3 ../../../../../tools/bin2c/bin2c.py final_certificate.bin keycert.h KEYCERT
      host:~$  cd ../../am64x-evm/r5fss0-0_nortos/ti-arm-clang/
      host:~$  make -sj PROFILE=debug clean
      host:~$  make -sj PROFILE=debug

   The keywriter for the certificate has now been built and is in the
   ``tiboot3.bin`` file in ``<MCU_PLUS_SDK_DIRECTORY>/source/security/sbl_keywriter/am64x-evm/r5fss0-0_nortos/ti-arm-clang``

**For the TI AM68x/TDA4x**
   .. code-block:: console

      host:~$  cd <MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/build
      host:~$  make keywriter_img_clean SOC=j721s2 BOARD=j721s2_evm
      host:~$  make keywriter_img SOC=j721s2 BOARD=j721s2_evm PROFILE=debug -sj

   The keywriter for the certificate has now been built and is in the
   ``tiboot3.bin`` file is ``<MCU_PLUS_SDK_DIRECTORY>/<PDK_j721s2_DIRECTORY>/packages/ti/boot/keywriter/binary/j721s2/keywriter_img_combined_j721s2_release.tiimage``

Save it elsewhere so that we can build the other keywriters without overwriting
this one. Make sure that you keep track of the binaries so that you can flash
them in the correct order later.

Create Kernel FIT-Image key
---------------------------

You can create the Kernel FIT-Image Key with a PKI Tool or openssl.

For the signing of the Kernel FIT-Image the private key is used. The public key
is build into as device-tree node in the bootloader and used for the FIT-Image
verification.

The certificate is not necessary for the signing and verification of the
FIT-Image.

Create Kernel Module Signing key
--------------------------------

You can create the Key and certificate for kernel module signing with a PKI
tool or openssl. You must combine the private key and the certificate to one
file.

.. code-block:: console

   host:~$ cat private.key certificate.pem > kernel_modsign.pem

Create rauc update certificates
-------------------------------

You can create the Key and certificate for rauc with a PKI tool or openssl.
More details on the
`rauc documentation <https://rauc.readthedocs.io/en/latest/advanced.html#ca-configuration>`_
