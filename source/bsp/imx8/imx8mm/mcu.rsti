|soc| |mcore|
=============

In addition to the Cortex-A53 cores, there is a Cortex-|mcore| as MCU integrated
into the |soc| SoC. Our Yocto-Linux-BSP runs on the A53-Cores and the |mcore|
can be used as a secondary core for additional tasks using bare-metal or RTOS
firmware. Both cores have access to the same peripherals and thus peripheral
usage needs to be limited either in the |mcore|'s firmware or the devicetree for
the Linux operating system. This section describes how to build firmware
examples and how to run them on |sbc|.

Getting the Firmware Examples
-----------------------------

The firmware can be built using the NXP MCUxpresso SDK with a compatible
compiler toolchain using command-line tools.

Getting the Sources
...................

The SDK and the examples for the |soc| can be obtained from NXP's web page:

* https://mcuxpresso.nxp.com/

1. Register and log into the SDK Builder
2. Select Board / Processor → Processors → i.MX → 8M Mini Quad → MIMX8MM6xxxLZ
3. select version 2.10.0 and press “Build MCUXpresso SDK”
4. On the SDK Builder page select Linux Host and GCC ARM Embedded toolchain
5. Select the optional components (as of SDK v2.10.0) multicore, CMSIS DSP
   Library, FreeRTOS, and download the SDK archive

The |mcore| examples ported for |sbc| can be obtained in an additional
repository, which can be cloned into the SDK once it is extracted:

extract the SDK::

   host$ tar -xf SDK_2_10_0_MIMX8MM6xxxLZ.tar.gz

clone the repository::

   host$ git clone https://git.phytec.de/phytec-mcux-boards --branch SDK_2.10.0-phy

Phytec-mcux-boards contains all examples ported and tested for |sbc| with
version 2.10.0. of the NXP SDK.

To build the firmware, a compiler toolchain and make/cmake are required. The GNU
Arm Embedded Toolchain might be available in your distribution's repositories,
e.g. type for Ubuntu 20.04::

   host$ sudo apt install gcc-arm-none-eabi binutils-arm-none-eabi make cmake
   host$ export ARMGCC_DIR=/usr

Alternatively, the toolchain can also be obtained directly from
https://developer.arm.com/. After the archive has been extracted, the
ARMGCC_DIR has to be added to the environment, e.g. for the toolchain
10-2020-q4-major release located in the home directory::

   host$ export ARMGCC_DIR=~/gcc-arm-none-eabi-10-2020-q4-major

Building the Firmware
.....................

The scripts to build the firmware are located
in<sdk-directory>/phytec-mcux-boards/phyboard-polis/<example_category>/<example>/armgcc.
There are scripts in each location to build the firmware::

   host$ ./build_release.sh

To build the firmware for the |mcore|'s TCM. The output will be placed under
release/ in the armgcc directory. .bin files and can be run in U-Boot and .elf
files within Linux.

Running |mcore| Examples
------------------------

There are two ways to run the |mcore| with the built firmware, U-Boot and
Remoteproc within a running Linux.

To receive debug messages start your favorite terminal software (e.g. Minicom,
Tio, or Tera Term) on your host PC and configure it for 115200 baud, 8 data
bits, no parity, and 1 stop bit (8n1) with no handshake.

Once a micro-USB cable is connected to the USB-debug port on the |sbc|, two
ttyUSB devices are registered. One prints messages from A53-Core's debug UART
and the other one from the |mcore|'s debug UART.

.. Hint::

   Only the newer revision (1532.2) of the phyBOARD-Polis-MINI registers the
   debug UART as ttyUSB on the USB-debug port. With the older revision (1532.1)
   the debug UART is on the X8 connector.

Running Examples from U-Boot
............................

To load firmware using the bootloader U-Boot, the bootaux command can be used:

1. Prepare an SD card with our Yocto-BSP
2. Copy the generated .bin file to the SD-Cards boot partition
3. Stop the autoboot by pressing any key
4. Type the command depending on the type of firmware:

For firmware built to run in the |mcore|'s TCM::

   u-boot=> fatload mmc 1:1 0x48000000 firmware.bin;cp.b 0x48000000 0x7e0000 20000;
   u-boot=> bootaux 0x7e0000
   ## Starting auxiliary core stack = 0x20020000, pc = 0x1FFE0379…

For firmware built to run in the DRAM::

   u-boot=> fatload mmc 1:1 0x80000000 firmware.bin
   u-boot=> dcache flush
   u-boot=> bootaux 0x80000000
   ## Starting auxiliary core stack = 0x80400000, pc = 0x80000539...

The program's output should appear on the |mcore|'s debug UART

Running Examples from Linux using Remoteproc
............................................

Remoteproc is a module that allows you to control the |mcore| from Linux during
runtime. Firmware built for TCM can be loaded and the execution started or
stopped. To use Remoteproc a devicetree overlay needs to be set:

edit the bootenv.txt file located in the /boot directory on the target by adding
|kernel-socname|-phycore-rpmsg.dtbo::

   overlays=imx8mm-phyboard-polis-peb-eval-01.dtbo imx8mm-phyboard-polis-peb-av-010.dtbo imx8mm-phycore-rpmsg.dtbo

Firmware .elf files for the |mcore| can be found under /lib/firmware. To load
the firmware, type::

   target$ echo /lib/firmware/<firmware>.elf > /sys/class/remoteproc/remoteproc0/firmware
   target$ echo start > /sys/class/remoteproc/remoteproc0/state

To load a different firmware, the |mcore| needs to be stopped::

   target$ echo stop > /sys/class/remoteproc/remoteproc0/state

Debugging Using J-Link
......................

The Segger software can be obtained from https://www.segger.com/downloads/jlink/.

Together with the J-Link, a GDB Server can be used for running and debugging the
software.  On the |sbc|, the JTAG-Pins are accessible via the X8 Expansion
Connector. The simplest way is to use a PEB-EVAL-01 board that has the JTAG-Pins
reachable with a pin header on the top.

Install the GDB server::

   host$ sudo apt install gdb gdb-multiarch

To start the J-Link software, type::

   host$ JLinkGDBServer -if JTAG -device MIMX8MM6_M4
   ...
   Connected to target
   Waiting for GDB connection...

To start GDB with a firmware example in another window, type::

   host$ $host gdb-multiarch firmware.elf
   ...
   (gdb) target remote localhost:2331
   (gdb) monitor reset
   (gdb) load
   ...
   (gdb) monitor go
