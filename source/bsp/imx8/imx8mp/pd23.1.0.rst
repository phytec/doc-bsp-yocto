.. Download links
.. |dlpage-bsp| replace:: our BSP
.. _dlpage-bsp: https://www.phytec.de/bsp-download/?bsp=BSP-Yocto-NXP-i.MX8MP-PD23.1.0
.. |dlpage-product| replace:: https://www.phytec.de/produkte/system-on-modules/phycore-imx-8m-plus/#downloads
.. _dl-server: https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/
.. _dl-sdk: https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD23.1.0/sdk/ampliphy-vendor-xwayland/
.. |link-image| replace:: https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD23.1.0/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/phytec-qt6demo-image-phyboard-pollux-imx8mp-3.wic
.. |link-partup-package| replace:: https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD23.1.0/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/phytec-qt6demo-image-phyboard-pollux-imx8mp-3.partup
.. |link-boot-tools| replace:: https://download.phytec.de/Software/Linux/BSP-Yocto-i.MX8MP/BSP-Yocto-NXP-i.MX8MP-PD23.1.0/images/ampliphy-vendor-xwayland/phyboard-pollux-imx8mp-3/imx-boot-tools/
.. _releasenotes: https://git.phytec.de/phy2octo/tree/releasenotes?h=imx8mp

.. IMX8(MP) specific
.. _overlaycallback: https://git.phytec.de/u-boot-imx/tree/board/phytec/phycore_imx8mp/phycore-imx8mp.c?h=v2022.04_2.2.2-phy5#n149


.. General Substitutions
.. |kit| replace:: **phyCORE-i.MX8M Plus Kit**
.. |kit-ram-size| replace:: 2GiB
.. |sbc| replace:: phyBOARD-Pollux
.. |soc| replace:: i.MX 8M Plus
.. |socfamily| replace:: i.MX 8
.. |som| replace:: phyCORE-i.MX8MP
.. |debug-uart| replace:: ttymxc0
.. |serial-uart| replace:: ttymxc1
.. |expansion-connector| replace:: X6


.. Linux Kernel
.. |kernel-defconfig| replace:: imx_v8_defconfig imx8_phytec_distro.config imx8_phytec_platform.config
.. |kernel-recipe-path| replace:: meta-phytec/dynamic-layers/freescale-layer/recipes-kernel/linux/linux-imx_*.bb
.. |kernel-repo-name| replace:: linux-imx
.. |kernel-repo-url| replace:: git://git.phytec.de/linux-imx
.. |kernel-socname| replace:: imx8mp
.. |kernel-tag| replace:: v5.15.71_2.2.2-phy3
.. |emmcdev| replace:: mmcblk2

.. Bootloader
.. |u-boot-offset| replace:: 32
.. |u-boot-offset-boot-part| replace:: 0
.. |u-boot-mmc-flash-offset| replace:: 0x40
.. |u-boot-defconfig| replace:: phycore-imx8mp_defconfig
.. |u-boot-emmc-devno| replace:: 2
.. |u-boot-recipe-path| replace:: meta-phytec/recipes-bsp/u-boot/u-boot-imx_*.bb
.. |u-boot-repo-name| replace:: u-boot-imx
.. |u-boot-repo-url| replace:: git://git.phytec.de/u-boot-imx

.. IMX8(MP) specific
.. |u-boot-socname-config| replace:: IMX8MP
.. |u-boot-tag| replace:: v2022.04_2.2.2-phy5


.. RAUC
.. |rauc-manual| replace:: L-1006e.A5 RAUC Update & Device Management Manual
.. _rauc-manual: https://www.phytec.de/cdocuments/?doc=fgByJg


.. Devicetree
.. |dt-carrierboard| replace:: imx8mp-phyboard-pollux-rdk
.. |dt-som| replace:: imx8mp-phycore-som
.. |dtbo-rpmsg| replace:: imx8mp-phycore-rpmsg.dtbo
.. |dtbo-peb-av-10| replace:: imx8mp-phyboard-pollux-peb-av-010.dtbo

.. IMX8(MP) specific
.. |dt-somnetwork| replace:: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n50`

.. Yocto
.. |yocto-bootenv-link| replace:: :yocto-bootenv:`kirkstone`
.. |yocto-bsp-name| replace:: BSP-Yocto-IMX8MP
.. _yocto-bsp-name: `dl-server`_
.. |yocto-codename| replace:: kirkstone
.. |yocto-distro| replace:: ampliphy-vendor-xwayland
.. |yocto-imagename| replace:: phytec-qt6demo-image
.. |yocto-imageext| replace:: wic
.. |yocto-machinename| replace:: phyboard-pollux-imx8mp-3
.. |yocto-manifestname| replace:: BSP-Yocto-NXP-i.MX8MP-PD23.1.0
.. |yocto-manifestname-master| replace:: BSP-Yocto-Ampliphy-i.MX8MP-master
.. |yocto-manifestname-y| replace:: BSP-Yocto-NXP-i.MX8MP-PD23.1.y
.. |yocto-ref-manual| replace:: Yocto Reference Manual (kirkstone)
.. _yocto-ref-manual: https://phytec.github.io/doc-bsp-yocto/yocto/manual-index.html#kirkstone
.. _yocto-ref-manual-kernel-and-bootloader-config: https://phytec.github.io/doc-bsp-yocto/yocto/kirkstone.html#kernel-and-bootloader-configuration
.. |yocto-sdk-rev| replace:: 4.0.13
.. |yocto-sdk-a-core| replace:: cortexa53-crypto

.. Ref Substitutions
.. |ref-bootswitch| replace:: :ref:`bootmode switch (S3) <imx8mp-pd23.1.0-bootswitch>`
.. |ref-bsp-images| replace:: :ref:`BSP Images <imx8mp-pd23.1.0-images>`
.. |ref-debugusbconnector| replace:: :ref:`(X1) <imx8mp-pd23.1.0-components>`
.. |ref-dt| replace:: :ref:`device tree <imx8mp-pd23.1.0-device-tree>`
.. |ref-getting-started| replace:: :ref:`Getting Started <imx8mp-pd23.1.0-getting-started>`
.. |ref-network| replace:: :ref:`Network Environment Customization <imx8mp-pd23.1.0-network>`
.. |ref-setup-network-host| replace:: :ref:`Setup Network Host <imx8mp-pd23.1.0-development>`
.. |ref-usb-otg| replace:: :ref:`X5 (upper connector) <imx8mp-pd23.1.0-components>`
.. |ref-build-uboot| replace:: :ref:`Build U-Boot <imx8mp-pd23.1.0-development-build-uboot>`
.. |ref-disable-emmc-part| replace:: :ref:`Disable booting from eMMC boot partitions <emmc-disable-boot-part>`
.. |ref-format-sd| replace:: :ref:`Resizing ext4 Root Filesystem  <imx8mp-pd23.1.0-format-sd>`


.. IMX8(MP) specific
.. |sbc-network| replace::
   The device tree set up for EQOS Ethernet IP core where the PHY is populated
   on the |sbc| can be found here:
   :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n150`.
.. |pollux-fan-note| replace::
   Starting with BSP-Yocto-i.MX8MP-PD22.1.1 we have to switch from PWM fan
   to GPIO fan due to availability. The PWM fan will not be supported
   anymore and will not function with the new release.
.. |weston-hdmi-mode| replace:: current

.. |ref-serial| replace:: :ref:`X2 <imx8mp-pd23.1.0-components>`
.. |ref-jp3| replace:: :ref:`JP3 <imx8mp-pd23.1.0-components>`
.. |ref-jp4| replace:: :ref:`JP4 <imx8mp-pd23.1.0-components>`
.. |ubootexternalenv| replace:: U-boot External Environment subsection of the
   :ref:`device tree overlay section <imx8mp-pd23.1.0-ubootexternalenv>`


.. M-Core specific
.. |mcore| replace:: M7 Core
.. |mcore-zephyr-docs| replace:: https://docs.zephyrproject.org/latest/boards/phytec/mimx8mp_phyboard_pollux/doc/index.html
.. |mcore-jtag-dev| replace:: MIMX8ML8_M7
.. |mcore-sdk-version| replace:: 2.13.0

+-----------------------+----------------------+
| |soc| BSP Manual                             |
+-----------------------+----------------------+
| Document Title        | |soc| BSP Manual     |
+-----------------------+----------------------+
| Document Type         | BSP Manual           |
+-----------------------+----------------------+
| Yocto Manual          | Kirkstone            |
+-----------------------+----------------------+
| Release Date          | 2024/01/10           |
+-----------------------+----------------------+
| Is Branch of          | |soc| BSP Manual     |
+-----------------------+----------------------+

The table below shows the Compatible BSPs for this manual:

==================== ================ ================ ==========
Compatible BSP'S     BSP Release Type BSP Release Date BSP Status

==================== ================ ================ ==========
|yocto-manifestname| Major            2023/12/12       Released
==================== ================ ================ ==========


.. include:: ../../intro.rsti

Supported Hardware
------------------

On our web page, you can see all supported Machines with the available Article
Numbers for this release: |yocto-manifestname| `download <dlpage-bsp_>`_.

If you choose a specific **Machine Name** in the section **Supported Machines**,
you can see which **Article Numbers** are available under this machine and also
a short description of the hardware information. In case you only have
the **Article Number** of your hardware, you can leave the **Machine
Name** drop-down menu empty and only choose your **Article Number**. Now it
should show you the necessary **Machine Name** for your specific hardware

.. _imx8mp-pd23.1.0-components:
.. include:: components.rsti

.. +---------------------------------------------------------------------------+
.. Getting Started
.. +---------------------------------------------------------------------------+

.. _imx8mp-pd23.1.0-getting-started:

Getting Started
===============

The |kit| is shipped with a pre-flashed SD card. It contains the
|yocto-imagename| and can be used directly as a boot source. The eMMC is
programmed with only a U-Boot by default. You can get all sources from the
`PHYTEC download server <dl-server_>`_. This chapter explains how to flash a BSP
image to SD card and how to start the board.

There are several ways to flash an image to SD card or even eMMC. Most notably
using simple, sequential writing with the Linux command line tool ``dd``. An
alternative way is to use PHYTEC's system initialization program called
`partup <https://github.com/phytec/partup>`_, which makes it especially easy to
format more complex systems. You can get `prebuilt Linux binaries of partup
<https://github.com/phytec/partup/releases>`__ from its release page. Also read
`partup's README <https://github.com/phytec/partup#readme>`__ for installation
instructions.

Get the Image
-------------

The image contains all necessary files and makes sure partitions and any raw
data are correctly written. Both the partup package and the WIC image, which can
be flashed using ``dd``, can be downloaded from the `PHYTEC download server
<dl-server_>`_.

Get either the partup package or the WIC image from the download server:

.. code-block:: console
   :substitutions:

   host:~$ wget |link-partup-package|
   host:~$ wget |link-image|

.. note::
   For eMMC, more complex partitioning schemes or even just large images, we
   recommend using the partup package, as it is faster in writing than ``dd``
   and allows for a more flexible configuration of the target flash device.

Write the Image to SD Card
--------------------------

.. warning::
   To create your bootable SD card, you must have root privileges on your Linux
   host PC. Be very careful when specifying the destination device! All files
   on the selected device will be erased immediately without any further query!

   Selecting the wrong device may result in **data loss** and e.g. could erase
   your currently running system on your host PC!

Finding the Correct Device
..........................

To create your bootable SD card, you must first find the correct device name
of your SD card and possible partitions. If any partitions of the SD cards are
mounted, unmount those before you start copying the image to the SD card.

#. In order to get the correct device name, remove your SD card and
   execute:

   .. code-block:: console

      host:~$ lsblk

#. Now insert your SD card and execute the command again:

   .. code-block:: console

      host:~$ lsblk

#. Compare the two outputs to find the new device names listed in the second
   output. These are the device names of the SD card (device and partitions if
   the SD card was formatted).
#. In order to verify the device names being found, execute the command
   ``sudo dmesg``. Within the last lines of its output, you should also find the
   device names, e.g. ``/dev/sde`` or ``/dev/mmcblk0`` (depending on your
   system).

Alternatively, you may use a graphical program of your choice, like `GNOME Disks
<https://apps.gnome.org/en/DiskUtility/>`_ or `KDE Partition Manager
<https://apps.kde.org/partitionmanager/>`_, to find the correct device.

Now that you have the correct device name, e.g. ``/dev/sde``,
you can see the partitions which must be unmounted if the SD card is formatted.
In this case, you will also find the device name with an appended number
(e.g. ``/dev/sde1``) in the output. These represent the partitions. Some Linux
distributions automatically mount partitions when the device gets plugged in.
Before writing, however, these need to be unmounted to avoid data corruption.

Unmount all those partitions, e.g.:

.. code-block:: console

   host:~$ sudo umount /dev/sde1
   host:~$ sudo umount /dev/sde2

Now, the SD card is ready to be flashed with an image, using either ``partup``,
``dd`` or ``bmap-tools``.

Using partup
............

Writing to an SD card with partup is done in a single command:

.. code-block:: console
   :substitutions:

   host:~$ sudo partup install |yocto-imagename|-|yocto-machinename|.partup /dev/<your_device>

Make sure to replace <your_device> with your actual device name found previously.

Further usage of partup is explained at its `official documentation website
<https://partup.readthedocs.io/en/latest/>`__.

.. note::
   *partup* has the advantage of allowing to clear specific raw areas in the
   MMC user area, which is used in our provided partup packages to erase any
   existing U-Boot environments. This is a known issue *bmaptool* does not
   solve, as mentioned below.

   Another key advantage of partup over other flashing tools is that it allows
   configuring MMC specific parts, like writing to eMMC boot partitions, without
   the need to call multiple other commands when writing.

Using bmap-tools
................

An alternative and also fast way to prepare an SD card is using
`bmap-tools <https://github.com/yoctoproject/bmaptool>`_. Yocto
automatically creates a block map file (``<IMAGENAME>-<MACHINE>.wic.bmap``) for
the WIC image that describes the image content and includes checksums for data
integrity. *bmaptool* is packaged by various Linux distributions. For
Debian-based systems install it by issuing:

.. code-block:: console

   host:~$ sudo apt install bmap-tools

Flash a WIC image to SD card by calling:

.. code-block:: console
   :substitutions:

   host:~$ bmaptool copy |yocto-imagename|-|yocto-machinename|.|yocto-imageext| /dev/<your_device>

Replace <your_device> with your actual SD card's device name found previously,
and make sure to place the file ``<IMAGENAME>-<MACHINE>.wic.bmap`` alongside
the regular WIC image file, so bmaptool knows which blocks to write and which
to skip.

.. warning::
   *bmaptool* only overwrites the areas of an SD card where image data is
   located. This means that a previously written U-Boot environment may still be
   available after writing the image.

Using ``dd``
............

After having unmounted all SD card's partitions, you can create your bootable SD card.

Some PHYTEC BSPs produce uncompressed images (with filename-extension \*.wic),
and some others produce compressed images (with filename-extension \*.wic.xz).

To flash an uncompressed images (\*.wic) use command below:

.. code-block:: console
   :substitutions:

   host:~$ sudo dd if=|yocto-imagename|-|yocto-machinename|.wic of=/dev/<your_device> bs=1M conv=fsync status=progress

Or to flash a compressed images (\*.wic.xz) use that command:

.. code-block:: console
   :substitutions:

   host:~$ xzcat |yocto-imagename|-|yocto-machinename|.wic.xz | sudo dd of=/dev/<your_device> bs=1M conv=fsync status=progress

Again, make sure to replace <your_device> with your actual device name found
previously.

The parameter ``conv=fsync`` forces a sync operation on the device before
``dd`` returns. This ensures that all blocks are written to the SD card and
none are left in memory. The parameter ``status=progress`` will print out
information on how much data is and still has to be copied until it is
finished.

First Start-up
--------------

*  To boot from an SD card, the |ref-bootswitch| needs to be set to the following
   position:

.. image:: images/SD_Card_Boot.png

*  Insert the SD card
*  Connect the target and the host with **mirco USB** on |ref-debugusbconnector|
   debug USB
*  Power up the board

.. +---------------------------------------------------------------------------+
.. Building the BSP
.. +---------------------------------------------------------------------------+

.. include:: /bsp/building-bsp.rsti

.. _imx8mp-pd23.1.0-images:

*  **u-boot.bin**: Binary compiled U-boot bootloader (U-Boot). Not the final
   Bootloader image!
*  **oftree**: Default kernel device tree
*  **u-boot-spl.bin**: Secondary program loader (SPL)
*  **bl31-imx8mp.bin**: ARM Trusted Firmware binary
*  **lpddr4_pmu_train_2d_dmem_202006.bin,
   lpddr4_pmu_train_2d_imem_202006.bin**: DDR PHY firmware images
*  **imx-boot**: Bootloader build by imx-mkimage which includes SPL, U-Boot, ARM
   Trusted Firmware and DDR firmware. This is the final bootloader image which is
   bootable.
*  **Image**: Linux kernel image
*  **Image.config**: Kernel configuration
*  **imx8mp-phyboard-pollux-rdk*.dtb**: Kernel device tree file
*  **imx8mp-phy*.dtbo**: Kernel device tree overlay files
*  **phytec-qt6demo-image\*.tar.gz**: Root file system
*  **phytec-qt6demo-image\*.wic**: SD card image

.. +---------------------------------------------------------------------------+
.. INSTALLING THE OS
.. +---------------------------------------------------------------------------+

Installing the OS
=================

Bootmode Switch (S3)
--------------------

.. tip::

   Hardware revision baseboard: 1552.2

The |sbc| features a boot switch with four individually switchable ports to
select the phyCORE-|soc| default bootsource.

.. _imx8mp-pd23.1.0-bootswitch:
.. include:: bootmode-switch.rsti

Flash eMMC
----------

For consistency, it is assumed that a TFTP server is configured; More
importantly, all generated images, as listed above, are copied to the default
/srv/tftp directory. If you do not have this set up, you need to adjust the
paths that point to the images being used in the instructions. For instructions
on how to set up the TFTP server and directory, see |ref-setup-network-host|.

To boot from eMMC, make sure that the BSP image is flashed correctly to the eMMC
and the |ref-bootswitch| is set to **eMMC**.

.. warning::
   When eMMC and SD card are flashed with the same (identical) image, the UUIDs
   of the boot partitions are also identical. If the SD card is connected when
   booting, this leads to non-deterministic behavior as Linux mounts the boot
   partition based on UUID.

   .. code-block:: console

      target:~$ blkid

   can be run to inspect whether the current setup is affected. If ``mmcblk2p1``
   and ``mmcblk1p1`` have an identical UUID, the setup is affected.

Flash eMMC from Network
.......................

|soc| boards have an Ethernet connector and can be updated over a network. Be
sure to set up the development host correctly. The IP needs to be set to
192.168.3.10, the netmask to 255.255.255.0, and a TFTP server needs to be
available. From a high-level point of view, an eMMC device is like an SD card.
Therefore, it is possible to flash the **WIC image** (``<name>.wic``) from
the Yocto build system directly to the eMMC. The image contains the
bootloader, kernel, device tree, device tree overlays, and root file system.

Flash eMMC from Network in U-Boot on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These steps will show how to update the eMMC via a network.

.. tip::

   This step only works if the size of the image file is less than 1GB due to
   limited usage of RAM size in the Bootloader after enabling OPTEE.

.. tip::

   A working network is necessary! |ref-setup-network-host|

Load your image via network to RAM:

*  when using dhcp

   .. code-block::
      :substitutions:

      u-boot=> dhcp |yocto-imagename|-|yocto-machinename|.wic
      BOOTP broadcast 1
      DHCP client bound to address 192.168.3.1 (1 ms)
      Using ethernet@30be0000 device
      TFTP from server 192.168.3.10; our IP address is 192.168.3.1
      Filename '|yocto-imagename|-|yocto-machinename|.wic'.
      Load address: 0x40480000
      Loading: ######################################
               ######################################
               ######################################
               ...
               ...
               ...
               ######################################
               #############
               11.2 MiB/s
      done
      Bytes transferred = 911842304 (36599c00 hex)

*  when using a static ip address (serverip and ipaddr must be set
   additionally).

   .. code-block::
      :substitutions:

      u-boot=> tftp ${loadaddr} |yocto-imagename|-|yocto-machinename|.wic
      Using ethernet@30be0000 device
      TFTP from server 192.168.3.10; our IP address is 192.168.3.11
      Filename '|yocto-imagename|-|yocto-machinename|.wic'.
      Load address: 0x40480000
      Loading: ######################################
               ######################################
               ######################################
               ...
               ...
               ...
               ######################################
               #############
               11.2 MiB/s
      done
      Bytes transferred = 911842304 (36599c00 hex)

Write the image to the eMMC:

.. code-block::

   u-boot=> mmc dev 2
   switch to partitions #0, OK
   mmc2(part 0) is current device
   u-boot=> setexpr nblk ${filesize} / 0x200
   u-boot=> mmc write ${loadaddr} 0x0 ${nblk}

   MMC write: dev # 2, block # 0, count 1780942 ... 1780942 blocks written: OK

Flash eMMC via Network in Linux on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can update the eMMC from your target.

.. tip::

   A working network is necessary! |ref-setup-network-host|

Take a compressed or uncompressed image with accompanying block map on the host
and send it with ssh through the network to the eMMC of the target with a
one-line command:

.. code-block:: console
   :substitutions:

   target:~$ scp <USER>@192.168.3.10:/srv/tftp/|yocto-imagename|-|yocto-machinename|.wic.* /tmp && bmaptool copy /tmp/|yocto-imagename|-|yocto-machinename|.|yocto-imageext| /dev/mmcblk2

Flash eMMC via Network in Linux on Host
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is also possible to install the OS at eMMC from your Linux host. As before,
you need a complete image on your host.

.. tip::

   A working network is necessary! |ref-setup-network-host|

Show your available image files on the host:

.. code-block:: console
   :substitutions:

   host:~$ ls /srv/tftp
   |yocto-imagename|-|yocto-machinename|.wic
   |yocto-imagename|-|yocto-machinename|.wic.bmap

Send the image with the ``bmaptool`` command combined with ssh through the network
to the eMMC of your device:

.. code-block:: console
   :substitutions:

   host:~$ scp /srv/tftp/|yocto-imagename|-|yocto-machinename|.|yocto-imageext| root@192.168.3.11:/tmp && ssh root@192.168.3.11 "bmaptool copy /tmp/|yocto-imagename|-|yocto-machinename|.|yocto-imageext| /dev/mmcblk2"

Flash eMMC U-Boot image via Network from running U-Boot
.......................................................

Update the standalone U-Boot image imx-boot is also possible from U-Boot. This
can be used if the bootloader on eMMC is located in the eMMC user area.

.. tip::

   A working network is necessary! |ref-setup-network-host|

Load image over tftp into RAM and then write it to eMMC:

.. code-block::
   :substitutions:

   u-boot=> tftp ${loadaddr} imx-boot
   u-boot=> setexpr nblk ${filesize} / 0x200
   u-boot=> mmc dev 2
   u-boot=> mmc write ${loadaddr} |u-boot-mmc-flash-offset| ${nblk}

.. hint::
   The hexadecimal value represents the offset as a multiple of 512 byte
   blocks. See the `offset table <#offset-table>`__ for the correct value
   of the corresponding SoC.

Flash eMMC from USB stick
.........................

Flash eMMC from USB stick in U-Boot on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

   This step only works if the size of the image file is less than 1GB due to
   limited usage of RAM size in the Bootloader after enabling OPTEE.

These steps will show how to update the eMMC via a USB device. Configure the
|ref-bootswitch| to SD Card and insert an SD card. Power on the board and stop
in U-Boot prompt. Insert a USB device with the copied WIC image to the USB slot.

Load your image from the USB device to RAM:

.. code-block::

   u-boot=> usb start
   starting USB...
   USB0:   USB EHCI 1.00
   scanning bus 0 for devices... 2 USB Device(s) found
          scanning usb for storage devices... 1 Storage Device(s) found
   u-boot=> fatload usb 0:1 ${loadaddr} *.wic
   497444864 bytes read in 31577 ms (15 MiB/s)

Write the image to the eMMC:

.. code-block::

   u-boot=> mmc dev 2
   switch to partitions #0, OK
   mmc2(part 0) is current device
   u-boot=> setexpr nblk ${filesize} / 0x200
   u-boot=> mmc write ${loadaddr} 0x0 ${nblk}

   MMC write: dev # 2, block # 0, count 1024000 ... 1024000 blocks written: OK
   u-boot=> boot

Flash eMMC from USB in Linux
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These steps will show how to flash the eMMC on Linux with a USB stick. You only
need a complete image saved on the USB stick and a bootable WIC image. (e.g.
|yocto-imagename|-|yocto-machinename|.wic). Set the |ref-bootswitch| to SD Card.

*  Insert and mount the USB stick:

   .. code-block:: console

      [   60.458908] usb-storage 1-1.1:1.0: USB Mass Storage device detected
      [   60.467286] scsi host0: usb-storage 1-1.1:1.0
      [   61.504607] scsi 0:0:0:0: Direct-Access                               8.07 PQ: 0 ANSI: 2
      [   61.515283] sd 0:0:0:0: [sda] 3782656 512-byte logical blocks: (1.94 GB/1.80 GiB)
      [   61.523285] sd 0:0:0:0: [sda] Write Protect is off
      [   61.528509] sd 0:0:0:0: [sda] No Caching mode page found
      [   61.533889] sd 0:0:0:0: [sda] Assuming drive cache: write through
      [   61.665969]  sda: sda1
      [   61.672284] sd 0:0:0:0: [sda] Attached SCSI removable disk
      target:~$ mount /dev/sda1 /mnt

*  Now show your saved image files on the USB Stick:

   .. code-block:: console
      :substitutions:

      target:~$ ls /mnt
      |yocto-imagename|-|yocto-machinename|.wic
      |yocto-imagename|-|yocto-machinename|.wic.bmap

*  Write the image to the phyCORE-|soc| eMMC (MMC device 2 without partition):

   .. code-block:: console
      :substitutions:

      target:~$ bmaptool copy /mnt/|yocto-imagename|-|yocto-machinename|.|yocto-imageext| /dev/mmcblk2

*  After a complete write, your board can boot from eMMC.

   .. tip::

      Before this will work, you need to configure the |ref-bootswitch| to
      **eMMC**.

Flash eMMC from SD Card
.......................

Even if there is no network available, you can update the eMMC. For that, you
only need a ready-to-use image file (``*.wic``) located on the SD card.
Because the image file is quite large, you have to create a third partition.
To create a new partition or enlarge your SD card, see |ref-format-sd|.

Alternatively, flash a partup package to the SD card, as described in
|ref-getting-started|. This will ensure the full space of the SD card is used.

Flash eMMC from SD card in U-Boot on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

   This step only works if the size of the image file is less than 1GB due to
   limited usage of RAM size in the Bootloader after enabling OPTEE. If the
   image file is too large use the `Updating eMMC from SD card in
   Linux on Target` subsection.

*  Flash an SD card with a working image and create a third ext4 partition. Copy
   the WIC image (for example |yocto-imagename|.wic) to this
   partition.
*  Configure the |ref-bootswitch| to SD Card and insert the SD Card.
*  Power on the board and stop in U-Boot.
*  Load the image:

   .. code-block::
      :substitutions:

      u-boot=> ext4load mmc 1:3 ${loadaddr} |yocto-imagename|-|yocto-machinename|.wic
      reading
      911842304 bytes read in 39253 ms (22.2 MiB/s)

*  Switch the mmc dev to eMMC:

   .. code-block::

      u-boot=> mmc list
      FSL_SDHC: 1 (SD)
      FSL_SDHC: 2 (eMMC)
      u-boot=> mmc dev 2
      switch to partitions #0, OK
      mmc2(part 0) is current device

*  Flash your WIC image (for example |yocto-imagename|.wic)
   from the SD card to eMMC. This will partition the card and copy imx-boot,
   Image, dtb, dtbo, and root file system to eMMC.

   .. code-block::

      u-boot=> setexpr nblk ${filesize} / 0x200
      u-boot=> mmc write ${loadaddr} 0x0 ${nblk}

      MMC write: dev # 2, block # 0, count 1780942 ... 1780942 blocks written: OK

*  Power off the board and change the |ref-bootswitch| to eMMC.

Flash eMMC from SD card in Linux on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also flash the eMMC on Linux. You only need a partup package or WIC
image saved on the SD card.

*  Show your saved partup package or WIC image files on the SD card:

   .. code-block:: console
      :substitutions:

      target:~$ ls
      |yocto-imagename|-|yocto-machinename|.partup
      |yocto-imagename|-|yocto-machinename|.wic
      |yocto-imagename|-|yocto-machinename|.wic.bmap

*  Write the image to the phyCORE-|soc| eMMC (MMC device 2 **without**
   partition) using `partup`_:

   .. code-block:: console
      :substitutions:

      target:~$ partup install |yocto-imagename|-|yocto-machinename|.partup /dev/mmcblk2

   Flashing the partup package has the advantage of using the full capacity of
   the eMMC device, adjusting partitions accordingly.

   .. note::

      Alternatively, ``bmaptool`` may be used instead:

      .. code-block:: console
         :substitutions:

         target:~$ bmaptool copy |yocto-imagename|-|yocto-machinename|.|yocto-imageext| /dev/mmcblk2

      Keep in mind that the root partition does not make use of the full space when
      flashing with ``bmaptool``.

*  After a complete write, your board can boot from eMMC.

   .. warning::

      Before this will work, you need to configure the |ref-bootswitch| to eMMC.

Flash SPI NOR Flash
-------------------

The |som| modules are optionally equipped with SPI NOR Flash. To boot from SPI
Flash, set |ref-bootswitch| to **SPI NOR**. The SPI Flash is usually quite small.
The phyBOARD-Pollux-i.MX8MP kit only has 32MB SPI NOR flash populated. Only the
bootloader and the environment can be stored. The kernel, device tree, and file
system are taken from eMMC by default.

The SPI NOR flash partition table is defined in the U-Boot environment. It can
be printed with:

.. code-block::

   u-boot=> printenv mtdparts
   mtdparts=30bb0000.spi:3840k(u-boot),128k(env),128k(env:redund),-(none)

Flash SPI NOR Flash from Network
................................

The SPI NOR can contain the bootloader and environment to boot from. The arm64
kernel can not decompress itself, the image size extends the SPI NOR flash
populated on the phyCORE-|soc|.

.. tip::

   A working network is necessary! |ref-setup-network-host|

Flash SPI NOR from Network in U-Boot on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similar to updating the eMMC over a network, be sure to set up the development
host correctly. The IP needs to be set to 192.168.3.10, the netmask to
255.255.255.0, and a TFTP server needs to be available. Before reading and
writing is possible, the SPI NOR flash needs to be probed:

.. code-block::

   u-boot=> sf probe
   SF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB

*  A specially formatted U-Boot image for the SPI NOR flash is used. Ensure you
   use the correct image file. Load the image over tftp, erase and write the
   bootloader to the flash:

   .. code-block::
      :substitutions:

      u-boot=> tftp ${loadaddr} imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi
      u-boot=> sf update ${loadaddr} 0 ${filesize}
      device 0 offset 0x0, size 0x1c0b20
      1641248 bytes written, 196608 bytes skipped in 4.768s, speed 394459 B/s

*  Erase the environment partition as well. This way, the environment can be
   written after booting from SPI NOR flash:

   .. code-block::

      u-boot=> sf erase 0x400000 0x100000

Flash SPI NOR from Network in kernel on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*  Copy the image from the host to the target:

   .. code-block:: console
      :substitutions:

      host:~$ scp imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi root@192.168.3.11:/root

*  Find the number of blocks to erase of the U-boot partition:

   .. code-block:: console

      target:~$ mtdinfo /dev/mtd0
      mtd0
      Name:                           u-boot
      Type:                           nor
      Eraseblock size:                65536 bytes, 64.0 KiB
      Amount of eraseblocks:          60 (3932160 bytes, 3.7 MiB)
      Minimum input/output unit size: 1 byte
      Sub-page size:                  1 byte
      Character device major/minor:   90:0
      Bad blocks are allowed:         false
      Device is writable:             true

*  Erase the U-Boot partition and flash it:

   .. code-block:: console
      :substitutions:

      target:~$ flash_erase /dev/mtd0 0x0 60
      target:~$ flashcp imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi /dev/mtd0

Flash SPI NOR Flash from SD Card
................................

The bootloader on SPI NOR flash can be also flashed with SD Card.

Flash SPI NOR from SD Card in U-Boot on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*  Copy the SPI NOR flash U-boot image
   imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi to the first partition
   on the SD Card.

*  Before reading and writing are possible, the SPI-NOR flash
   needs to be probed:

   .. code-block::

      u-boot=> sf probe
      SF: Detected n25q256ax1 with page size 256 Bytes, erase size 64 KiB, total 32 MiB

*  A specially formatted U-boot image for the SPI NOR flash is used. Ensure you
   use the correct image file. Load the image from the SD Card, erase and write
   the bootloader to the flash:

   .. code-block::
      :substitutions:

      u-boot=> mmc dev 1
      u-boot=> fatload mmc 1:1 ${loadaddr} imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi
      u-boot=> sf update ${loadaddr} 0 ${filesize}

*  Erase the environment partition as well. This way, the environment can be
   written after booting from SPI NOR flash:

   .. code-block::

      u-boot=> sf erase 0x400000 0x100000

Flash SPI NOR from SD Card in kernel on Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*  Copy the SPI NOR flash U-boot image
   imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi to the first partition
   on the SD Card.

*  Mount the SD Card:

   .. code-block:: console
      :substitutions:

      target:~$ mount /dev/mmcblk1p1 /mnt

*  Find the number of blocks to erase of the U-Boot partition:

   .. code-block:: console

      target:~$ mtdinfo /dev/mtd0
      mtd0
      Name:                           u-boot
      Type:                           nor
      Eraseblock size:                65536 bytes, 64.0 KiB
      Amount of eraseblocks:          60 (3932160 bytes, 3.7 MiB)
      Minimum input/output unit size: 1 byte
      Sub-page size:                  1 byte
      Character device major/minor:   90:0
      Bad blocks are allowed:         false
      Device is writable:             true

*  Erase the u-boot partition and flash it:

   .. code-block:: console
      :substitutions:

      target:~$ flash_erase /dev/mtd0 0x0 60
      target:~$ flashcp /mnt/imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi /dev/mtd0

RAUC
----

The RAUC (Robust Auto-Update Controller) mechanism support has been added to
meta-ampliphy. It controls the procedure of updating a device with new firmware.
This includes updating the Linux kernel, Device Tree, and root filesystem.
PHYTEC has written an online manual on how we have intergraded RAUC into our
BSPs: |rauc-manual|_.

.. +---------------------------------------------------------------------------+
.. DEVELOPMENT
.. +---------------------------------------------------------------------------+

.. _imx8mp-pd23.1.0-development:

Development
===========

.. include:: /bsp/imx-common/development/host_network_setup.rsti
.. include:: /bsp/imx-common/development/netboot.rsti

Working with UUU-Tool
---------------------

The Universal Update Utility Tool (UUU-Tool) from NXP is a software to execute
on the host to load and run the bootloader on the board through SDP (Serial
Download Protocol). For detailed information visit
https://github.com/nxp-imx/mfgtools or download the `Official UUU-tool
documentation <https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/imx-processors/140261/1/UUU.pdf>`_.

Host preparations for UUU-Tool Usage
....................................

*  Follow the instructions from https://github.com/nxp-imx/mfgtools#linux.

*  If you built UUU from source, add it to ``PATH``:

   This BASH command adds UUU only temporarily to ``PATH``. To add it permanently, add this line to
   ``~/.bashrc``.

   .. code-block:: console

      export PATH=~/mfgtools/uuu/:"$PATH"

*  Set udev rules (documented in ``uuu -udev``):

   .. code-block:: console

      host:~$ sudo sh -c "uuu -udev >> /etc/udev/rules.d/70-uuu.rules"
      host:~$ sudo udevadm control --reload

Get Images
..........

Download imx-boot from our server or get it from your Yocto build directory at
build/deploy/images/|yocto-machinename|/. For flashing a wic image to eMMC,
you will also need |yocto-imagename|-|yocto-machinename|.wic.

Prepare Target
..............

Set the |ref-bootswitch| to **USB Serial Download**. Also, connect USB port
|ref-usb-otg| to your host.

Starting bootloader via UUU-Tool
................................

Execute and power up the board:

.. code-block:: console

   host:~$ sudo uuu -b spl imx-boot

You can see the bootlog on the console via |ref-debugusbconnector|, as usual.

.. note::
   The default boot command when booting with UUU-Tool is set to fastboot. If
   you want to change this, please adjust the environment variable bootcmd_mfg
   in U-boot prompt with setenv bootcmd_mfg. Please note, when booting with
   UUU-tool the default environment is loaded. Saveenv has no effect. If you
   want to change the boot command permanently for UUU-boot, you need to change
   this in U-Boot code.

Flashing U-boot Image to eMMC via UUU-Tool
...........................................

.. warning::

   UUU flashes U-boot into eMMC BOOT (hardware) boot partitions, and it sets
   the BOOT_PARTITION_ENABLE in the eMMC! This is a problem since we want the
   bootloader to reside in the eMMC USER partition. Flashing next U-Boot version
   .wic image and not disabling BOOT_PARTITION_ENABLE bit will result in device
   always using U-boot saved in BOOT partitions. To fix this in U-Boot:

   .. code-block:: console
      :substitutions:

      u-boot=> mmc partconf |u-boot-emmc-devno| 0 0 0
      u-boot=> mmc partconf |u-boot-emmc-devno|
      EXT_CSD[179], PARTITION_CONFIG:
      BOOT_ACK: 0x0
      BOOT_PARTITION_ENABLE: 0x0
      PARTITION_ACCESS: 0x0

   or check |ref-disable-emmc-part| from Linux.

   This way the bootloader is still flashed to eMMC BOOT partitions but it is
   not used!

   When using **partup** tool and ``.partup`` package for eMMC flashing this is
   done by default, which makes partup again superior flash option.

Execute and power up the board:

.. code-block:: console

   host:~$ sudo uuu -b emmc imx-boot

Flashing wic Image to eMMC via UUU-Tool
...........................................

Execute and power up the board:

.. code-block:: console
   :substitutions:

   host:~$ sudo uuu -b emmc_all imx-boot |yocto-imagename|-|yocto-machinename|.wic

.. include:: /bsp/imx-common/development/standalone_build_preface.rsti

.. _imx8mp-pd23.1.0-development-build-uboot:
.. include:: /bsp/imx-common/development/standalone_build_u-boot_binman.rsti

Starting with PD23.1.0 release, the phyCORE-|soc| SoMs with revision 1549.3 and
newer also support 2GHz RAM timings. These will be enabled for supported boards
automatically, but they can also be enabled or disabled manually.

Edit the file configs/phycore-|kernel-socname|\_defconfig.
The fixed RAM size with 2GHz timings will be used:

.. code-block:: kconfig

   CONFIG_TARGET_PHYCORE_IMX8MP=y
   CONFIG_PHYCORE_IMX8MP_RAM_SIZE_FIX=y
   # CONFIG_PHYCORE_IMX8MP_RAM_SIZE_1GB=y
   # CONFIG_PHYCORE_IMX8MP_RAM_SIZE_2GB=y
   # CONFIG_PHYCORE_IMX8MP_RAM_SIZE_4GB=y
   CONFIG_PHYCORE_IMX8MP_USE_2GHZ_RAM_TIMINGS=y

Choose the correct RAM size as populated on the board and uncomment the line
for this ram size. When not specifying the
``CONFIG_PHYCORE_IMX8MP_USE_2GHZ_RAM_TIMINGS`` option, the 1.5GHz timings will
be chosen by default. After saving the changes, follow the remaining steps from
|ref-build-uboot|.

.. include:: /bsp/imx-common/development/standalone_build_kernel.rsti

.. include:: /bsp/imx8/development/development_manifests.rsti

.. include:: /bsp/imx8/development/upstream_manifest.rsti

.. _imx8mp-pd23.1.0-format-sd:

.. include:: /bsp/imx-common/development/format_sd-card.rsti

.. +---------------------------------------------------------------------------+
.. DEVICE TREE
.. +---------------------------------------------------------------------------+

.. _imx8mp-pd23.1.0-device-tree:
.. include:: /bsp/device-tree.rsti

::

   imx8mp-isi-csi1.dtbo
   imx8mp-isi-csi2.dtbo
   imx8mp-isp-csi1.dtbo
   imx8mp-isp-csi2.dtbo
   imx8mp-phyboard-pollux-peb-av-010.dtbo
   imx8mp-phyboard-pollux-peb-av-012.dtbo
   imx8mp-phyboard-pollux-peb-wlbt-05.dtbo
   imx8mp-phycore-no-eth.dtbo
   imx8mp-phycore-no-rtc.dtbo
   imx8mp-phycore-no-spiflash.dtbo
   imx8mp-phycore-rpmsg.dtbo
   imx8mp-vm016-csi1.dtbo
   imx8mp-vm016-csi1-fpdlink.dtbo
   imx8mp-vm016-csi2.dtbo
   imx8mp-vm016-csi2-fpdlink.dtbo
   imx8mp-vm017-csi1.dtbo
   imx8mp-vm017-csi1-fpdlink.dtbo
   imx8mp-vm017-csi2.dtbo
   imx8mp-vm017-csi2-fpdlink.dtbo

.. _imx8mp-pd23.1.0-ubootexternalenv:
.. include:: ../dt-overlays.rsti

.. +---------------------------------------------------------------------------+
.. ACCESSING PERIPHERALS
.. +---------------------------------------------------------------------------+

.. include:: /bsp/peripherals/introduction.rsti

.. include:: /bsp/imx-common/peripherals/pin-muxing.rsti

The following is an example of the pin muxing of the UART1 device in
|dt-carrierboard|.dts:

.. code-block::

   pinctrl_uart1: uart1grp {
           fsl,pins = <
                   MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX     0x140
                   MX8MP_IOMUXC_UART1_TXD_UART1_DCE_TX     0x140
           >;
   };

The first part of the string MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX names the pad
(in this example UART1_RXD). The second part of the string (UART1_DCE_RX) is the
desired muxing option for this pad. The pad setting value (hex value on the
right) defines different modes of the pad, for example, if internal pull
resistors are activated or not. In this case, the internal resistors are
disabled.

The device tree representation for UART1 pinmuxing:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n536`

RS232/RS485
-----------

The phyCORE-|soc| supports up to 4 UART units. On the |sbc|, TTL level signals
of UART1 (the standard console) and UART4 are routed to Silicon Labs CP2105 UART
to USB converter expansion. This USB is brought out at Micro-USB connector X1.
UART3 is at X6 (Expansion Connector) at TTL level. UART2 is connected to a
multi-protocol transceiver for RS-232 and RS-485, available at pin header
connector |ref-serial| at the RS-232 level, or at the RS-485 level. The
configuration of the multi-protocol transceiver is done by jumpers |ref-jp3| and
|ref-jp4| on the baseboard. For more information about the correct setup please
refer to the phyCORE-|soc|/|sbc| Hardware Manual section UARTs.

We use the same device tree node for RS-232 and RS-485. RS-485 mode can be
enabled with ioctl TIOCSRS485. Also, full-duplex support is also configured
using ioctls. Have a look at our small example application rs485test, which is
also included in the BSP. The jumpers |ref-jp3| and |ref-jp4| need to be set
correctly.

.. include:: /bsp/peripherals/rs232.rsti
.. include:: /bsp/peripherals/rs485.rsti

The device tree representation for RS232 and RS485:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n341`

.. _imx8mp-pd23.1.0-network:

Network
-------

|sbc|-|soc| provides two ethernet interfaces. A gigabit Ethernet is provided by our
module and board.

.. warning::

   The naming convention of the Ethernet interfaces in the hardware (ethernet0
   and ethernet1) do not align with the network interfaces (eth0 and eth1) in
   Linux. So, be aware of these differences:

   | ethernet1 = eth0
   | ethernet0 = eth1

.. include:: /bsp/imx-common/peripherals/network.rsti

.. include:: wireless-network.rsti

.. include:: ../../peripherals/wireless-network.rsti

.. note::

   If the connection fails with the error message: "Failed to connect:
   org.bluez.Error.Failed" try restarting PulseAudio with:

   .. code-block:: console

      target:~$ pulseaudio --start

.. include:: /bsp/imx-common/peripherals/sd-card.rsti

DT configuration for the MMC (SD card slot) interface can be found here:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n380`

DT configuration for the eMMC interface can be found here:
:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n223`

.. include:: /bsp/peripherals/emmc.rsti

.. include:: /bsp/imx-common/emmc.rsti

.. include:: ../peripherals/spi-master.rsti

The definition of the SPI master node in the device tree can be found here:

:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n76`

GPIOs
-----

The |sbc| has a set of pins especially dedicated to user I/Os. Those pins are
connected directly to |soc| pins and are muxed as GPIOs. They are directly
usable in Linux userspace. The processor has organized its GPIOs into five banks
of 32 GPIOs each (GPIO1 – GPIO5)
GPIOs. gpiochip0, gpiochip32, gpiochip64, gpiochip96, and gpiochip128 are
the sysfs representation of these internal |soc| GPIO banks GPIO1 – GPIO5.

The GPIOs are identified as GPIO<X>_<Y> (e.g. GPIO5_07). <X> identifies the GPIO
bank and counts from 1 to 5, while <Y> stands for the GPIO within the bank. <Y>
is being counted from 0 to 31 (32 GPIOs on each bank).

By contrast, the Linux kernel uses a single integer to enumerate all available
GPIOs in the system. The formula to calculate the right number is:

.. code-block::

   Linux GPIO number: <N> = (<X> - 1) * 32 + <Y>

Accessing GPIOs from userspace will be done using the libgpiod. It provides a
library and tools for interacting with the Linux GPIO character device. Examples
of some usages of various tools:

*  Detecting the gpiochips on the chip:

   .. code-block:: console

      target:~$ gpiodetect
      gpiochip0 [30200000.gpio] (32 lines)
      gpiochip1 [30210000.gpio] (32 lines)
      gpiochip2 [30220000.gpio] (32 lines)
      gpiochip3 [30230000.gpio] (32 lines)
      gpiochip4 [30240000.gpio] (32 lines)

*  Show detailed information about the gpiochips. Like their names, consumers,
   direction, active state, and additional flags:

   .. code-block:: console

      target:~$ gpioinfo gpiochip0

*  Read the value of a GPIO (e.g GPIO 20 from chip0):

   .. code-block:: console

      target:~$ gpioget gpiochip0 20

*  Set the value of GPIO 20 on chip0 to 0 and exit tool:

   .. code-block:: console

      target:~$ gpioset --mode=exit gpiochip0 20=0

*  Help text of gpioset shows possible options:

   .. code-block:: console

      target:~$ gpioset --help
      Usage: gpioset [OPTIONS] <chip name/number> <offset1>=<value1> <offset2>=<value2> ...
      Set GPIO line values of a GPIO chip

      Options:
        -h, --help:           display this message and exit
        -v, --version:        display the version and exit
        -l, --active-low:     set the line active state to low
        -m, --mode=[exit|wait|time|signal] (defaults to 'exit'):
                      tell the program what to do after setting values
        -s, --sec=SEC:        specify the number of seconds to wait (only valid for --mode=time)
        -u, --usec=USEC:      specify the number of microseconds to wait (only valid for --mode=time)
        -b, --background:     after setting values: detach from the controlling terminal

      Modes:
        exit:         set values and exit immediately
        wait:         set values and wait for user to press ENTER
        time:         set values and sleep for a specified amount of time
        signal:       set values and wait for SIGINT or SIGTERM

      Note: the state of a GPIO line controlled over the character device reverts to default
      when the last process referencing the file descriptor representing the device file exits.
      This means that it's wrong to run gpioset, have it exit and expect the line to continue
      being driven high or low. It may happen if given pin is floating but it must be interpreted
      as undefined behavior.


.. warning::

   Some of the user IOs are used for special functions. Before using a user IO,
   refer to the schematic or the hardware manual of your board to ensure that it
   is not already in use.

.. include:: ../peripherals/gpios.rsti
   :start-after: .. gpios-via-sysfs-marker

.. include:: /bsp/peripherals/leds.rsti

Device tree configuration for the User I/O configuration can be found here:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n229`

.. include:: /bsp/imx-common/peripherals/i2c-bus.rsti

General I²C1 bus configuration (e.g. |dt-som|.dtsi):
:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n110`

General I²C2 bus configuration (e.g. |dt-carrierboard|.dts)
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n212`


EEPROM
------

On the |som| there is an i2c EEPROM flash populated. It has two addresses. The
main EEPROM space (bus: I2C-0 address: 0x51) and the ID-page (bus: I2C-0
address: 0x59) can be accessed via the sysfs interface in Linux. The first
256 bytes of the main EEPROM and the ID-page are used for board detection and
must not be overwritten. Overwriting reserved spaces will result in boot issue.

.. include:: ../peripherals/eeprom.rsti

Rescue EEPROM Data
..................

The hardware introspection data is pre-written on both EEPROM data spaces. If
you have accidentally deleted or overwritten the normal area, you can copy the
hardware introspection from the ID area to the normal area.

.. code-block:: console

   target:~$ dd if=/sys/class/i2c-dev/i2c-0/device/0-0059/eeprom of=/sys/class/i2c-dev/i2c-0/device/0-0051/eeprom bs=1

.. note::

   If you deleted both EEPROM spaces, please contact our support!

DT representation, e.g. in phyCORE-|soc| file imx8mp-phycore-som.dtsi can be
found in our PHYTEC git:
:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n199`

.. include:: /bsp/peripherals/rtc.rsti
   :end-before: .. rtc_parameter_start_label

RTC Parameters
..............

RTCs have a few abilities which can be read/set with the help of ``hwclock``
tool.

*  We can check RTC supported features with:

   .. code-block:: console

      target:~$ hwclock --param-get features
      The RTC parameter 0x0 is set to 0x11.

   What this value means is encoded in kernel, each set bit translates to:

   .. code-block::

      #define RTC_FEATURE_ALARM              0
      #define RTC_FEATURE_ALARM_RES_MINUTE   1
      #define RTC_FEATURE_NEED_WEEK_DAY      2
      #define RTC_FEATURE_ALARM_RES_2S       3
      #define RTC_FEATURE_UPDATE_INTERRUPT   4
      #define RTC_FEATURE_CORRECTION         5
      #define RTC_FEATURE_BACKUP_SWITCH_MODE 6
      #define RTC_FEATURE_CNT                7

*  We can check RTC BSM (Backup Switchover Mode) with:

   .. code-block:: console

      target:~$ hwclock --param-get bsm
      The RTC parameter 0x2 is set to 0x1.

*  We can set RTC BSM with:

   .. code-block:: console

      target:~$ hwclock --param-set bsm=0x2
      The RTC parameter 0x2 will be set to 0x2.

   What BSM values mean translates to these values:

   .. code-block::

      #define RTC_BSM_DISABLED   0
      #define RTC_BSM_DIRECT     1
      #define RTC_BSM_LEVEL      2
      #define RTC_BSM_STANDBY    3

   .. tip::
      You should set BSM mode to DSM or LSM for RTC to switch to backup power
      source when the initial power source is not available. Check **RV-3028** RTC
      datasheet to read what LSM (Level Switching Mode) and DSM (Direct Switching
      Mode) actually mean.

DT representation for I²C RTCs:
:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n207`

USB Host Controller
-------------------

The USB controller of the |soc| SoC provides a low-cost connectivity solution
for numerous consumer portable devices by providing a mechanism for data
transfer between USB devices with a line/bus speed of up to 4 Gbit/s (SuperSpeed
'SS'). The USB subsystem has two independent USB controller cores. Both cores
are capable of acting as a USB peripheral device or a USB host. Each is
connected to a USB 3.0 PHY.

.. include:: /bsp/peripherals/usb-host.rsti

DT representation for USB Host:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n351`

CAN FD
------

The |sbc| two flexCAN interfaces supporting CAN FD. They are supported by the
Linux standard CAN framework which builds upon then the Linux network layer.
Using this framework, the CAN interfaces behave like an ordinary Linux network
device, with some additional features special to CAN. More information can be
found in the Linux Kernel
documentation: https://www.kernel.org/doc/html/latest/networking/can.html

.. include:: ../peripherals/canfd.rsti

Device Tree CAN configuration of |dt-carrierboard|.dts:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n175`

.. include:: /bsp/peripherals/pcie.rsti

Device Tree PCIe configuration of |dt-carrierboard|.dts:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n287`

Audio
-----

Playback devices supported for |sbc| are HDMI and the TI TLV320AIC3007 audio
codec on the PEB-AV-10 connector. On the AV-Connector there is a 3.5mm headset
jack with OMTP-standard and an 8-pin header. The 8-pin header contains a mono
speaker, headphones, and line in signals.

.. note::

   Using the PEB-AV-10 connector for display output along HDMI as audio output
   is not supported. The audio output device must match the video output device.

.. include:: /bsp/peripherals/audio.rsti

Device Tree Audio configuration:
:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n58`

.. include:: /bsp/peripherals/video.rsti

.. include:: display.rsti

.. include:: /bsp/qt6.rsti

.. include:: /bsp/imx-common/peripherals/display.rsti

Device tree description of LVDS-1 and HDMI can be found here:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n264`
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n191`

The device tree of LVDS-0 on PEB-AV-10 can be found here:
:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n133`

.. include:: ../peripherals/pm.rsti

.. include:: ../peripherals/tm.rsti

The device tree description of GPIO Fan can be found here:
:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n33`

.. include:: /bsp/peripherals/watchdog.rsti

.. include:: ../peripherals/snvs-power-key.rsti

.. include:: ../peripherals/npu.rsti

.. include:: ../peripherals/isp.rsti

.. include:: ../peripherals/ocotp-ctrl.rsti

.. +---------------------------------------------------------------------------+
.. i.MX 8M Plus M7 Core
.. +---------------------------------------------------------------------------+

.. include:: ../mcu.rsti

.. +---------------------------------------------------------------------------+
.. BSP EXTENSIONS
.. +---------------------------------------------------------------------------+

.. include:: /bsp/bsp-extensions.rsti
