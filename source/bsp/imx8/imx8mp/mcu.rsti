|soc| |mcore|
=============

In addition to the Cortex-A53 cores, there is a Cortex-|mcore| as MCU integrated
into the |soc| SoC. Our Yocto-Linux-BSP runs on the A53-Cores and the |mcore|
can be used as a secondary core for additional tasks using bare-metal or RTOS
firmware. Both cores have access to the same peripherals and thus peripheral
usage needs to be limited either in the |mcore|'s firmware or the devicetree for
the Linux operating system. This section describes how to build firmware
examples and how to run them on
|sbc|.

Getting the Firmware Examples
-----------------------------

The firmware can be built using the NXP MCUxpresso SDK with a compatible
compiler toolchain using command-line tools.

Getting the Sources
...................

The SDK and the examples for the |soc| are not yet available on Github and can
only be obtained from NXP's web page: https://mcuxpresso.nxp.com/

1. Register and log into the SDK Builder
2. Select Board / Processor → Processors → i.MX → 8M Plus Quad → MIMX8ML8xxxLZ
3. Select SDK version 2.11.1
4. On the SDK Builder page select Linux Host and GCC ARM Embedded toolchain
5. Select the optional components (as of SDK v2.11.1) multicore, CMSIS DSP
   Library, FreeRTOS, and download the SDK archive

The |mcore| examples ported for |sbc| can be obtained in an additional
repository, which can be cloned into the SDK once it is extracted::

   $ tar -xf SDK_2_11_1_MIMX8ML8xxxLZ.tar.gz
   $ git clone https://git.phytec.de/phytec-mcux-boards --branch SDK_2.11.1-phy

.. hint::

   The older SDK version 2.9.0 is also available, replace 2.11.1 with 2.9.0 to
   use it.

phytec-mcux-boards contains all examples ported and tested for |sbc| with the
current version 2.11.1. of the NXP SDK. To build the firmware, a compiler
toolchain and make/cmake are required. The GNU Arm Embedded Toolchain might be
available in your distribution's repositories, e.g. type for Ubuntu 20.04::

   $ sudo apt install gcc-arm-none-eabi binutils-arm-none-eabi make cmake
   $ export ARMGCC_DIR=/usr

The toolchain can also be obtained directly from https://developer.arm.com/.
After the archive has been extracted, the  ARMGCC_DIR has to be added to the
environment, e.g. for the toolchain 10-2020-q4-major release located in the home
directory::

   $ export ARMGCC_DIR=~/gcc-arm-none-eabi-10-2020-q4-major

Building the Firmware
.....................

The scripts to build the firmware are located in
<sdk-directory>/phytec-mcux-boards/phyboard-pollux/<example_category>/<example>/armgcc.
There are scripts for each location the firmware is supposed to run, e.g. ::

   $ ./build_release.sh

to build the firmware for the |mcore|'s TCM. The output will be placed under
release/ in the armgcc directory. .bin files and can be run in U-Boot and .elf
files within Linux.

To build the firmware for the DRAM, run the script build_ddr_release.
The script of the firmware that is supposed to run, e.g. ::

   $ ./build_ddr_release.sh

The output will be placed under ddr_release/ in the armgcc
directory. .bin files and can be run in U-Boot and .elf
files within Linux.

Running |mcore| Examples
------------------------

To receive debug messages start your favorite terminal software (e.g. Minicom,
Tio, or Tera Term) on your host PC and configure it for 115200 baud, 8 data
bits, no parity, and 1 stop bit (8n1) with no handshake.

Once a micro-USB cable is connected to the USB-debug port on the |sbc|, two
ttyUSB devices are registered. One prints messages from A53-Core's debug UART
and the other one from the |mcore|'s debug UART.

Running Examples from U-Boot
............................

To load firmware using the bootloader U-Boot, the bootaux command can be used:

1. Prepare an SD Card with our Yocto-BSP
2. Copy the generated .bin file to the SD Cards first partition
3. Stop the autoboot by pressing any key
4. Type the command depending on the type of firmware:

For firmware built to run in the |mcore|'s TCM::

   u-boot=> fatload mmc 1:1 0x48000000 firmware.bin;cp.b 0x48000000 0x7e0000 20000;
   u-boot=> bootaux 0x7e0000
   ## Starting auxiliary core stack = 0x20020000, pc = 0x000004CD...

For firmware built to run in the DRAM::

   u-boot=> fatload mmc 1:1 0x80000000 firmware.bin
   u-boot=> dcache flush
   u-boot=> bootaux 0x80000000
   ## Starting auxiliary core stack = 0x80400000, pc = 0x80000539...

The program's output should appear on the |mcore|'s debug UART.

Running Examples from Linux using Remoteproc
............................................

Remoteproc is a module that allows you to control the |mcore| from Linux
during runtime. Firmware built for TCM can be loaded and the execution started
or stopped. To use Remoteproc a devicetree overlay needs to be set:

Edit the bootenv.txt file located in the /boot directory on the target by
adding imx8mp-phycore-rpmsg.dtbo::

   overlays=imx8mp-phyboard-pollux-peb-av-010.dtbo imx8mp-phycore-rpmsg.dtbo

Restart the target and execute in U-Boot::

   u-boot=> run prepare_mcore

Firmware .elf files for the M7 core can be found under /lib/firmware.
To load the firmware, type::

   target$ echo /lib/firmware/<firmware>.elf > /sys/class/remoteproc/remoteproc0/firmware
   target$ echo start > /sys/class/remoteproc/remoteproc0/state

To load a different firmware, the |mcore| needs to be stopped::

   target$ echo stop > /sys/class/remoteproc/remoteproc0/state

Debugging Using J-Link
......................

The Segger software can be obtained from
https://www.segger.com/downloads/jlink/. As of version V7.20a of the Segger
software, accessing the |soc|' |mcore| requires additional configuration files
to be copied into the J-Link software directory: NXP J-Link files for |soc|

Together with the J-Link, GDB Server can be used for running and debugging the
software.  On the |sbc|, the JTAG-Pins are accessible via the X6 Expansion
Connector. The simplest way is to use a PEB-EVAL-01 board that has the JTAG-Pins
reachable with a pin header on the top. ::

   $ sudo apt install gdb gdb-multiarch

To start the J-Link software, type::

   $ JLinkGDBServer -if JTAG -device MIMX8ML8_M7
   ...
   Connected to target
   Waiting for GDB connection...

To start GDB with a firmware example in another window, type::

   $ gdb-multiarch firmware.elf
   ...
   (gdb) target remote localhost:2331
   (gdb) monitor reset
   Resetting target
   (gdb) load
   ...
   (gdb) monitor go
