# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, PHYTEC Messtechnik GmbH
# This file is distributed under the same license as the PHYTEC BSP Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PHYTEC BSP Documentation imx8mp-pd24.1.0-nxp-48-g8498718\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 11:24+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

msgid "Documentation in pdf format: `Download <static-pdf-dl_>`_"
msgstr ""

msgid "This manual is a draft version and is currently **work in progress**. It will undergo significant changes over time."
msgstr ""

msgid "We value your feedback, questions, and suggestions and encourage you to open an issue or pull request in the linked repository to get in contact."
msgstr ""

msgid "Coprocessor Application Manual"
msgstr ""

msgid "Document Title"
msgstr ""

msgid "Document Type"
msgstr ""

msgid "Generic Application Guide"
msgstr ""

msgid "Release Date"
msgstr ""

msgid "XXXX/XX/XX"
msgstr ""

msgid "This manual applies to all Phytec releases from kernel version x."
msgstr ""

msgid "Introduction"
msgstr ""

msgid "Most modern SoCs include one or more coprocessors beside an application processor. In most cases the application processor runs Linux, while the coprocessor may run an RTOS. This manual goes into detail how to utilize the coprocessor efficiently for projects."
msgstr ""

msgid "The manual explains generic principles and applies those principles in examples for a specific platform and tools. It gives an introduction into coprocessor software stacks and RTOS like Zephyr, MCUXpresso and OpenAMP"
msgstr ""

msgid "For now this manual is focused on the NXP i.MX platform, but an attempt is made to keep the manual as generic as possible."
msgstr ""

msgid "Internal vs. External Coprocessor"
msgstr ""

msgid "A coprocessor can be internal or external (Of the application processors SoC). Both have their advantages and disadvantages. Advantages on internal coprocessors are for example a more simple firmware update management, a more efficient communication between the coprocessor and the application processor and a probably more inexpensive PCB design. External coprocessors have, for example, the advantages of more interfaces in addition to the ones of the application processor, and they are starting up directly, not depending on the application processor."
msgstr ""

msgid "This manual focuses on internal coprocessors of the PHYTEC SoMs."
msgstr ""

msgid "Use Cases"
msgstr ""

msgid "There are several use cases for coprocessors in embedded systems. Almost every time-critical task that cannot be handled by the application processor can be offloaded to a coprocessor."
msgstr ""

msgid "Here are some more explicit use-case examples to give an idea of the possibilities:"
msgstr ""

msgid "Energy Constrained Applications"
msgstr ""

msgid "For energy constrained applications, it may be beneficial to reduce the active time of the entire SoC to conserve power. In such cases, the application processor can be put into sleep mode while the coprocessor remains active to, for example, monitor I2C communication and wake up the application processor upon receiving a specific command."
msgstr ""

msgid "Time-Critical Communication"
msgstr ""

msgid "Some protocols may require sending or receiving data in real-time. If there is no hardware IP-core that is capable of handling the desired protocol, the coprocessor could help out to support it through building it in software."
msgstr ""

msgid "Sensors and Real-Time"
msgstr ""

msgid "Some applications may require a sensor to be read in a time-critical manner (e.g. an accelerometer) to detect small value changes in a short time frame. This can be done by a coprocessor to ensure that the sensor is read at the right time. The data can be buffered and fed to the application processor if it has time to process the data."
msgstr ""

msgid "Interface Virtualization"
msgstr ""

msgid "On SoCs like the i.MX9 series there is the FLEXIO interface (compare RPi PIO, Microchip CLC). Received data on this interface needs to be processed in a time-critical manner because it is lacking a FIFO buffer. If serial data with higher speeds is received, the application processor may need to process too many interrupts. That could slow down other running applications. Another problem is the interrupt latency. The application processor could possibly lose data frames."
msgstr ""

msgid "The coprocessor can be used to read the data from the interface, buffer it and send it to the application processor when it has time to process it."
msgstr ""

msgid "Overview of Technologies"
msgstr ""

msgid "Real-Time Operating Systems (RTOS) and Development Frameworks"
msgstr ""

msgid "There are multiple RTOS and SDKs available that can be used on coprocessors."
msgstr ""

msgid "Zephyr"
msgstr ""

msgid "Zephyr is an Open Source and vendor neutral RTOS that is is governed by the Linux Foundation and supported by various companies and a large community. It is designed to be small and efficient and is suitable for a wide range of devices from simple embedded devices to complex SoCs. The key feature is the platform independence, which allows developing applications with a generic API that can run on multiple platforms without modification."
msgstr ""

msgid "It supports a wide range of SoCs and boards from various manufacturers based on different processor architectures. There is also support for a lot of different peripherals and interfaces, as well as a wide range of communication protocols. (e.g. TCP/IP stack, Bluetooth, CAN, USB, etc.)"
msgstr ""

msgid "Zephyr supports the coprocessor on multiple phyBOARDs, including the phyBOARD Pollux (i.MX8MP), Polis (i.MX8MM), Nash (i.MX93), Electra (AM64x) and Lyra (AM62x)."
msgstr ""

msgid "It should be mentioned, that not all hardware features are available in Zephyr yet. The support is constantly being expanded through NXP and the Zephyr community. Despite this PHYTEC recommends using Zephyr for new projects because of its many advantages."
msgstr ""

msgid "You can find more information about using Zephyr in the `Zephyr Documentation <https://docs.zephyrproject.org/latest/introduction/index.html>`_ website."
msgstr ""

msgid "Please reach out to us if there is any feature missing in Zephyr that you need for your project. We will try our best to get that feature implemented."
msgstr ""

msgid "MCUXpresso SDK (NXP)"
msgstr ""

msgid "The MCUX SDK is a software development kit for NXP microcontrollers and microprocessors. It provides a comprehensive set of peripheral drivers, middlewares and examples for all NXP Platforms. MCUX gives the possibility to use different RTOS like FreeRTOS, Azure RTOS or even using it BareMetal."
msgstr ""

msgid "If Zephyr is not suitable for your project (e.g. because of missing features), MCUX SDK is the alternative. You can use it either with the MCUX SDK or repository-managed via make and cpp."
msgstr ""

msgid "Here are some resources to get started with MCUX:"
msgstr ""

msgid "`MCUXpresso SDK <https://www.nxp.com/design/software/development-software/mcuxpresso-software-and-tools/mcuxpresso-software-development-kit-sdk:MCUXpresso-SDK>`_"
msgstr ""

msgid "`PHYTEC MCUX-SDK <https://github.com/phytec/mcux-sdk>`_"
msgstr ""

msgid "`MCUXpresso VS-Code IDE <https://www.nxp.com/design/design-center/training/TIP-GETTING-STARTED-WITH-MCUXPRESSO-FOR-VS-CODE>`_"
msgstr ""

msgid "`MCUXpresso IDE <https://www.nxp.com/design/software/development-software/mcuxpresso-software-and-tools/mcuxpresso-integrated-development-environment-ide:MCUXpresso-IDE>`_"
msgstr ""

msgid "Additional Software Stacks"
msgstr ""

msgid "OpenAMP"
msgstr ""

msgid "The `OpenAMP <http://openampproject.org>`_ Project \"seeks to standardize the interactions between operating environments in a heterogeneous embedded system through open source solutions for Asymmetric MultiProcessing (AMP).\""
msgstr ""

msgid "This introduction explains the main components and terms, the `OpenAMP documentation <https://openamp.readthedocs.io/en/latest/openamp/index.html>`_ goes into further detail. OpenAMP is available in Linux as well as in RTOS (e.g. Zephyr) and Vendor SDKs (e.g. NXP MCUX, TI SDK, STM32Cube)."
msgstr ""

msgid "In general, OpenAMP is a framework that allows communication between asymmetric processor cores inside a SoC via shared memory."
msgstr ""

msgid "A differentiation is made between a master core (mostly the application processor) and one or more remote cores (coprocessors). The master core has to load the firmware on the remote core, start it and prepare shared memory regions for communication."
msgstr ""

msgid "The OpenAMP framework consists of two main components:"
msgstr ""

msgid "remoteproc"
msgstr ""

msgid "The remoteproc framework is used to control the life cycle of a remote processor. It is responsible for loading the firmware, starting and stopping the remote processor and managing the resources of both cores. The `remoteproc documentation <https://docs.kernel.org/staging/remoteproc.html>`_ on Kernel.org goes into further technical details."
msgstr ""

msgid "RPMsg"
msgstr ""

msgid "RPMsg is a messaging protocol that is used to exchange messages between the master core and remote cores. It is built on top of VirtIO and Virtqueue and uses the shared memory regions prepared by remoteproc to exchange messages."
msgstr ""

msgid "The communication stack is consisting of several protocol layers, similar to the OSI model:"
msgstr ""

msgid "Transport Layer (3):"
msgstr ""

msgid "MAC Layer (2):"
msgstr ""

msgid "VirtIO, Virtqueue, Vring"
msgstr ""

msgid "Physical Layer (1):"
msgstr ""

msgid "Shared Memory, Inter-core Interrupts e.g. via Messaging Unit (MU)"
msgstr ""

msgid "Normally VirtIO is used to exchange messages between virtual machines in a hypervisor environment. In the context of OpenAMP, VirtIO is used to exchange messages between the master core and remote cores while being very efficient. The Virtqueue is underlying VirtIO and organizes the messages in a circular buffer. The Vring is the specific implementation of the buffer inside the Virtqueue."
msgstr ""

msgid "The `rpmsg documentation <https://docs.kernel.org/staging/rpmsg.html>`_ on Kernel.org goes into further technical details."
msgstr ""

msgid "Requirements"
msgstr ""

msgid "Shared Memory"
msgstr ""

msgid "To exchange messages between the cores, a shared memory region is required."
msgstr ""

msgid "Interrupts"
msgstr ""

msgid "Minimum set of one interrupt line per communicating core. This interrupt is often implemented in hardware blocks of the SoC, e.g. the \"Messaging Unit (MU)\" on the NXP i.MX8MP."
msgstr ""

msgid "Resource Table"
msgstr ""

msgid "The resource table is a data structure that describes the shared memory regions and the VirtIO devices that are used for communication between the cores. It is used by the remoteproc framework to prepare the shared memory regions and the VirtIO devices. Ensure that the resource table is correctly included in the firmware binary of the remote core. (e.g. in Zephyr use ``CONFIG_OPENAMP_RSC_TABLE=y``)"
msgstr ""

msgid "Protocol Buffers"
msgstr ""

msgid "Application Architectures"
msgstr ""

msgid "Typical Usage"
msgstr ""

msgid "Typical Application Architecture with OpenAMP (source: `OpenAMP Whitepaper <https://www.openampproject.org/docs/whitepapers/Introduction_to_OpenAMPlib_v1.1a.pdf>`_)"
msgstr ""

msgid "A typical application architecture when using OpenAMP is using two cores. One application processor (typically running Linux) while the coprocessor is processing time-critical tasks."
msgstr ""

msgid "VirtIO"
msgstr ""

msgid "RPmsg + Overlaying Protocol"
msgstr ""

msgid "Sometimes it can be necessary to use an overlaying protocol on top of RPMsg to exchange more complex data structures."
msgstr ""

msgid "This could be done with using a protocol like `Protocol Buffers <https://developers.google.com/protocol-buffers>`_ or `Flat Buffers <https://google.github.io/flatbuffers/>`_ to serialize and deserialize the data structures."
msgstr ""

msgid "Getting Started"
msgstr ""

msgid "There are multiple ways to get started with using a coprocessor."
msgstr ""

msgid "First of all you need to decide which RTOS you want to use."
msgstr ""

msgid "If you want to use Zephyr, you can use the `Zephyr Getting Started Guide <https://docs.zephyrproject.org/latest/getting_started/index.html>`_."
msgstr ""

msgid "When building a Zephyr project / sample for a SoC, the board naming can be confusing. The naming convention is ``<board>/<soc>/<core>``. For example, to build a Zephyr project for the phyBOARD Pollux (i.MX8MP) with the M7 core, the board name is ``phyboard_pollux/mimx8ml8/m7``."
msgstr ""

msgid "When compiling the firmware, you'll get two binary files. One ``.elf`` file for starting the remote processor via remoteproc, which includes the resource table, and one ``.bin`` file for starting the remote processor via the bootloader."
msgstr ""

msgid "Starting the Coprocessor via Remoteproc"
msgstr ""

msgid "To start a remote processor via remoteproc, you need to place the firmware into the ``/lib/firmware`` directory on the target."
msgstr ""

msgid "This can be done using SCP (e.g., for development), by copying the file to the SD card, or by including it in the Yocto build (e.g., for production use)."
msgstr ""

msgid "Make sure the devicetree overlay that enables remoteproc support is activated. You can find more information about how to activate the devicetree overlay in the BSP manual for your platform."
msgstr ""

msgid "If your device has multiple coprocessors, please make sure you use the correct remoteproc device."
msgstr ""

msgid "Starting the Coprocessor via Bootloader"
msgstr ""

msgid "Starting the Coprocessor via the bootloader is platform specific. You can find more information in the BSP manual for your platform."
msgstr ""

msgid "Using this method can be useful, if you want to have the coprocessor running before the application processor boots up, for example for applications that need to have a fast response time on startup."
msgstr ""

msgid "Here is the manual for the i.MX8MP for example: `Running the M7 Core <https://phytec.github.io/doc-bsp-yocto/bsp/imx8/imx8mp/head.html#running-mcore-examples>`_"
msgstr ""

msgid "Starting the Coprocessor via Debug Probe"
msgstr ""

msgid "It is possible to start the coprocessor via a debug probe like J-Link or OpenOCD. This is useful for debugging the firmware on the coprocessor, or for starting up the coprocessor in a development environment."
msgstr ""

msgid "On most PHYTEC boards, you can use a PEB-EVAL-01 shield to connect the debug probe to the board via a 20-pin JTAG connector."
msgstr ""

msgid "When using Zephyr you can simply use the command"
msgstr ""

msgid "to start GDB and load / start the firmware on the coprocessor."
msgstr ""

msgid "Please note that it is not possible to use inter processor communication via RPMsg when not starting the coprocessor via remoteproc! This is because remoteproc prepares Linux and the shared memory for communication!"
msgstr ""

msgid "This is especially impractical when you want to debug your coprocessor firmware via a debug probe, if your system requires the use of communication between the cores."
msgstr ""

msgid "Accessing the serial console"
msgstr ""

msgid "The coprocessor firmware can output messages via a serial console. It differs from platform to platform how to gain access to the serial console."
msgstr ""

msgid "For example, on the i.MX8 platform, you'll get a serial console via the debug USB port on the board. On i.MX93 (on segin board) on the other hand, you can access it via RS232 on the PEB-EVAL-01."
msgstr ""

msgid "It's recommended to take a look into the corresponding BSP or Zephyr manual for your platform to find out how to access the serial console."
msgstr ""

msgid "Zephyr offers a shell backend to be able to access a shell via RPMsg. This can help for debugging purposes or to send commands to the coprocessor. Take a look here: :ref:`openamp-using-resource-table`"
msgstr ""

msgid "The easiest way to communicate on the Linux side through RPMsg is via the ``tty-rpmsg`` driver. This driver creates a tty device in ``/dev`` that can be used to send and receive messages to the coprocessor."
msgstr ""

msgid "Debugging the Coprocessor"
msgstr ""

msgid "In some cases it can be necessary to get a deeper insight into the coprocessor firmware to find bugs or to optimize the performance. To do that you can use any JTAG debugger. The following sections describe it with the J-Link as an example."
msgstr ""

msgid "If the firmware does not need to communicate with the application processor via RPMsg, the coprocessor can be started easily via the debug probe and debugged with GDB. (see :ref:`starting-coprocessor-via-debug-probe`)"
msgstr ""

msgid "If the firmware needs to communicate with the application processor via RPMsg, the preparation in order to start the coprocessor and the communication between the cores is a bit more complex. This is because remoteproc prepares the shared memory and the Linux Kernel for communication but GDB also needs to know in which state the coprocessor is."
msgstr ""

msgid "Before you start debugging, please make sure your J-Link is compatible with the architecture of the ARM-core you want to debug. Most cores are possible, for example the A- or M-Core or the DSP. You can find this information in the Segger knowledge base. (for example: `J-Link Base 9 <https://kb.segger.com/J-Link_BASE_V9>`_)"
msgstr ""

msgid "When debugging the coprocessor firmware, you can use the following methods:"
msgstr ""

msgid "Debug a non remoteproc firmware"
msgstr ""

msgid "Connect the debug probe to the board. (e.g. via PEB-EVAL-01)"
msgstr ""

msgid "Start the coprocessor via the debug probe. With west:"
msgstr ""

msgid "The only thing `west debug` does is to start a JLinkGDBServer and GDB with the correct parameters for your target. If you don't want to use or can't use west, you can do this manually as well."
msgstr ""

msgid "Load the firmware on the coprocessor via GDB."
msgstr ""

msgid "Set a breakpoint and start the firmware on the coprocessor via GDB."
msgstr ""

msgid "Debugging a remoteproc firmware using GDB"
msgstr ""

msgid "This is a workaround to debug a remoteproc firmware. It is neither the most convenient way to debug a processor nor is it recommended by NXP. Maybe there will be a better solution in the future but for now this is the only way found to debug a remoteproc firmware."
msgstr ""

msgid "Prerequisites:"
msgstr ""

msgid "Have the target booted up and connected to the host via debug usb and J-Link."
msgstr ""

msgid "Have the firmware in ``/lib/firmware`` on the target. For example :ref:`openamp-using-resource-table` (Make sure it is the same file you are debugging with GDB!)"
msgstr ""

msgid "Have the resource table included in the firmware binary."
msgstr ""

msgid "Have the remoteproc device enabled in the devicetree."
msgstr ""

msgid "Have a serial console to the coprocessor. (e.g. via ttyUSB1)"
msgstr ""

msgid "Have a shell of the application processor open (e.g. via SSH)"
msgstr ""

msgid "Start a debugserver with west:"
msgstr ""

msgid "Start GDB with your firmware in a new terminal:"
msgstr ""

msgid "Connect to the debugserver:"
msgstr ""

msgid "Reset the coprocessor and load the firmware:"
msgstr ""

msgid "Insert needed kernel modules on the target (e.g. rpmsg_tty.ko)"
msgstr ""

msgid "Start the firmware on the coprocessor via remoteproc:"
msgstr ""

msgid "The Linux shell freezes now because GDB is halting the coprocessor. Continue the execution in GDB:"
msgstr ""

msgid "Zephyr will not boot up and hang in a fault condition. This is expected. To overcome this issue, break execution with Ctrl+C, reset the coprocessor and continue again."
msgstr ""

msgid "The coprocessor should now boot up, and you can debug the firmware via GDB."
msgstr ""

msgid "It is important to use JTAG as debug interface. Using SWD will reset and halt the whole SoC which will cause unexpected behavior."
msgstr ""

msgid "GDB hints"
msgstr ""

msgid "Here are some useful GDB commands to debug the coprocessor firmware:"
msgstr ""

msgid "``monitor reset``: Reset the coprocessor"
msgstr ""

msgid "``monitor halt``: Halt the coprocessor"
msgstr ""

msgid "``break main``: Set a breakpoint at the main function"
msgstr ""

msgid "``break main.c:42``: Set a breakpoint at line 42 in main.c"
msgstr ""

msgid "``watch *(unsigned short*)0x30a30010``: Set a watchpoint on a 16-bit memory address(e.g. some register)"
msgstr ""

msgid "``print var``: Print the value of a variable in the current context"
msgstr ""

msgid "``backtrace``: Print the current stack trace"
msgstr ""

msgid "``continue``: Continue the execution"
msgstr ""

msgid "``step``: Step into the next function"
msgstr ""

msgid "If the command doesn't get ambiguous, you can shorten the command. For example, you can use ``b main`` instead of ``break main`` or ``c`` instead of ``continue``. This is useful if you have to type the command multiple times."
msgstr ""

msgid "Debugging a remoteproc firmware using SEGGER Ozone"
msgstr ""

msgid "Have the target booted up and connected to the host via debug USB and J-Link."
msgstr ""

msgid "Have the firmware in ``/lib/firmware`` on the target. For example :ref:`openamp-using-resource-table` (Make sure it is the same file you are debugging with Ozone!)"
msgstr ""

msgid "SEGGER Ozone is a powerful graphical debugging tool that can be used to debug any kind of target with any kind of architecture. It makes it more easy to attach to a running program than GDB."
msgstr ""

msgid "Here are the steps how to connect to a running program:"
msgstr ""

msgid "Start the target and load the firmware via remoteproc:"
msgstr ""

msgid "Start SEGGER Ozone and use the new project wizard"
msgstr ""

msgid "Select your target (for example MIMX8ML8_M7 for i.MX8MP), click next and select the connected J-Link debug probe."
msgstr ""

msgid "Select the compiled elf file of your firmware and click next."
msgstr ""

msgid "Select \"Do not set\" for initial PC and Stack Pointer to ensure that nothing is overwritten."
msgstr ""

msgid "Click \"Finish\" to create the project."
msgstr ""

msgid "Click on the small green arrow directly next to the \"On/Off\" button in the top left corner of the window. Click on \"Attach to running program\"."
msgstr ""

msgid "The target will halt, even though Ozone shows \"CPU Running...\""
msgstr ""

msgid "To fix this behavior just restart the coprocessor via remoteproc on the target:"
msgstr ""

msgid "The target should now boot up, and you can debug the firmware via Ozone."
msgstr ""

msgid "You can use debugging with Ozone not just to debug the firmware, but also to debug the remoteproc framework itself. This can be useful if you want to find out why the coprocessor is not booting up or why the communication is not working or if you just want to get a deeper insight into the remoteproc framework."
msgstr ""

msgid "Examples and Resources"
msgstr ""

msgid "This section gives an overview of examples and resources that can be used to get started with a coprocessor."
msgstr ""

msgid "The examples are focused on the NXP i.MX platform and Zephyr for now, but the principles can be applied to other platforms as well."
msgstr ""

msgid "**Resources:**"
msgstr ""

msgid "`NXP AN5317 - Loading code to Coprocessor <https://www.nxp.com/docs/en/application-note/AN5317.pdf>`_"
msgstr ""

msgid "`Zephyr IPC Samples <https://docs.zephyrproject.org/latest/samples/subsys/ipc/ipc.html>`_"
msgstr ""

msgid "Hello World"
msgstr ""

msgid "The `hello_world <https://docs.zephyrproject.org/latest/samples/hello_world/README.html>`_ sample is a simple example Zephyr project, that prints \"Hello World!\" to the serial console."
msgstr ""

msgid "Run the Sample"
msgstr ""

msgid "Make sure the devicetree overlay ``imx8mp-phycore-rpmsg.dtbo`` is activated, the BSP manual for your platform explains how to activate this."
msgstr ""

msgid "Restart the target and execute in U-Boot:"
msgstr ""

msgid "Save the environment in U-Boot in order to enable the m-core on every boot by default. Executing ``saveenv`` twice will save the environment to the redundant MMC partition as well."
msgstr ""

msgid "The target will now boot and you can build and flash the Zephyr application with:"
msgstr ""

msgid "Zephyr should now boot with"
msgstr ""

msgid "OpenAMP using resource table"
msgstr ""

msgid "The `openamp_rsc_table <https://docs.zephyrproject.org/latest/samples/subsys/ipc/openamp_rsc_table/README.html>`_ sample \"demonstrates how to use OpenAMP with Zephyr based on a resource table. It is designed to respond to [..]\" the `rpmsg client <https://elixir.bootlin.com/linux/latest/source/samples/rpmsg/rpmsg_client_sample.c>`_ and `rpmsg tty <https://elixir.bootlin.com/linux/latest/source/drivers/tty/rpmsg_tty.c>`_ samples in the Linux Kernel. This sample demonstrates communication between Zephyr (coprocessor) and Linux (application processor) using OpenAMP. It creates the two RPMsg endpoints:"
msgstr ""

msgid "rpmsg-client-sample"
msgstr ""

msgid "Demonstrates generic RPMsg message exchange (Ping-pong) between Zephyr and Linux."
msgstr ""

msgid "rpmsg-tty"
msgstr ""

msgid "A TTY service that virtualizes a serial connection at `/dev/rpmsg-tty` in Linux, facilitating data exchange with Zephyr over this virtualized interface."
msgstr ""

msgid "Prepare Linux"
msgstr ""

msgid "The example has been tested with the imx8mp and the `BSP-Yocto-NXP-i.MX8MP-PD24.1.0 <https://www.phytec.de/bsp-download/?bsp=BSP-Yocto-NXP-i.MX8MP-PD24.1.0>`_. However, some modifications are necessary to be able to communicate in between Zephyr and Linux with RPMsg. The devicetree overlay that enables rpmsg has to be enabled. You can edit this line directly in bootenv.txt in the boot partition."
msgstr ""

msgid "Changes in 'bootenv.txt'"
msgstr ""

msgid "Changes in the devicetree overlay 'imx8mp-phycore-rpmsg.dtbo'"
msgstr ""

msgid "Prepare Zephyr"
msgstr ""

msgid "The sample needs some board specific settings and a devicetree overlay for the phyBOARD Pollux. This will be upstreamed soon and maybe it is possible to make the Zephyr sample fully generic."
msgstr ""

msgid "You can see a branch with the required changes `here <https://github.com/PHYTEC-Messtechnik-GmbH/sdk-zephyr/tree/WIP/j.remmert%40phytec.de/openamp_rsc_pollux>`_."
msgstr ""

msgid "Build Zephyr and copy the firmware to ``/lib/firmware`` on the target:"
msgstr ""

msgid "Start the Zephyr application with remoteproc:"
msgstr ""

msgid "Zephyr should now boot now. The kernel module ``rpmsg_client_sample`` should load automatically and respond to the running m-core."
msgstr ""

msgid "If the the kernel Module does not load automatically, you can manually load it:"
msgstr ""

msgid "**Serial Communication**"
msgstr ""

msgid "Once the demo is running, it opens two serial devices (``/dev/ttyRPMSG0``, ``/dev/ttyRPMSG1``), one to send/receive any messages to Zephyr and one for the Zephyr shell backend."
msgstr ""

msgid "Remoteproc ensures to register the resource table and the RPMsg service. Running firmware via debug probe is not possible when using RPMsg."
msgstr ""

msgid "Remoteproc only reads firmware files from the ``/lib/firmware`` directory! If you try to load a binary from another location errors will occur!"
msgstr ""

msgid "Console Output Linux"
msgstr ""

msgid "Debugging"
msgstr ""

msgid "Print resource table in Linux"
msgstr ""

msgid "Print related memory areas in Linux:"
msgstr ""

msgid "Other Examples"
msgstr ""

msgid "The following examples exist in Zephyr, however, they are specific to SoCs that have multiple instances of Zephyr running in the same SoC. They are partly related to Zephyrs `ipc_service <https://docs.zephyrproject.org/latest/services/ipc/ipc_service/ipc_service.html>`_ and not suitable for communication with Linux."
msgstr ""

msgid "`OpenAMP Sample <https://docs.zephyrproject.org/latest/samples/subsys/ipc/openamp/README.html#openamp>`_"
msgstr ""

msgid "sample builds different images for two targets running Zephyr. Both targets setup virtqueue and virtio and communicate with each other via RPMsg. This sample is mainly used to evaluate SoCs with two Cortex M devices and can not be used with Linux."
msgstr ""

msgid "`openamp-system-reference <https://github.com/OpenAMP/openamp-system-reference>`_"
msgstr ""

msgid "Several samples for both platforms, Linux and Zephyr that demonstrate different aspects of OpenAMP."
msgstr ""

msgid "`Samples in ipc_service/ <https://docs.zephyrproject.org/latest/samples/subsys/ipc/ipc.html>`_"
msgstr ""

msgid "Examples related to Zephyr ipc_service subsystem. Note that not all of those examples may be applicable to heterogeneous systems with one core running Linux and the other Zephyr."
msgstr ""

msgid "Current Problems"
msgstr ""

msgid "This section lists current problems that need work."
msgstr ""

msgid "Shell not working in Zephyr for Linux SoCs."
msgstr ""

msgid "There may be a problem with interrupts and nxp deactivated the shell for the imx8qm  boards. https://github.com/zephyrproject-rtos/zephyr/pull/79428"
msgstr ""

msgid "Table of Contents"
msgstr ""

msgid "Coprocessor"
msgstr ""

#~ msgid "Most modern SoCs include one of more coprocessors beside an application processor. In most cases the application processor runs Linux, while the coprocessor may run an RTOS. This manuals goes into detail how to utilize the coprocessor efficiently for projects."
#~ msgstr ""

#~ msgid "The manual explains generic principles and applies those principles in examples for a specific platform and tools. It gives in introduction to OpenAMP, Zephyr and Protocol Buffers (protobuf)."
#~ msgstr ""

#~ msgid "Data Processing"
#~ msgstr ""

#~ msgid "The `OpenAMP <http://openampproject.org>`_ Project which \"seeks to standardize the interactions between operating environments in a heterogeneous embedded system through open source solutions for Asymmetric MultiProcessing (AMP).\" This introduction explains the main components and terms, the `OpenAMP documentation <https://openamp.readthedocs.io/en/latest/openamp/index.html>`_ goes into further detail. OpenAMP is available in Linux as well as in RTOS (e.g. Zephyr) and Vendor SDKs (e.g. NXP MCUX, TI SDK, STM32Cube). The OpenAMP framework consists of several components:"
#~ msgstr ""

#~ msgid "Components"
#~ msgstr ""

#~ msgid "In SoCs, where coprocessors are integrated on the same die they typically communicate by exchanging data via sharing memory sections."
#~ msgstr ""

#~ msgid "Life Cycle Management (LCM) to manage and update the software running on coprocessors. The `remoteproc documentation <https://docs.kernel.org/staging/remoteproc.html>`_ on Kernel.org goes into further technical details."
#~ msgstr ""

#~ msgid "Exchange of messages, api that enables Inter Processor Communications (IPC). The `rpmsg documentation <https://docs.kernel.org/staging/rpmsg.html>`_ on Kernel.org goes into further technical details."
#~ msgstr ""

#~ msgid "**VirtIO** provides a standardized framework for efficient message exchange between processing units using virtualization. **Virtqueue** is the abstract structure that manages the queues of messages and buffers for communication between these units. **Vring** is the specific circular buffer implementation used within a Virtqueue that organizes the descriptors for the messages being exchanged. There are ringbuffers for both directions (read, write). This set of infrastructure components can be used in combination with RPMsg to improve performance and reduce synchronization between Cores."
#~ msgstr ""

#~ msgid "RPC based on RPMsg"
#~ msgstr ""

#~ msgid "TBD"
#~ msgstr ""

#~ msgid "RPMsg Messaging Protocol"
#~ msgstr ""

#~ msgid "communication stack consisting of several protocol layers:"
#~ msgstr ""

#~ msgid "Transport Layer:"
#~ msgstr ""

#~ msgid "MAC Layer:"
#~ msgstr ""

#~ msgid "Physical Layer:"
#~ msgstr ""

#~ msgid "Libmetal"
#~ msgstr ""

#~ msgid "NXP MCUX"
#~ msgstr ""

#~ msgid "RPmsg + Protobuf"
#~ msgstr ""

#~ msgid "The Zephyr Inter-Processor Communication (IPC) Subsystem includes some `samples <https://docs.zephyrproject.org/latest/samples/subsys/ipc/ipc.html>`_:"
#~ msgstr ""

#~ msgid "**Remoteproc:** The remoteproc framework is used to load and manage firmware on coprocessors. It also ensures to register the resource table and the RPMsg service. If RPMsg is used, flashing the firmware via a SWD debug adapter is not possible."
#~ msgstr ""

#~ msgid "Furthermore, remoteproc only reads firmware files from the ``/lib/firmware`` directory. Loading firmware binaries from another location will result in errors."
#~ msgstr ""

#~ msgid "Remoteproc ensures to register the resource table and the RPMsg service. Running firmware via debug adapter is not possible when using RPMsg."
#~ msgstr ""

