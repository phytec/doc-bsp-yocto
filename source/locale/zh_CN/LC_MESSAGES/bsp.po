# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, PHYTEC Messtechnik GmbH
# This file is distributed under the same license as the PHYTEC BSP
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PHYTEC BSP Documentation imx8mp-pd22.1.2-5-ge2f699d\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 11:24+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

msgid "i.MX 8M Plus Manuals"
msgstr "i.MX 8M Plus 手册"

msgid "Libra i.MX 8M Plus FPSC Manuals"
msgstr "Libra i.MX 8M Plus FPSC 手册"

msgid "i.MX 8M Mini Manuals"
msgstr "i.MX 8M Mini 手册"

msgid "i.MX 8M Nano Manuals"
msgstr "i.MX 8M Nano 手册"

msgid "i.MX 8 Manuals"
msgstr "i.MX 8 手册"

#, fuzzy
msgid "i.MX 8"
msgstr "i.MX 8 手册"

msgid "Documentation in pdf format: `Download <static-pdf-dl_>`_"
msgstr "pdf格式的文档： `下载 <static-pdf-dl_>`_"

msgid "|doc-id| |soc| BSP Manual Head"
msgstr "|doc-id| |soc| BSP 手册模板"

msgid "Document Title"
msgstr "文档标题"

msgid "Document Type"
msgstr "文档类型"

msgid "BSP Manual"
msgstr "BSP 手册"

msgid "Article Number"
msgstr "型号"

msgid "|doc-id|"
msgstr "|doc-id|"

msgid "Yocto Manual"
msgstr "Yocto 手册"

msgid "Release Date"
msgstr "发布日期"

msgid "XXXX/XX/XX"
msgstr "XXXX/XX/XX"

msgid "Is Branch of"
msgstr "母文档"

msgid "The table below shows the Compatible BSPs for this manual:"
msgstr "下表显示了与本手册兼容的 BSP："

msgid "Compatible BSPs"
msgstr "适用BSP"

msgid "BSP Release Type"
msgstr "BSP 发布类型"

msgid "BSP Release  Date"
msgstr "BSP 发布日期"

msgid "BSP Status"
msgstr "BSP 状态"

msgid "This BSP manual guides you through the installation and creation steps for the Board Support Package (BSP) and describes how to handle the interfaces for the |kit|. Furthermore, this document describes how to create BSP images from the source code. This is useful for those who need to change the default image and need a way to implement these changes in a simple and reproducible way. Further, some sections of this manual require executing commands on a personal computer (host). Any and all of these commands are assumed to be executed on a Linux Operating System."
msgstr "本手册指导您完成BSP包的安装、编译和烧写，并描述如何使用 |kit| 的硬件接口。本手册还包括如何从源码编译内核、u-boot镜像。本手册包含需要在PC(Linux操作系统)上执行的指令。"

msgid "This document contains code examples that describe the communication with the board over the serial shell. The code examples lines begin with \"host:~$\", \"target:~$\" or \"u-boot=>\". This describes where the commands are to be executed. Only after these keywords must the actual command be copied."
msgstr "本文档包含指令示例，描述如何在串口终端上与核心板进行交互。指令示例以“host:~$”、“target:~$”或“u-boot=>”开头，开头的这些关键字描述了指令执行的软件环境。如果需要复制这些指令，请仅复制这些关键字之后的内容。"

msgid "PHYTEC Documentation"
msgstr "PHYTEC 文档"

msgid "PHYTEC provides a variety of hardware and software documentation for all of our products. This includes any or all of the following:"
msgstr "PHYTEC 将为旗下所有产品提供各种硬件和软件文档。包括以下任一以及全部内容："

#, fuzzy
msgid "**QS Guide**: A short guide on how to set up and boot a phyCORE board."
msgstr "**快速上手指南**：简单指导我们如何配置和启动 phyCORE 核心板，以及对构建 BSP、设备树和外设访问进行简要说明。"

msgid "**Hardware Manual**: A detailed description of the System on Module and accompanying carrierboard."
msgstr "**硬件手册**：核心板和配套底板的详细硬件描述。"

msgid "**Yocto Guide**: A comprehensive guide for the Yocto version the phyCORE uses. This guide contains an overview of Yocto; introducing, installing, and customizing the PHYTEC BSP; how to work with programs like Poky and Bitbake; and much more."
msgstr "**Yocto 指南**：phyCORE 使用的 Yocto 版本的综合指南。本指南包含: Yocto 概述；PHYTEC BSP 介绍、编译和定制化修改；如何使用 Poky 和 Bitbake 等编译框架。"

msgid "**BSP Manual**: A manual specific to the BSP version of the phyCORE. Information such as how to build the BSP, booting, updating software, device tree, and accessing peripherals can be found here."
msgstr "**BSP 手册**：phyCORE 的 BSP 版本专用手册。可在此处找到如何编译BSP、启动、更新软件、设备树和外设等信息。"

msgid "**Development Environment Guide**: This guide shows how to work with the Virtual Machine (VM) Host PHYTEC has developed and prepared to run various Development Environments. There are detailed step-by-step instructions for Eclipse and Qt Creator, which are included in the VM. There are instructions for running demo projects for these programs on a phyCORE product as well. Information on how to build a Linux host PC yourself is also a part of this guide."
msgstr "**开发环境指南**：本指南介绍了如何使用 PHYTEC 虚拟机来搭建多样的开发环境。VM 中包含了 Eclipse 和 Qt Creator 的详细上手指导，还说明了如何将所编译出的demo程序放到phyCORE 核心板上运行。本指南同时也介绍了如何在本地Linux ubuntu上搭建完整的开发环境。"

msgid "**Pin Muxing Table**: phyCORE SOMs have an accompanying pin table (in Excel format). This table will show the complete default signal path, from the processor to the carrier board. The default device tree muxing option will also be included. This gives a developer all the information needed in one location to make muxing changes and design options when developing a specialized carrier board or adapting a PHYTEC phyCORE SOM to an application."
msgstr "**引脚复用表**：phyCORE 核心板附带一个引脚复用表（Excel 格式）。此表将显示从处理器到底板的信号连接以及默认的设备树复用选项。这为开发人员进行引脚复用和设计提供了必要的信息。"

msgid "On top of these standard manuals and guides, PHYTEC will also provide Product Change Notifications, Application Notes, and Technical Notes. These will be done on a case-by-case basis. Most of the documentation can be found on the |dlpage-product| of our product."
msgstr "除了这些标准手册和指南之外，PHYTEC 还将提供产品变更通知、应用说明和技术说明。这些文档将根据具体案例进行针对性提供。大部分文档都可以在我们产品的 |dlpage-product| 中找到。"

msgid "Supported Hardware"
msgstr "支持的硬件"

msgid "The |sbc| populated with either the i.MX 8M Mini SoC or i.MX 8M Nano SoC, is supported."
msgstr "支持配备 i.MX 8M Mini SoC 或 i.MX 8M Nano SoC 的 |sbc|。"

msgid "On our web page, you can see all supported Machines with the available Article Numbers for this release: |yocto-manifestname| `download <dlpage-bsp_>`_. If you choose a specific **Machine Name** in the section **Supported Machines**, you can see which **Article Numbers** are available under this machine and also a short description of the hardware information. In case you only have the **Article Number** of your hardware, you can leave the **Machine Name** drop-down menu empty and only choose your **Article Number**. Now it should show you the necessary **Machine Name** for your specific hardware"
msgstr "在我们的网页上，您可以查看适用于BSP版本 |yocto-manifestname| 的所有Machine及其对应的Article Numbers(产品型号)： `网址 <dlpage-bsp_>`_. 如果您在该网页 **Supported Machines** 一节选择了特定的 **Machine Name** ，您可以查看被选中machine下的包含的 **Article Number(产品型号)** 以及简要的硬件描述。如果您只有 **Article Number** ，可以将 **Machine Name** 下拉菜单留空，仅选择您的 **Article Number** 。那么，它会显示您特定硬件所对应的 **Machine Name** "

msgid "|sbc| Components"
msgstr "|sbc| 器件"

msgid "|sbc| Components (top)"
msgstr "|sbc| 器件（顶部）"

msgid "|sbc| Components (bottom)"
msgstr "|sbc| 器件（底部）"

msgid "Getting Started"
msgstr "开始使用"

msgid "The |kit| is shipped with a pre-flashed SD card. It contains the |yocto-imagename| and can be used directly as a boot source. The eMMC is programmed with only a U-Boot by default. You can get all sources from the `PHYTEC download server <dl-server_>`_. This chapter explains how to flash a BSP image to SD card and how to start the board."
msgstr "该 |kit| 包含预先烧写好的SD卡。它包含 |yocto-imagename| 镜像，可以直接用作启动盘。默认情况下，核心板上的eMMC仅烧写了U-Boot。您可以从 `PHYTEC下载服务器 <dl-server_>`_ 获取所有镜像资源。本章将解释如何将BSP镜像烧写到SD卡以及如何启动开发板。"

msgid "There are several ways to flash an image to SD card or even eMMC. Most notably using simple, sequential writing with the Linux command line tool ``dd``. An alternative way is to use PHYTEC's system initialization program called `partup <https://github.com/phytec/partup>`_, which makes it especially easy to format more complex systems. You can get `prebuilt Linux binaries of partup <https://github.com/phytec/partup/releases>`__ from its release page. Also read `partup's README <https://github.com/phytec/partup#readme>`__ for installation instructions."
msgstr "有几种方法可以将镜像写入SD卡或eMMC。最为人熟知的方式是使用Linux命令行工具 ``dd`` 进行简单的顺序写入。另一种方法是使用PHYTEC的自研程序 `partup <https://github.com/phytec/partup>`_ ，它可以让格式化复杂系统的过程变得简单。您可以从其发布页面获取 `预编译的Linux partup 二进制文件 <https://github.com/phytec/partup/releases>`_ 。请阅读 `partup的readme文件 <https://github.com/phytec/partup#readme>`_ 来获取安装指导。"

msgid "Get the Image"
msgstr "下载镜像"

msgid "The image contains all necessary files and makes sure partitions and any raw data are correctly written. Both the partup package and the WIC image, which can be flashed using ``dd``, can be downloaded from the `PHYTEC download server <dl-server_>`_."
msgstr "|yocto-imagename| 镜像包含完整系统所需的所有必要文件，您需确保镜像中各个分区以及裸数据都会被正确写入启动盘。可以从 `PHYTEC 下载服务器 <dl-server_>`_ 下载 partup 镜像文件或者是可以使用 ``dd`` 进行烧写的 WIC 镜像。"

msgid "Get either the partup package or the WIC image from the download server:"
msgstr "从下载服务器获取 partup 镜像文件或WIC镜像："

msgid "For eMMC, more complex partitioning schemes or even just large images, we recommend using the partup package, as it is faster in writing than ``dd`` and allows for a more flexible configuration of the target flash device."
msgstr "针对eMMC，我们建议使用partup去烧写比较大的或者是有复杂分区配置的镜像，因为它在写入速度上比 ``dd`` 更快，并且可以对闪存设备进行更灵活的配置。"

msgid "Write the Image to SD Card"
msgstr "将镜像写入SD卡"

msgid "To create your bootable SD card, you must have root privileges on your Linux host PC. Be very careful when specifying the destination device! All files on the selected device will be erased immediately without any further query!"
msgstr "要创建SD卡启动盘，必须要拥有Linux PC上的root权限。在选择烧写设备时请务必小心！所选设备上的所有文件将在命令执行后立即被擦除，而且擦除前不会有任何进一步的确认！"

msgid "Selecting the wrong device may result in **data loss** and e.g. could erase your currently running system on your host PC!"
msgstr "选择错误的设备可能会导致 **数据丢失** ，例如，可能会擦除您当前所在PC上的系统！"

msgid "Finding the Correct Device"
msgstr "寻找正确的设备"

msgid "To create your bootable SD card, you must first find the correct device name of your SD card and possible partitions. If any partitions of the SD cards are mounted, unmount those before you start copying the image to the SD card."
msgstr "要创建SD卡启动盘，首先要找到PC上您SD卡对应的正确设备名称。在开始将镜像复制到SD卡之前，请卸载任何已挂载的分区。"

msgid "In order to get the correct device name, remove your SD card and execute:"
msgstr "为了获取正确的设备名称，请移除您的SD卡并执行："

msgid "Now insert your SD card and execute the command again:"
msgstr "现在插入你的SD卡，然后再次执行命令："

msgid "Compare the two outputs to find the new device names listed in the second output. These are the device names of the SD card (device and partitions if the SD card was formatted)."
msgstr "比较两个输出，以获取第二个输出中的新设备名称。这些是SD卡的设备名称（如果SD卡已格式化，则包括设备名称和对应的分区）。"

msgid "In order to verify the device names being found, execute the command ``sudo dmesg``. Within the last lines of its output, you should also find the device names, e.g. ``/dev/sde`` or ``/dev/mmcblk0`` (depending on your system)."
msgstr "为了验证找到的设备名称的最终正确性，请执行命令 ``sudo dmesg``。在其输出的最后几行中，您应该也能找到设备名称，例如 ``/dev/sde`` 或 ``/dev/mmcblk0`` （具体取决于您的系统）。"

msgid "Alternatively, you may use a graphical program of your choice, like `GNOME Disks <https://apps.gnome.org/en/DiskUtility/>`_ or `KDE Partition Manager <https://apps.kde.org/partitionmanager/>`_, to find the correct device."
msgstr "或者，您可以使用图形化的程序，例如 `GNOME Disks <https://apps.gnome.org/en/DiskUtility/>`_ 或 `KDE Partition Manager <https://apps.kde.org/partitionmanager/>`_ 来找到正确的设备。"

msgid "Now that you have the correct device name, e.g. ``/dev/sde``, you can see the partitions which must be unmounted if the SD card is formatted. In this case, you will also find the device name with an appended number (e.g. ``/dev/sde1``) in the output. These represent the partitions. Some Linux distributions automatically mount partitions when the device gets plugged in. Before writing, however, these need to be unmounted to avoid data corruption."
msgstr "现在您已经得到了正确的设备名称，例如 ``/dev/sde``，如果SD卡曾格式化过，需要确认已取消其分区的挂载，您可以在输出中看到带有附加了数字的设备名称（例如 ``/dev/sde1``），它们是SD卡的分区。一些Linux发行版系统在设备插入时会自动挂载分区。在写入之前，必须卸载这些分区，以避免数据损坏。"

msgid "Unmount all those partitions, e.g.:"
msgstr "卸载所有这些分区，例如："

msgid "Now, the SD card is ready to be flashed with an image, using either ``partup``, ``dd`` or ``bmap-tools``."
msgstr "现在，SD卡已经准备好可以使用 ``partup`` 、 ``dd`` 或 ``bmap-tools`` 来写入镜像。"

msgid "Using bmap-tools"
msgstr "使用bmap-tools"

msgid "One way to prepare an SD card is using `bmap-tools <https://github.com/yoctoproject/bmaptool>`_. Yocto automatically creates a block map file (``<IMAGENAME>-<MACHINE>.wic.bmap``) for the WIC image that describes the image content and includes checksums for data integrity. *bmaptool* is packaged by various Linux distributions. For Debian-based systems install it by issuing:"
msgstr "烧写SD卡的其中一种方法是使用 `bmap-tools <https://github.com/yoctoproject/bmaptool>`_ 。Yocto会自动为WIC镜像创建一个block map文件（ ``<IMAGENAME>-<MACHINE>.wic.bmap`` ），该文件描述了镜像内容并包含数据完整性的校验。 *bmaptool* 已被多种Linux发行版支持。对于基于Debian的系统，可以通过以下命令安装："

msgid "Flash a WIC image to SD card by calling:"
msgstr "通过以下命令将WIC镜像烧写到SD卡："

msgid "Replace <your_device> with your actual SD card's device name found previously, and make sure to place the file ``<IMAGENAME>-<MACHINE>.wic.bmap`` alongside the regular WIC image file, so bmaptool knows which blocks to write and which to skip."
msgstr "将 <your_device> 替换为您之前找到的SD卡设备名称，并确保将文件 ``<IMAGENAME>-<MACHINE>.wic.bmap`` 与WIC镜像文件放在一起，以便bmaptool知道哪些块需要写入，哪些块需要跳过。"

msgid "*bmaptool* only overwrites the areas of an SD card where image data is located. This means that a previously written U-Boot environment may still be available after writing the image."
msgstr "*bmaptool* 仅擦写SD卡上镜像数据所在的区域。这意味着在写入新的镜像后，之前写入的旧U-Boot环境变量可能仍然可用。"

msgid "Using partup"
msgstr "使用partup"

msgid "Writing to an SD card with partup is done in a single command:"
msgstr "使用partup烧写SD卡只需一个命令："

msgid "Make sure to replace <your_device> with your actual device name found previously."
msgstr "确保将 <your_device> 替换为您之前找到的设备名称。"

msgid "Further usage of partup is explained at its `official documentation website <https://partup.readthedocs.io/en/latest/>`__."
msgstr "关于partup的进一步使用说明，请参阅其 `官方文档 <https://partup.readthedocs.io/en/latest/>`_ 。"

msgid "Host systems which are using resize2fs version 1.46.6 and older (e.g. Ubuntu 22.04) are not able to write partup packages created with Yocto Mickledore or newer to SD-Card. This is due to a new default option in resize2fs which causes an incompatibility. See `release notes <https://e2fsprogs.sourceforge.net/e2fsprogs-release.html#1.47.0>`_."
msgstr "使用resize2fs版本1.46.6及更早版本的PC系统（例如Ubuntu 22.04）无法烧写在Mickledore以及更新的yocto版本上创建的partup软件包。这个是因为resize2fs新增了默认选项而导致的兼容性问题。有关详细信息，请参阅 `release notes <https://e2fsprogs.sourceforge.net/e2fsprogs-release.html#1.47.0>`_ 。"

msgid "*partup* has the advantage of allowing to clear specific raw areas in the MMC user area, which is used in our provided partup packages to erase any existing U-Boot environments. This is a known issue *bmaptool* does not solve, as mentioned in the previous chapter."
msgstr "*partup* 具有清除eMMC user区域中特定区域的功能，我们提供的partup程序中用该功能擦除U-Boot环境变量。这是 *bmaptool* 工具所无法完成的一点，如前一部分所提到的。"

msgid "Another key advantage of partup over other flashing tools is that it allows configuring MMC specific parts, like writing to eMMC boot partitions, without the need to call multiple other commands when writing."
msgstr "partup相较于其他烧写工具的一个主要优势是，它可以配置MMC的特定部分，比如他可以直接写入eMMCboot分区，无需调用其他命令。"

msgid "Using ``dd``"
msgstr "使用 ``dd`` "

msgid "After having unmounted all SD card's partitions, you can create your bootable SD card."
msgstr "在卸载所有SD卡的挂载分区后，您可以烧写SD卡。"

msgid "Some PHYTEC BSPs produce uncompressed images (with filename-extension \\*.wic), and some others produce compressed images (with filename-extension \\*.wic.xz)."
msgstr "一些PHYTEC BSP会生成未压缩的镜像（文件名扩展名为*.wic），而另一些则生成压缩的镜像（文件名扩展名为*.wic.xz）。"

msgid "To flash an uncompressed images (\\*.wic) use command below:"
msgstr "要写入未压缩的镜像（\\*.wic），请使用以下命令："

msgid "Or to flash a compressed images (\\*.wic.xz) use that command:"
msgstr "或者要写入压缩后的镜像（\\*.wic.xz），请使用以下命令："

msgid "Again, make sure to replace <your_device> with your actual device name found previously."
msgstr "再次确保将 <your_device> 替换为之前找到的设备名称。"

msgid "The parameter ``conv=fsync`` forces a sync operation on the device before ``dd`` returns. This ensures that all blocks are written to the SD card and none are left in memory. The parameter ``status=progress`` will print out information on how much data is and still has to be copied until it is finished."
msgstr "参数 ``conv=fsync`` 强制在 ``dd`` 返回之前对设备进行sync操作。这确保所有数据块都已写入SD卡，而没有任何数据缓存在内存中。参数 ``status=progress`` 将打印出进度信息。"

msgid "First Start-up"
msgstr "首次启动"

msgid "To boot from an SD card, |ref-bootswitch| needs to be set to the following position:"
msgstr "要从SD卡启动， |ref-bootswitch| 需要设置为以下位置："

msgid "Bootmode Selection"
msgstr "启动模式选择"

msgid "Mini"
msgstr "Mini"

msgid "Insert the SD card"
msgstr "插入SD卡"

#, fuzzy
msgid "Connect the target and the host with **micro USB** on |ref-debugusbconnector| debug USB"
msgstr "使用 **micro USB** 线将开发板的 |ref-debugusbconnector| 调试USB口和主机连接起来"

msgid "Power up the board"
msgstr "给开发板通电"

msgid "Building the BSP"
msgstr "编译BSP"

msgid "This section will guide you through the general build process of the |soc| BSP using Yocto and the phyLinux script. For more information about our meta-layer or Yocto in general visit: |yocto-ref-manual|."
msgstr "本节将指导您使用Yocto和phyLinux脚本进行 |soc| BSP的编译。更多有关phytec meta-layer和Yocto的信息，请访问： |yocto-ref-manual| 。"

msgid "Basic Set-Up"
msgstr "基本设置"

msgid "If you have never created a Phytec BSP with Yocto on your computer, you should take a closer look at the chapter BSP Workspace Installation in the |yocto-ref-manual|."
msgstr "如果您从未在您的主机上使用Yocto编译过Phytec BSP，您应查看 |yocto-ref-manual| 中的BSP Workspace安装一节。"

msgid "Get the BSP"
msgstr "下载BSP"

msgid "There are two ways to get the BSP sources. You can download the complete BSP sources from our download page: |yocto-bsp-name|_; or you can fetch and build it yourself with Yocto. This is particularly useful if you want to make customizations."
msgstr "获取BSP有两种方式。您可以从我们的下载页面下载完整的BSP镜像： |yocto-bsp-name|_ ；您也可以使用Yocto下载BSP工程并编译。如果您想要对BSP进行修改，建议使用第二种方式。"

msgid "The phyLinux script is a basic management tool for PHYTEC Yocto BSP releases written in Python. It is mainly a helper to get started with the BSP structure."
msgstr "phyLinux脚本使用python语言编写，是一个用于管理PHYTEC Yocto BSP工程的基础工具，帮助用户更快上手BSP。"

msgid "Create a fresh project folder, get phyLinux, and make the script executable:"
msgstr "创建一个新的项目文件夹，获取phyLinux脚本，并赋予脚本具备可执行权限："

msgid "A clean folder is important because phyLinux will clean its working directory. Calling phyLinux from a directory that isn't empty will result in a warning."
msgstr "我们需要一个空的项目文件夹，phyLinux首先会清理当前所在的工作目录。从一个不为空的目录下调用phyLinux将会产生告警。"

msgid "Run phyLinux:"
msgstr "运行phyLinux："

msgid "On the first initialization, the phyLinux script will ask you to install the Repo tool in your ``/usr/local/bin`` directory."
msgstr "在首次初始化时，phyLinux脚本会要求您在 ``/usr/local/bin`` 目录中安装Repo工具。"

msgid "During the execution of the init command, you need to choose your processor platform (SoC), PHYTEC's BSP release number, and the hardware you are working on."
msgstr "在执行init命令时，您需要选择您的处理器平台（SoC）、PHYTEC的BSP版本号以及您正在使用的硬件。"

msgid "If you cannot identify your board with the information given in the selector, have a look at the invoice for the product. And have a look at |dlpage-bsp|_."
msgstr "如果您无法根据菜单中提供的信息识别您的开发板，请查看产品的发票。并查看  |dlpage-bsp|_ 。"

msgid "It is also possible to pass this information directly using command line parameters:"
msgstr "也可以通过命令行参数直接传递这些信息："

msgid "After the execution of the init command, phyLinux will print a few important notes. For example, it will print your git identify, SOC and BSP release which was selected as well as information for the next steps in the build process."
msgstr "在执行init命令后，phyLinux将打印一些重要的说明。例如，它将打印您的git用户信息、选择的SOC和BSP版本，以及引导构建过程进行下一步处理的信息。"

msgid "Starting the Build Process"
msgstr "开始构建"

msgid "Set up the shell environment variables:"
msgstr "设置Shell环境变量："

msgid "This needs to be done every time you open a new shell for starting builds."
msgstr "在每次打开新的用于编译的shell时，都需要先执行这一步骤。"

msgid "The current working directory of the shell should change to build/."
msgstr "当前的工作目录会变更为 build/。"

msgid "Open the main configuration file and accept the GPU and VPU binary license agreements. Do this by uncommenting the corresponding line, as below."
msgstr "打开主配置文件，同意并接受GPU和VPU二进制文件的许可证协议。通过取消注释相应的行来完成此操作，如下所示。"

msgid "Build your image:"
msgstr "编译您的镜像："

msgid "For the first build we suggest starting with our smaller non-graphical image phytec-headless-image to see if everything is working correctly."
msgstr "对于第一次编译，我们建议从我们的较小的非图形化镜像phytec-headless-image开始，以查看一切是否正常工作。"

msgid "The first compile process takes about 40 minutes on a modern Intel Core i7. All subsequent builds will use the filled caches and should take about 3 minutes."
msgstr "第一次构建过程在现代的Intel Core i7处理器上大约需要40分钟。后续的构建将使用本次编译产生的缓存，大约需要3分钟。"

msgid "BSP Images"
msgstr "BSP镜像"

msgid "All images generated by Bitbake are deployed to ``~/yocto/build/deploy*/images/<machine>``. The following list shows for example all files generated for the |yocto-machinename| machine:"
msgstr "所有由Bitbake生成的镜像都放在 ``~/yocto/build/deploy*/images/<machine>`` 。例如以下列表是 |yocto-machinename| machine生成的所有文件："

msgid "**u-boot.bin**: Binary compiled U-boot bootloader (U-Boot). Not the final Bootloader image!"
msgstr "**u-boot.bin**: 编译后的U-boot bootloader二进制文件。不是最终镜像中的bootloader！"

msgid "**oftree**: Default kernel device tree"
msgstr "**oftree**: 默认内核设备树"

msgid "**u-boot-spl.bin**: Secondary program loader (SPL)"
msgstr "**u-boot-spl.bin**: 二级程序加载器 (SPL)"

msgid "**bl31-imx8mm.bin**: ARM Trusted Firmware binary"
msgstr "**bl31-imx8mm.bin**: ARM可信固件二进制文件"

msgid "**lpddr4_pmu_train_2d_dmem_202006.bin, lpddr4_pmu_train_2d_imem_202006.bin**: DDR PHY firmware images"
msgstr "**lpddr4_pmu_train_2d_dmem_202006.bin, lpddr4_pmu_train_2d_imem_202006.bin**: DDR PHY固件镜像"

msgid "**imx-boot**: Bootloader build by imx-mkimage which includes SPL, U-Boot, ARM Trusted Firmware and DDR firmware. This is the final bootloader image which is bootable."
msgstr "**imx-boot**：由imx-mkimage编译的bootloader镜像，包括SPL、U-Boot、ARM可信固件和DDR固件。这是最终的可引导bootloader镜像。"

msgid "**fitImage**: Linux kernel FIT image"
msgstr "**fitImage**: Linux内核FIT镜像"

msgid "**fitImage-its\\*.its**: FIT image configuration file"
msgstr "**fitImage-its\\*.its**: FIT镜像配置文件"

msgid "**Image**: Linux kernel image"
msgstr "**Image**: Linux内核镜像"

msgid "**Image.config**: Kernel configuration"
msgstr "**Image.config**: 内核config文件"

msgid "**imx8mm-phyboard-polis-rdk*.dtb**: Kernel device tree file"
msgstr "**imx8mm-phyboard-polis-rdk*.dtb**：内核设备树文件"

msgid "**imx8mm-phy*.dtbo**: Kernel device tree overlay files"
msgstr "**imx8mm-phy*.dtbo**: 内核设备树overlay文件"

msgid "**phytec-qt6demo-image\\*.tar.gz**: Root file system"
msgstr "**phytec-qt6demo-image\\*.tar.gz**: 根文件系统"

msgid "**phytec-qt6demo-image\\*.rootfs.wic.xz**: SD card image"
msgstr "**phytec-qt6demo-image\\*.rootfs.wic.xz**: SD卡镜像"

msgid "Installing the OS"
msgstr "安装操作系统"

msgid "Bootmode Switch (S1)"
msgstr "启动模式开关 (S1)"

#, fuzzy
msgid "The |sbc| features a boot switch with six individually switchable ports to select the |som| default bootsource."
msgstr "该 |sbc| 具有一个启动配置开关，带有六个可单独切换的开关，用于选择 phyCORE-|soc| 的默认启动源。"

msgid "eMMC (Default SoM boot)"
msgstr "eMMC（核心板的默认启动方式）"

msgid "SPI NOR"
msgstr "SPI NOR"

msgid "USB Serial Download"
msgstr "USB"

msgid "SD Card"
msgstr "SD卡"

msgid "Switch between UART1 RS485/RS232"
msgstr "切换UART1的RS485和RS232模式"

msgid "UART1 RS485"
msgstr "UART1 RS485"

msgid "UART1 RS232"
msgstr "UART1 RS232"

msgid "Flash eMMC"
msgstr "烧写eMMC"

msgid "For consistency, it is assumed that a TFTP server is configured; More importantly, all generated images, as listed above, are copied to the default /srv/tftp directory. If you do not have this set up, you need to adjust the paths that point to the images being used in the instructions. For instructions on how to set up the TFTP server and directory, see |ref-setup-network-host|."
msgstr "为了保持文档的一致性和简洁性，假设已经配置好了TFTP服务器；所有生成的镜像（如上所列）都被复制到默认的/srv/tftp目录。如果您没有进行设置，您需要修改路径到包含镜像的目录。有关如何设置TFTP服务器和目录的说明，请参见 |ref-setup-network-host| 。"

msgid "To boot from eMMC, make sure that the BSP image is flashed correctly to the eMMC and the |ref-bootswitch| is set to **eMMC**."
msgstr "要从 eMMC 启动，请确保 BSP 镜像已正确烧写到 eMMC，并且 |ref-bootswitch| 设置为 **eMMC**。"

msgid "When eMMC and SD card are flashed with the same (identical) image, the UUIDs of the boot partitions are also identical. If the SD card is connected when booting, this leads to non-deterministic behavior as Linux mounts the boot partition based on UUID."
msgstr "当eMMC和SD卡上烧录了相同（完全一致）的镜像时，他们boot分区的UUID也是相同的。所以如果从emmc启动时，烧录一致镜像的SD卡也同时存在，这会导致不确定的后果，因为Linux会根据UUID来挂载启动分区。"

msgid "can be run to inspect whether the current setup is affected. If ``mmcblk2p1`` and ``mmcblk1p1`` have an identical UUID, the setup is affected."
msgstr "可以运行上述命令来检查系统启动在这种条件下是否会到影响。如果 ``mmcblk2p1`` 和 ``mmcblk1p1`` 具有相同的UUID，则会影响系统正确启动。"

msgid "Flash eMMC from Network"
msgstr "从网络烧写 eMMC"

msgid "|soc| boards have an Ethernet connector and can be updated over a network. Be sure to set up the development host correctly. The IP needs to be set to 192.168.3.10, the netmask to 255.255.255.0, and a TFTP server needs to be available. From a high-level point of view, an eMMC device is like an SD card. Therefore, it is possible to flash the **WIC image** (``<name>.wic``) from the Yocto build system directly to the eMMC. The image contains the bootloader, kernel, device tree, device tree overlays, and root file system."
msgstr "|soc| 开发板具有以太网连接器，可以通过网络进行更新。确保正确设置主机，主机的IP需要设置为192.168.3.10，子网掩码为255.255.255.0，并且需要在主机开启TFTP服务。抽象来看，eMMC设备和SD卡十分类似。因此，可以直接将Yocto生成的 **WIC镜像** （ ``<name>.wic`` ）直接烧写到eMMC。该镜像包含bootloader、内核、设备树、设备树overlay和根文件系统。"

msgid "Flash eMMC via Network in Linux on Host"
msgstr "在Linux主机上通过网络烧写 eMMC"

msgid "It is also possible to install the OS at eMMC from your Linux host. As before, you need a complete image on your host."
msgstr "可以在您的Linux主机上将镜像烧写到eMMC。和之前一样，您需要在主机上准备一个完整的镜像。"

msgid "A working network is necessary! |ref-setup-network-host|"
msgstr "需要保证设备和存储镜像的主机之间的网络正常！ |ref-setup-network-host|"

msgid "Show your available image files on the host:"
msgstr "查看主机上可用的镜像文件："

msgid "Send the image with the ``bmaptool`` command combined with ssh through the network to the eMMC of your device:"
msgstr "通过网络ssh协议使用 ``bmaptool`` 命令将镜像发送到开发板的eMMC："

msgid "Flash eMMC via Network in Linux on Target"
msgstr "在开发板的Linux系统中通过网络烧写eMMC"

msgid "You can update the eMMC from your target."
msgstr "您可以在开发板系统中更新eMMC。"

msgid "Take a compressed or decompressed image with the accompanying block map file `*.bmap` on the host and send it with `ssh` through the network to the eMMC of the target with a one-line command:"
msgstr "使用以下命令，通过网络将压缩或未压缩的镜像和配套的 `*.bmap` 文件传送到核心板并写入 eMMC："

msgid "Flash eMMC from Network in U-Boot on Target"
msgstr "在开发板的U-Boot中通过网络烧写eMMC"

msgid "These steps will show how to update the eMMC via a network."
msgstr "这些步骤将展示如何通过网络更新eMMC。"

msgid "This step only works if the size of the image file is less than 1GB due to limited usage of RAM size in the Bootloader after enabling OPTEE."
msgstr "此步骤仅在镜像文件小于1GB的情况下会被执行成功，因为在启用OPTEE后，Bootloader中可用的RAM大小有限，不足以加载超过1GB的镜像"

msgid "Uncompress your image"
msgstr "解压缩您的镜像"

msgid "Load your image via network to RAM:"
msgstr "通过网络将您的镜像加载到内存中："

msgid "when using dhcp"
msgstr "使用DHCP"

msgid "when using a static ip address (serverip and ipaddr must be set additionally)."
msgstr "使用静态IP地址（必须先设置serverip和ipaddr）。"

msgid "Write the image to the eMMC:"
msgstr "将镜像写入eMMC："

msgid "Flash eMMC U-Boot image via Network from running U-Boot"
msgstr "在运行的U-Boot中通过网络烧写eMMC U-Boot镜像"

msgid "Update the standalone U-Boot image imx-boot is also possible from U-Boot. This can be used if the bootloader on eMMC is located in the eMMC user area."
msgstr "可以在U-Boot中更新U-Boot镜像imx-boot，eMMC上的U-Boot需要位于eMMC的user区域。"

msgid "Load image over tftp into RAM and then write it to eMMC:"
msgstr "通过tftp将镜像加载到RAM中，然后写入eMMC："

msgid "The hexadecimal value represents the offset as a multiple of 512 byte blocks. See the `offset table <#offset-table>`__ for the correct value of the corresponding SoC."
msgstr "十六进制值表示偏移量，单位为512字节块的倍数。请参阅 `偏移表 <#offset-table>`__ 以获取相应SoC的正确值。"

msgid "Flash eMMC from USB stick"
msgstr "从USB大容量存储设备烧写eMMC"

msgid "Flash eMMC from USB in Linux"
msgstr "在运行的Linux系统中从USB烧写eMMC"

msgid "These steps will show how to flash the eMMC on Linux with a USB stick. You only need a complete image saved on the USB stick and a bootable WIC image. (e.g. |yocto-imagename|-|yocto-machinename|.|yocto-imageext|). Set the |ref-bootswitch| to SD Card."
msgstr "下面这些步骤展示如何在Linux系统上使用USB大容量存储设备烧写eMMC。您需要一个保存了完整镜像的U盘和一个可从SD卡启动的核心板。（例如： |yocto-imagename|-|yocto-machinename|.|yocto-imageext| ）。将 |ref-bootswitch| 设置为SD卡。"

msgid "Insert and mount the USB stick:"
msgstr "插入并挂载U盘："

msgid "Now show your saved image files on the USB Stick:"
msgstr "现在查看您在USB优盘上保存的镜像文件："

#, fuzzy
msgid "Write the image to the |som| eMMC (MMC device 2 without partition):"
msgstr "将镜像写入 phyCORE-|soc| eMMC（无分区的 MMC 设备 2）："

msgid "After a complete write, your board can boot from eMMC."
msgstr "在完成写入后，您的开发板可以从eMMC启动。"

msgid "Before this will work, you need to configure the |ref-bootswitch| to **eMMC**."
msgstr "在此之前，您需要将 |ref-bootswitch| 配置为 **eMMC**。"

msgid "Flash eMMC from USB stick in U-Boot on Target"
msgstr "在开发板上通过U-Boot从USB烧写eMMC"

msgid "These steps will show how to update the eMMC via a USB device. Configure the |ref-bootswitch| to SD Card and insert an SD card. Power on the board and stop in U-Boot prompt. Insert a USB device with the copied uncompressed WIC image to the USB slot."
msgstr "下面这些步骤展示如何通过USB设备更新eMMC。将 |ref-bootswitch| 配置为SD卡并插入SD卡。给开发板上电并进入U-Boot环境。将已存储了未压缩WIC镜像的优盘插入开发板USB接口。"

msgid "Load your image from the USB device to RAM:"
msgstr "将镜像从USB设备加载到RAM中："

msgid "Flash eMMC from SD Card"
msgstr "从SD卡烧写eMMC"

msgid "Even if there is no network available, you can update the eMMC. For that, you only need a ready-to-use image file (``*.wic``) located on the SD card. Because the image file is quite large, you have to create a third partition. To create a new partition or enlarge your SD card, see |ref-format-sd|."
msgstr "即使没有可用的网络，您也可以更新eMMC。为此，您需要一个位于SD卡上的镜像文件（ ``*.wic`` ）。由于镜像文件相当大，您需要在SD卡创建第三个分区。要创建新分区或扩展您的SD卡，请参见 |ref-format-sd| 。"

msgid "Alternatively, flash a partup package to the SD card, as described in |ref-getting-started|. This will ensure the full space of the SD card is used."
msgstr "或者，使用partup包烧写SD卡，如 |ref-getting-started| 中所述。这样就可使用SD卡的全部容量。"

msgid "Flash eMMC from SD card in Linux on Target"
msgstr "在开发板的linux环境中通过SD卡烧写eMMC"

msgid "You can also flash the eMMC on Linux. You only need a partup package or WIC image saved on the SD card."
msgstr "您也可以在Linux系统中烧写eMMC。您只需要一个partup包或保存在SD卡上的WIC镜像。"

msgid "Show your saved partup package or WIC image files on the SD card:"
msgstr "检查在SD卡上保存的partup包或WIC镜像文件："

#, fuzzy
msgid "Write the image to the |som| eMMC (MMC device 2 **without** partition) using `partup`_:"
msgstr "使用 `partup`_ 将镜像写入 phyCORE-|soc| 的 eMMC（MMC 设备 2 **不带** 分区字样）："

msgid "Flashing the partup package has the advantage of using the full capacity of the eMMC device, adjusting partitions accordingly."
msgstr "使用partup烧写的优点是可以充分利用eMMC设备的全部容量，会相应自动调整分区大小。"

msgid "Alternatively, ``bmaptool`` may be used instead:"
msgstr "另外，也可以使用 ``bmaptool`` 工具："

msgid "Keep in mind that the root partition does not make use of the full space when flashing with ``bmaptool``."
msgstr "请注意，在使用 ``bmaptool`` 烧写时，根文件系统分区并不会使用eMMC的最大容量。"

msgid "Before this will work, you need to configure the |ref-bootswitch| to eMMC."
msgstr "在此之前，您需要将 |ref-bootswitch| 配置为 eMMC。"

msgid "Flash eMMC from SD card in U-Boot on Target"
msgstr "在开发板的uboot环境中通过SD卡烧写eMMC"

msgid "This step only works if the size of the image file is less than 1GB due to limited usage of RAM size in the Bootloader after enabling OPTEE. If the image file is too large use the `Updating eMMC from SD card in Linux on Target` subsection."
msgstr "此步骤仅在镜像文件大小小于1GB的情况下有效，因为在启用OPTEE后，Bootloader中可用的RAM大小有限。如果镜像文件过大，请阅读 `在开发板上通过SD卡更新eMMC` 一节"

msgid "Flash an SD card with a working image and create a third ext4 partition. Copy the WIC image (for example |yocto-imagename|.rootfs.wic) to this partition."
msgstr "将一个可用的镜像烧写到SD卡，并创建一个EXT4格式的第三分区。将WIC镜像（例如 |yocto-imagename|.rootfs.wic）复制到该分区。"

msgid "Configure the |ref-bootswitch| to SD Card and insert the SD Card."
msgstr "将 |ref-bootswitch| 配置为 SD 卡并插入 SD 卡。"

msgid "Power on the board and stop in U-Boot."
msgstr "打开电源并进入U-Boot。"

msgid "Load the image:"
msgstr "加载镜像："

msgid "Switch the mmc dev to eMMC:"
msgstr "将当前mmc设备切换到eMMC："

msgid "Flash your WIC image (for example |yocto-imagename|.rootfs.wic) from the SD card to eMMC. This will partition the card and copy imx-boot, Image, dtb, dtbo, and root file system to eMMC."
msgstr "将您的WIC镜像（例如 |yocto-imagename|.rootfs.wic）从SD卡烧写到eMMC。这将对emmc进行分区，并将imx-boot、Image、dtb、dtbo和根文件系统复制到eMMC。"

msgid "Power off the board and change the |ref-bootswitch| to eMMC."
msgstr "关闭电源并将 |ref-bootswitch| 更改为 eMMC。"

msgid "Flash SPI NOR Flash"
msgstr "烧写 SPI NOR Flash"

msgid "The |som| modules are optionally equipped with SPI NOR Flash. To boot from SPI Flash, set |ref-bootswitch| to **SPI NOR**. The SPI Flash is usually quite small. The phyBOARD-Pollux-i.MX8MP kit only has 32MB SPI NOR flash populated. Only the bootloader and the environment can be stored. The kernel, device tree, and file system are taken from eMMC by default."
msgstr "|som| 模块可选配SPI NOR Flash。要从SPI Flash启动，请将 |ref-bootswitch| 设置为 **SPI NOR** 。SPI Flash通常比较小。phyBOARD-Pollux-i.MX8MP开发套件仅配备32MB的SPI NOR Flash。只能存储bootloader及其环境变量。默认情况下，内核、设备树和文件系统会从eMMC加载。"

msgid "The SPI NOR flash partition table is defined in the U-Boot environment. It can be printed with:"
msgstr "SPI NOR Flash分区表在U-Boot环境变量中定义。可以通过以下命令打印："

msgid "Flash SPI NOR Flash from Network"
msgstr "通过网络烧写SPI NOR Flash"

#, fuzzy
msgid "The SPI NOR can contain the bootloader and environment to boot from. The arm64 kernel can not decompress itself, the image size extends the SPI NOR flash populated on the |som|."
msgstr "SPI NOR可以包含bootloader及其环境变量。arm64的linux内核无法自行解压缩，内核镜像大小超出了phyCORE-|soc| 上的SPI NOR Flash的容量。"

msgid "Flash SPI NOR from Network in kernel on Target"
msgstr "在开发板linux环境中通过网络烧写SPI NOR Flash"

msgid "Copy the image from the host to the target:"
msgstr "将镜像从主机复制到开发板："

msgid "Find the number of blocks to erase of the U-boot partition:"
msgstr "查找要擦除的U-boot分区的块数："

msgid "Erase the U-Boot partition and flash it:"
msgstr "擦除U-Boot分区并烧写："

msgid "Flash SPI NOR from Network in U-Boot on Target"
msgstr "在开发板的U-Boot环境中通过网络烧写SPI NOR"

msgid "Similar to updating the eMMC over a network, be sure to set up the development host correctly. The IP needs to be set to 192.168.3.10, the netmask to 255.255.255.0, and a TFTP server needs to be available. Before reading and writing is possible, the SPI NOR flash needs to be probed:"
msgstr "类似于通过网络更新eMMC，请确保正确设置主机PC。IP地址需要设置为192.168.3.10，子网掩码设置为255.255.255.0，并且需要有一个可用的TFTP服务。在进行读写之前，需要对SPI NOR Flash进行枚举："

msgid "A specially formatted U-Boot image for the SPI NOR flash is used. Ensure you use the correct image file. Load the image over tftp, erase and write the bootloader to the flash:"
msgstr "SPI NOR Flash需要使用特殊格式的U-Boot镜像。确保您使用了正确的镜像文件。通过tftp加载镜像，然后将bootloader写入Flash："

msgid "Erase the environment partition as well. This way, the environment can be written after booting from SPI NOR flash:"
msgstr "同时需要擦除环境分区。这样，环境变量可以在从SPI NOR Flash启动后写入："

msgid "Flash SPI NOR Flash from SD Card"
msgstr "从SD卡烧写SPI NOR Flash"

msgid "The bootloader on SPI NOR flash can be also flashed with SD Card."
msgstr "SPI NOR Flash上的bootloader也可以通过SD卡进行烧写。"

msgid "Flash SPI NOR from SD Card in kernel on Target"
msgstr "在开发板的linux环境中从SD卡烧写SPI NOR"

msgid "Copy the SPI NOR flash U-boot image imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi to the first partition on the SD Card."
msgstr "将SPI NOR Flash的U-boot镜像imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi复制到SD卡的第一个分区。"

msgid "Mount the SD Card:"
msgstr "挂载SD卡："

msgid "Find the number of blocks to erase of the U-Boot partition:"
msgstr "查找要擦除的U-Boot分区的块数："

msgid "Erase the u-boot partition and flash it:"
msgstr "擦除u-boot分区并烧写："

msgid "Flash SPI NOR from SD Card in U-Boot on Target"
msgstr "在开发板的U-Boot环境中从SD卡烧写SPI NOR"

msgid "Before reading and writing are possible, the SPI-NOR flash needs to be probed:"
msgstr "在进行读写操作之前，需要对SPI-NOR Flash进行枚举："

msgid "A specially formatted U-boot image for the SPI NOR flash is used. Ensure you use the correct image file. Load the image from the SD Card, erase and write the bootloader to the flash:"
msgstr "SPI NOR Flash需要使用特殊格式的U-Boot镜像，请确保使用正确的镜像文件。从SD卡加载镜像，擦除并将bootloader写入flash："

msgid "RAUC"
msgstr "RAUC"

msgid "The RAUC (Robust Auto-Update Controller) mechanism support has been added to meta-ampliphy. It controls the procedure of updating a device with new firmware. This includes updating the Linux kernel, Device Tree, and root filesystem. PHYTEC has written an online manual on how we have intergraded RAUC into our BSPs: |rauc-manual|_."
msgstr "BSP支持RAUC（Robust Auto-Update Controller）。它管理设备固件更新的过程。这包括更新Linux内核、设备树和根文件系统。PHYTEC已撰写了一份在线手册，介绍如何在我们的BSP中集成RAUC： |rauc-manual|_ 。"

msgid "EFI Boot"
msgstr "EFI 启动"

msgid "Standardboot in U-Boot also supports booting distros over efi. By default the U-Boot will search for a bootscript first, which is used to boot our Ampliphy distro. If it does not find any bootscript, it will search for bootable efi applications. So for booting over efi just make sure you don't have our distro installed."
msgstr "U-boot也支持通过efi启动核心板。U-boot会默认先搜寻一个启动脚本，然后使用该脚本启动Ampliphy发行版。如果未搜索出该启动脚本，将会启动efi例程。所以，通过efi启动前，需要确认您并没有安装我们的发行版。"

msgid "Disable booting with efi"
msgstr "关闭efi启动"

msgid "To disable booting with efi you have to set the ``doefiboot`` variable to 0. Also make sure you do not have ``efi`` or ``efi_mgr`` specified in the ``bootmeths`` environment variable."
msgstr "要关闭efi启动，需要将 ``doefiboot`` 变量设置为0.并且确认您没有在 ``bootmeths`` 环境变量中定义 ``efi`` 或者 ``efi_mgr`` "

msgid "Switch to only efi boot"
msgstr "切换efi启动模式"

msgid "If you want to only boot with efi, you can set the ``bootmeths`` environment variable to efi. Also make sure you have the ``doefiboot`` environment variable set to 1."
msgstr "如果您想要通过efi启动，可以设置 ``bootmeths`` 环境变量到efi。同时将 ``doefiboot`` 环境变量值配置为1。"

msgid "Installing a distro"
msgstr "安装操作系统"

msgid "With efi you can install and boot different distros like openSUSE, Fedora or Debian. First you have to get the iso Image from their website. For example:"
msgstr "使用efi可以安装、启动不同的linux发行版，如openSUSE, Fedora以及Debian。首先你需要从它们的官方网站下载iso镜像，如："

msgid "https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/"
msgstr "https://cdimage.debian.org/debian-cd/current/arm64/iso-dvd/"

msgid "Then copy the .iso file to a usb stick for example. Make sure you select the correct device:"
msgstr "然后复制.iso文件到比如U盘。请确认输入了正确的设备名："

msgid "Insert the USB stick into the board and boot it. GRUB will then prompt you with a menu where you can select what to do. Here select install. Then you have to click through the installation menu. This is relatively straightforward and differs a bit for every distro. You can install the distro for example to emmc (|emmcdev-uboot|) or sdcard (|sdcarddev-uboot|). Make sure you do not overwrite your U-Boot during the install. Best to choose a different medium to install to than the U-Boot is stored on. Otherwise manual partitioning will be required. The automatic partitioning will start at the beginning of the disk. To not overwrite the U-Boot, use an offset of 4MiB at the beginning of the disk."
msgstr "将U盘插入板并启动。GRUB会用菜单提示接下来做什么。这里选择安装。然后按照向导操作。这个过程很直接，不同的发行版可能有些区别。你可以将发行版安装在emmc (|emmcdev-uboot|) 或sd卡 (|sdcarddev-uboot|)。 确保在安装时不要覆盖u-boot。最好是和uboot选择不同的存储器件，否则需要手工分区。 自动分区会从硬盘的头部开始分区， 为了避免覆盖u-boot， 使用从硬盘头部4MiB的偏移量后的区域。"

msgid "During the Installation of Debian you will be asked, if you want to Force the GRUB installation to the EFI removable media path. Select no. Also select no, when you will be asked if you want to update the NVRAM variables. Otherwise the grub-dummy installation step will fail and you will be sent back to the \"Force GRUB installation\" prompt."
msgstr "在安装Debian时会被问，你是否想要强制安装GRUB到EFI可移动存储路径。 选择不。 当被问倒你是否要更新NVRAM变量，也选择不。 否则grub-dummy安装步骤会失败，并且会退回倒 \"强制GRUB安装\" 提示界面。"

msgid "After the installation is complete, reboot the board and remove the installation medium (USB-stick). The board should then boot the distro you installed."
msgstr "在安装完成后，重新启动设备并移除安装介质（U盘）。设备会启动刚刚安装的发行版系统。"

msgid "If that does not happen, check if there is a boot option set for the distro. The easiest way is with the ``eficonfig`` command."
msgstr "如果启动失败，请检查启动选项是否设置了该发行版。最简单的方法是使用 ``eficonfig`` 命令。"

msgid "That will open a menu. Then you can select ``Edit Boot Option``. It will show you the current boot options. If this is empty or you don't find your distro, select ``Add Boot Option`` to add a new one. For debian for example you only need to set the description and the file. You can enter whatever you want into the description field. When you select the file field, you can select the disc you installed the distro on and partition number one. For example \"|emmcdev-uboot|:1\" for emmc, or \"|sdcarddev-uboot|:1\" for sdcard. The file you need to select is at ``EFI/debian/grubaa64.efi``. After that save, quit and reset the board. The board should then boot into debian."
msgstr "这将打开一个菜单。然后你可以选择 ``Edit Boot Option`` 。它会显示当前的启动选项。如果这是空的或者找不到你的发行版，选择 ``Add Boot Option`` 以添加一个新的选项。例如对于debian，你只需要设置描述和文件。你可以随意输入描述字段中的内容。当你选择文件字段时，可以选择安装发行版的磁盘和第一个分区。例如eMMC \"|emmcdev-uboot|:1\" ，或SD卡 \"|sdcarddev-uboot|:1\" 。你需要选择的文件位于 ``EFI/debian/grubaa64.efi`` 。之后保存，退出并重置板子。板子应该会启动进入debian。"

msgid "Development"
msgstr "开发"

msgid "Starting with this release, the boot behaviour in U-Boot changes. Before, kernel and device tree came as separate blobs. Now, both will be included in a single FIT image blob. Further, the logic for booting the PHYTEC ampliphy distributions is moved to a boot script which itself is part of a separate FIT image blob. To revert to the old style of booting, you may do"
msgstr "从这个版本开始，U-Boot中的启动行为发生了变化。之前，内核和设备树是作为单独的二进制文件提供的。现在，二者将被包含在一个单一的FIT镜像二进制文件中。此外，PHYTEC ampliphy发行版的启动逻辑被移到了一个启动脚本中，该脚本是以FIT镜像二进制文件的一部分存在。要恢复到旧的启动方式，您可以执行"

msgid "This way of booting is deprecated and will be removed in the next release. By default, booting via this command will return an error as kernel and device tree are missing in the boot partition."
msgstr "这种启动方式已被弃用，并将在下一个版本中移除。默认情况下，通过此命令启动将返回错误，因为启动分区中缺少内核和设备树。"

msgid "Standalone Build preparation"
msgstr "独立编译准备"

msgid "In this section, we describe how to build the U-Boot and the Linux kernel without using the `Yocto Project <https://www.yoctoproject.org/>`__. This procedure makes the most sense for development. The U-Boot source code, the Linux kernel, and all other git repositories are available on our `Git server <https://git.phytec.de/>`__ at git://git.phytec.de."
msgstr "在本节中，我们将描述如何在不使用 `Yocto Project <https://www.yoctoproject.org/>`__ 的情况下编译 U-Boot 和 Linux kernel。U-Boot、Linux kernel以及其他源码的 git 仓库都可以在我们的 `Git 服务器 <https://git.phytec.de/>`__ 上找到，地址为 git://git.phytec.de。"

msgid "Should your company firewall/gateway inhibit the git protocol, you may use HTTP or HTTPS instead (e.g. git clone |u-boot-repo-url|)"
msgstr "如果您的公司防火墙/网关禁止git协议，您可以改用HTTP或HTTPS（例如：git clone |u-boot-repo-url|）"

msgid "Git Repositories"
msgstr "Git 仓库"

msgid "Used U-Boot repository:"
msgstr "使用的 U-Boot 仓库："

msgid "Our U-Boot is based on the |u-boot-repo-name| and adds board-specific patches."
msgstr "我们的U-Boot基于 |u-boot-repo-name| 并添加了一些硬件相关的补丁。"

msgid "Used Linux kernel repository:"
msgstr "使用的 Linux 内核仓库："

msgid "Our |soc| kernel is based on the |kernel-repo-name| kernel."
msgstr "我们的 |soc| 内核是基于 |kernel-repo-name| 内核。"

msgid "To find out which u-boot and kernel tags to use for a specific board, have a look at your BSP source folder:"
msgstr "要找出核心板应使用的u-boot和kernel版本对应的git仓库tag标签，请查看您的BSP源文件夹："

msgid "Get the SDK"
msgstr "获取SDK"

msgid "You can download the SDK `here <dl-sdk_>`_, or build it yourself with Yocto:"
msgstr "您可以在此处下载SDK `这里 <dl-sdk_>`_，或者使用Yocto去编译生成SDK："

msgid "Move to the Yocto build directory:"
msgstr "移动到Yocto的build目录："

msgid "After a successful build the SDK installer is deployed to ``build/deploy*/sdk``."
msgstr "在成功编译后，SDK安装包保存在  ``build/deploy*/sdk``。"

msgid "Install the SDK"
msgstr "安装SDK"

msgid "Set correct permissions and install the SDK:"
msgstr "设置正确的权限并安装SDK："

msgid "Using the SDK"
msgstr "使用SDK"

msgid "Activate the toolchain for your shell by sourcing the *environment-setup* file in the toolchain directory:"
msgstr "通过在工具链目录中source *environment-setup* 文件来初始化您的 shell 交叉编译环境："

msgid "Installing Required Tools"
msgstr "安装所需工具"

msgid "Building Linux and U-Boot out-of-tree requires some additional host tool dependencies to be installed. For Ubuntu you can install them with:"
msgstr "独立编译Linux kernel和U-Boot需要主机安装一些额外的工具。对于Ubuntu，您可以使用以下命令安装它们："

msgid "Using the SDK on older host distributions (e.g., Ubuntu 20.04 LTS) with Scarthgap NXP-based BSPs can cause issues when building U-Boot or Linux kernel tools for host use. If you encounter an \"undefined reference\" error, a workaround is to prepend the host's binutils to the PATH."
msgstr "在较旧的主机发行版（例如，Ubuntu 20.04 LTS）上使用Scarthgap NXP基础的BSP时，构建用于主机的U-Boot或Linux内核工具可能会出现问题。如果遇到 \"undefined reference\" 错误，一种解决方法是在PATH环境变量中添加主机的binutils。"

msgid "Run this after sourcing the SDK *environment-setup* file."
msgstr "在加载SDK *environment-setup* 后，运行此命令。"

msgid "Note, SDK issue has not been observed on newer distributions, such as Ubuntu 22.04, which appear to work without requiring any modifications."
msgstr "请注意，在较新版本的发行版（如Ubuntu 22.04）中未观察到SDK相关问题，这些发行版似乎无需任何修改即可正常工作。"

msgid "U-Boot standalone build"
msgstr "单独编译U-Boot"

msgid "Get the source code"
msgstr "获取源代码"

msgid "Get the U-Boot sources:"
msgstr "获取U-Boot源代码："

msgid "To get the correct *U-Boot* **tag** you need to take a look at our release notes, which can be found here: `release notes <releasenotes_>`_"
msgstr "要获取正确的 *U-Boot* **tag**，您需要查看我们的release notes，可以在这里找到：`release notes <releasenotes_>`_"

msgid "The **tag** used in this release is called |u-boot-tag|"
msgstr "此版本中使用的 **tag** 称为 |u-boot-tag|"

msgid "Check out the needed *U-Boot* **tag**:"
msgstr "查看所需的 *U-Boot* **tag**："

msgid "Set up a build environment:"
msgstr "设置编译环境："

msgid "Get the needed binaries"
msgstr "获取所需的二进制文件"

msgid "To build the bootloader, you need to **copy** these **files** to your |u-boot-repo-name| **build directory** and rename them to fit with *mkimage* script:"
msgstr "要编译bootloader，您需要将这些文件复制到您的 |u-boot-repo-name| 编译目录，并将其重命名以适应 *mkimage* 脚本："

msgid "**ARM Trusted firmware binary** (*mkimage tool* compatible format **bl31.bin**): bl31-|kernel-socname|.bin"
msgstr "**ARM Trusted firmware 二进制文件** （ *mkimage 工具*  兼容格式 **bl31.bin** ）：bl31-|kernel-socname|.bin"

msgid "**OPTEE image** (optional): tee.bin"
msgstr "**OPTEE 镜像** (可选的)：tee.bin"

msgid "**DDR firmware files** (*mkimage tool* compatible format **lpddr4_[i,d]mem_\\*d_\\*.bin**): lpddr4_dmem_1d_*.bin, lpddr4_dmem_2d_*.bin, lpddr4_imem_1d_*.bin, lpddr4_imem_2d_*.bin"
msgstr "**DDR firmware files** ( *mkimage 工具* 兼容格式 **lpddr4_[i,d]mem_\\*d_\\*.bin** ): lpddr4_dmem_1d_*.bin, lpddr4_dmem_2d_*.bin, lpddr4_imem_1d_*.bin, lpddr4_imem_2d_*.bin"

msgid "If you already built our BSP with Yocto, you can get the bl31-|kernel-socname|.bin, tee.bin and lpddr4_*.bin from the directory mentioned here: |ref-bsp-images|"
msgstr "如果您已经使用Yocto编译了我们的BSP，您可以在yocto工程目录中获取 bl31-|kernel-socname|.bin、tee.bin和lpddr4_*.bin：|ref-bsp-images|"

msgid "Or you can download the files here: |link-boot-tools|"
msgstr "或者你可以在这里下载文件： |link-boot-tools|"

msgid "Make sure you rename the files you need so that they are compatible with the *mkimage tool*."
msgstr "确保您重命名所需的文件，以和 *mkimage tool* 兼容。"

msgid "Build the bootloader"
msgstr "编译bootloader"

msgid "build flash.bin (imx-boot):"
msgstr "编译 flash.bin (imx-boot):"

msgid "Flash the bootloader to a block device"
msgstr "将bootloader烧写到块设备上"

msgid "The flash.bin can be found at |u-boot-repo-name|/ directory and now can be flashed. A chip-specific offset is needed:"
msgstr "flash.bin 文件可以在 |u-boot-repo-name|/ 目录下找到，现在可以进行烧写。需要指定芯片特定的偏移量："

msgid "SoC"
msgstr "SoC"

msgid "Offset User Area"
msgstr "User分区偏移量"

msgid "Offset Boot Partition"
msgstr "Boot分区偏移量"

msgid "eMMC Device"
msgstr "eMMC设备"

msgid "|soc|"
msgstr "|soc|"

#, fuzzy
msgid "|bootloader-offset| kiB"
msgstr "|u-boot-offset| kiB"

#, fuzzy
msgid "|bootloader-offset-boot-part| kiB"
msgstr "|u-boot-offset-boot-part| kiB"

msgid "/dev/|emmcdev|"
msgstr "/dev/|emmcdev|"

msgid "E.g. flash SD card:"
msgstr "例如，烧写SD卡："

msgid "The specific offset values are also declared in the Yocto variables \"BOOTLOADER_SEEK\" and \"BOOTLOADER_SEEK_EMMC\""
msgstr "如果您有我们的BSP Yocto工程代码，具体的偏移值也会在Yocto变量\"BOOTLOADER_SEEK\"和\"BOOTLOADER_SEEK_EMMC\"中声明。"

msgid "Build U-Boot With a Fixed RAM Size"
msgstr "使用固定内存大小编译U-Boot"

msgid "If you cannot boot your system anymore because the hardware introspection in the EEPROM is damaged or deleted, you can create a flash.bin with a fixed ram size. You should still contact support and flash the correct EEPROM data, as this could lead to unexpected behavior."
msgstr "如果您的系统因为EEPROM中的硬件信息损坏或丢失而无法启动，您可以创建一个具有固定RAM大小的flash.bin。但您仍应联系我们支持部门以烧写正确的EEPROM数据。"

msgid "Follow the steps to get the U-boot sources and check the correct branch in the **Build U-Boot** section."
msgstr "按照步骤获取U-boot源代码，并切换到 **Build U-Boot** 章节说明的分支。"

msgid "Edit the file configs/|u-boot-defconfig|:"
msgstr "编辑文件 configs/|u-boot-defconfig|:"

msgid "Choose the correct RAM size as populated on the board and uncomment the line for this ram size. After saving the changes, follow the remaining steps from |ref-build-uboot|."
msgstr "选择正确的RAM大小，确保与核心板上的贴装的器件一致，取消注释该RAM大小的行。保存更改后，按照 |ref-build-uboot| 章节的剩余步骤进行操作。"

msgid "Kernel standalone build"
msgstr "单独编译内核"

msgid "The kernel is packaged in a FIT image together with the device tree. U-Boot has been adapted to be able to load a FIT image and boot the kernel contained in it. As a result, the kernel Image has to packaged in a FIT image."
msgstr "内核与设备树一起打包在FIT镜像中。U-Boot已被配置为能够加载FIT镜像并引导其中包含的内核。因此，内核镜像必须打包在FIT镜像中。"

msgid "Setup sources"
msgstr "配置源代码"

msgid "The used |kernel-repo-name| branch can be found in the `release notes <releasenotes_>`_"
msgstr "使用的 |kernel-repo-name| 分支可以在 `release notes <releasenotes_>`_ 中找到"

msgid "The tag needed for this release is called |kernel-tag|"
msgstr "此版本所需的标签称为 |kernel-tag|"

msgid "Check out the needed |kernel-repo-name| tag:"
msgstr "Check out 所需的 |kernel-repo-name| 标签："

msgid "For committing changes, it is highly recommended to switch to a new branch:"
msgstr "为了提交更改，强烈建议切换到一个新分支："

msgid "Build the kernel"
msgstr "编译内核"

msgid "Build the linux kernel:"
msgstr "编译Linux内核："

msgid "Install kernel modules to e.g. NFS directory:"
msgstr "安装内核模块，比如安装到 NFS 目录："

msgid "The Image can be found at ~/|kernel-repo-name|/arch/arm64/boot/Image.gz"
msgstr "镜像可以在 ~/|kernel-repo-name|/arch/arm64/boot/Image.gz 找到"

msgid "The dtb can be found at ~/|kernel-repo-name|/arch/arm64/boot/dts/freescale/|dt-carrierboard|.dtb"
msgstr "dtb文件可以在 ~/|kernel-repo-name|/arch/arm64/boot/dts/freescale/|dt-carrierboard|.dtb 找到"

msgid "For (re-)building only Devicetrees and -overlays, it is sufficient to run"
msgstr "要（重新）编译设备树和 -overlay 文件，只需运行"

msgid "If you are facing the following build issue:"
msgstr "如果您遇到以下编译问题："

msgid "Make sure you installed the package *\"libyaml-dev\"* on your host system:"
msgstr "确保您在主机系统上安装了 *\"libyaml-dev\"* 包："

msgid "Package the kernel in a FIT image"
msgstr "将内核打包成FIT镜像"

msgid "To simply replace the kernel, you will need an ``image tree source`` (.its) file. If you already built our BSP with Yocto, you can get the its file from the directory mentioned here: |ref-bsp-images| Or you can download the file here: |link-bsp-images|"
msgstr "要简单地替换内核，您需要一个 ``image tree source`` (.its)文件。如果您已经使用Yocto编译了我们的BSP，可以从此处提到的目录获取its文件： |ref-bsp-images| 或者您可以在这里下载该文件： |link-bsp-images| "

msgid "Copy the .its file to the current working directory, create a link to the kernel image and create the final fitImage with mkimage."
msgstr "将 .its 文件复制到当前工作目录，创建一个指向内核镜像的链接，并使用 mkimage 创建最终的 fitImage。"

msgid "Copy FIT image and kernel modules to SD Card"
msgstr "将FIT镜像和内核模块复制到SD卡"

msgid "When one-time boot via netboot is not sufficient, the FIT image along with the kernel modules may be copied directly to a mounted SD card."
msgstr "FIT镜像以及内核module可以用以下方式复制到已挂载的SD卡上。"

msgid "Working with UUU-Tool"
msgstr "使用UUU工具"

msgid "The Universal Update Utility Tool (UUU-Tool) from NXP is a software to execute on the host to load and run the bootloader on the board through SDP (Serial Download Protocol). For detailed information visit https://github.com/nxp-imx/mfgtools or download the `Official UUU-tool documentation <https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/imx-processors/140261/1/UUU.pdf>`_."
msgstr "NXP的镜像更新工具（UUU-Tool）是一款在主机上运行的软件，用于通过SDP（串行下载协议）在开发板上下载并运行bootloader。有关详细信息，请访问 https://github.com/nxp-imx/mfgtools 或下载 `官方UUU工具文档 <https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/imx-processors/140261/1/UUU.pdf>`_。"

msgid "Host preparations for UUU-Tool Usage"
msgstr "使用UUU工具的准备"

msgid "Follow the instructions from https://github.com/nxp-imx/mfgtools#linux."
msgstr "请按照 https://github.com/nxp-imx/mfgtools#linux 上的说明进行操作。"

msgid "If you built UUU from source, add it to ``PATH``:"
msgstr "如果您要从源代码编译UUU，请将其添加到 ``PATH`` 中："

msgid "This BASH command adds UUU only temporarily to ``PATH``. To add it permanently, add this line to ``~/.bashrc``."
msgstr "这个BASH命令只是暂时将UUU添加到 ``PATH`` 中。要永久添加，请将此行添加到 ``~/.bashrc`` 中。"

msgid "Set udev rules (documented in ``uuu -udev``):"
msgstr "设置udev规则（在 ``uuu -udev`` 中有详细说明）："

msgid "Get Images"
msgstr "获取镜像"

msgid "Download imx-boot from our server or get it from your Yocto build directory at build/deploy-|yocto-distro|/images/|yocto-machinename|/. For flashing a wic image to eMMC, you will also need |yocto-imagename|-|yocto-machinename|.rootfs.wic."
msgstr "从我们的服务器下载imx-boot，或者从您Yocto工程中的build/deploy-|yocto-distro|/images/|yocto-machinename|/路径获取。要将wic镜像烧写到eMMC，你还需要 |yocto-imagename|-|yocto-machinename|.rootfs.wic。"

msgid "Prepare Target"
msgstr "开发板准备"

msgid "Set the |ref-bootswitch| to **USB Serial Download**. Also, connect USB port |ref-usb-otg| to your host."
msgstr "将 |ref-bootswitch| 设置为 **USB串行下载**。同时，将 USB 端口 |ref-usb-otg| 连接到主机。"

msgid "Starting bootloader via UUU-Tool"
msgstr "通过UUU工具启动bootloader"

msgid "Execute and power up the board:"
msgstr "执行并给开发板上电："

msgid "You can see the bootlog on the console via |ref-debugusbconnector|, as usual."
msgstr "您可以像往常一样通过 |ref-debugusbconnector| 在终端上查看启动日志。"

msgid "The default boot command when booting with UUU-Tool is set to fastboot. If you want to change this, please adjust the environment variable bootcmd_mfg in U-boot prompt with setenv bootcmd_mfg. Please note, when booting with UUU-tool the default environment is loaded. Saveenv has no effect. If you want to change the boot command permanently for UUU-boot, you need to change this in U-Boot code."
msgstr "UUU工具使用的默认启动命令为fastboot。如果您想更改此设置，请在U-Boot提示符下使用setenv bootcmd_mfg修改环境变量bootcmd_mfg。但是请注意，当开发板再次使用UUU工具启动时，默认环境变量会被加载，saveenv重启后不生效。如果您想永久的更改U-boot的启动命令，则需要更改U-Boot代码。"

msgid "Flashing U-boot Image to eMMC via UUU-Tool"
msgstr "通过UUU工具将U-boot镜像烧写到eMMC"

msgid "UUU flashes U-boot into eMMC BOOT (hardware) boot partitions, and it sets the BOOT_PARTITION_ENABLE in the eMMC! This is a problem since we want the bootloader to reside in the eMMC USER partition. Flashing next U-Boot version .wic image and not disabling BOOT_PARTITION_ENABLE bit will result in device always using U-boot saved in BOOT partitions. To fix this in U-Boot:"
msgstr "UUU将U-boot刷入eMMC BOOT（硬件）启动分区后，会在eMMC中设置BOOT_PARTITION_ENABLE。这带来一个问题，因为我们希望bootloader保存在eMMC 的USER分区中。如果烧写入新的包含U-boot的.wic镜像而不禁用BOOT_PARTITION_ENABLE位，将导致设备始终使用保存在BOOT分区中的U-boot。为了在U-Boot中解决此问题，需要："

msgid "or check :ref:`Disable booting from eMMC boot partitions <emmc-disable-boot-part>` from Linux."
msgstr "或者在linux中检查 :ref:`用从eMMC boot分区启动 <emmc-disable-boot-part>` "

msgid "This way the bootloader is still flashed to eMMC BOOT partitions but it is not used!"
msgstr "这样bootloader虽然会被烧写到 eMMC 的BOOT分区，但在启动中不会被使用！"

msgid "When using **partup** tool and ``.partup`` package for eMMC flashing this is done by default, which makes partup again superior flash option."
msgstr "在使用 **partup** 工具和 ``.partup`` 包进行eMMC烧写时，上述过程是默认进行的，这是partup的优势，简化烧写过程。"

msgid "Flashing wic Image to eMMC via UUU-Tool"
msgstr "通过UUU工具将wic镜像烧写到eMMC"

msgid "Flashing SPI NOR Flash via UUU-Tool"
msgstr "通过UUU工具烧写SPI NOR Flash"

msgid "This will update the U-Boot on SPI NOR Flash but not the environment. You may need to erase the old environment so the default environment of the new U-Boot gets loaded:"
msgstr "这将更新SPI NOR Flash上的U-Boot，但不会更新环境。您可能需要擦除旧环境，以便加载新U-Boot的默认环境："

msgid "Host Network Preparation"
msgstr "主机网络准备"

msgid "For various tasks involving a network in the Bootloader, some host services are required to be set up. On the development host, a TFTP, NFS and DHCP server must be installed and configured. The following tools will be needed to boot via Ethernet:"
msgstr "为了在bootloader中执行涉及网络的各种任务，需要配置一些主机服务。在开发主机上，必须安装和配置TFTP、NFS和DHCP服务。启动以太网所需的工具如下："

msgid "TFTP Server Setup"
msgstr "TFTP服务设置"

msgid "First, create a directory to store the TFTP files:"
msgstr "首先，创建一个目录来存储TFTP文件："

msgid "Then copy your BSP image files to this directory and make sure other users have read access to all the files in the tftp directory, otherwise they are not accessible from the target."
msgstr "然后将您的BSP镜像文件复制到此目录，并确保other用户也对tftp目录中的所有文件具有读取权限，否则将无法从开发板访问这些文件。"

msgid "You also need to configure a static IP address for the appropriate interface. The default IP address of the PHYTEC evaluation boards is 192.168.3.11. Setting a host address 192.168.3.10 with netmask 255.255.255.0 is a good choice."
msgstr "您还需要为相应的接口配置一个静态IP地址。PHYTEC开发板的默认IP地址是192.168.3.11。可以将主机地址设置为192.168.3.10，子网掩码为255.255.255.0"

msgid "Replace <network-interface> with the network interface you configured and want to connect the board to. You can show all network interfaces by not specifying a network interface."
msgstr "将 <network-interface> 替换为连接到开发板的网络接口。您可以通过不指定网络接口来显示所有可选网络接口。"

msgid "The message you receive should contain this:"
msgstr "返回的结果应包含以下内容："

msgid "Create or edit the ``/etc/default/tftpd-hpa`` file:"
msgstr "创建或编辑 ``/etc/default/tftpd-hpa`` 文件："

msgid "Set TFTP_DIRECTORY to your TFTP server root directory"
msgstr "将 TFTP_DIRECTORY 设置为您的 TFTP 服务器根目录"

msgid "Set TFTP_ADDRESS to the host address the server is listening to (set to 0.0.0.0:69 to listen to all local IPs)"
msgstr "将TFTP_ADDRESS设置为TFTP服务监听的主机地址（设置为0.0.0.0:69以监听69端口上所有IP）。"

msgid "Set TFTP_OPTIONS, the following command shows the available options:"
msgstr "设置 TFTP_OPTIONS，以下命令显示可配置的选项："

msgid "Restart the services to pick up the configuration changes:"
msgstr "重新启动服务以应用配置更改："

msgid "Now connect the ethernet port of the board to your host system. We also need a network connection between the embedded board and the TFTP server. The server should be set to IP 192.168.3.10 and netmask 255.255.255.0."
msgstr "现在将开发板的以太网端口连接到您的主机。我们还需要在开发板和运行TFTP服务的主机之间建立网络连接。TFTP服务器的IP地址应设置为192.168.3.10，子网掩码为255.255.255.0。"

msgid "NFS Server Setup"
msgstr "NFS服务器设置"

msgid "Create an nfs directory:"
msgstr "创建一个NFS目录："

msgid "The NFS server is not restricted to a certain file system location, so all we have to do on most distributions is modify the file ``/etc/exports`` and export our root file system to the embedded network. In this example file, the whole directory is exported and the \"lab network\" address of the development host is 192.168.3.10. The IP address has to be adapted to the local needs:"
msgstr "NFS服务对文件共享的路径没有限制，因此在大多数linux发行版中，我们只需修改文件 ``/etc/exports`` ，并将我们的根文件系统共享到网络。在这个示例文件中，整个目录被共享在主机地址为192.168.3.10的IP地址上。注意这个地址需要根据本地情况进行调整："

msgid "Now the NFS-Server has to read the ``/etc/exportfs`` file again:"
msgstr "现在NFS服务器需要再次读取 ``/etc/exportfs`` 文件："

msgid "DHCP Server setup"
msgstr "DHCP服务器设置"

msgid "Create or edit the ``/etc/kea/kea-dhcp4.conf`` file; Using the internal subnet sample. Replace <network-interface> with the name for the physical network interface:"
msgstr "创建或编辑 ``/etc/kea/kea-dhcp4.conf`` 文件；以内部子网为例，将 <network-interface> 替换为物理网络接口的名称："

msgid "Be careful when creating subnets as this may interfere with the company network policy. To be on the safe side, use a different network and specify that via the ``interfaces`` configuration option."
msgstr "在创建子网时请小心，因为这可能会扰乱公司网络政策。为了安全起见，请使用不同的子网，并通过 ``interfaces`` 配置选项指定该网络。"

msgid "Now the DHCP-Server has to read the ``/etc/kea/kea-dhcp4.conf`` file again:"
msgstr "现在DHCP服务需要重新读取 ``/etc/kea/kea-dhcp4.conf`` 文件："

msgid "When you boot/restart your host PC and don't have the network interface, as specified in the kea-dhcp4 config, already active the kea-dhcp4-server will fail to start. Make sure to start/restart the systemd service when you connect the interface."
msgstr "当您启动/重启主机时，如果kea-dhcp4配置中指定的网络接口未处于活动状态，kea-dhcp4-server将无法启动。因此请确保在连接接口后启动或者重启该systemd服务。"

msgid "Booting the Kernel from a Network"
msgstr "从网络启动内核"

msgid "Booting from a network means loading the kernel and device tree over TFTP and the root file system over NFS. The bootloader itself must already be loaded from another available boot device."
msgstr "从网络启动意味着通过TFTP加载内核和设备树，并通过NFS加载根文件系统。但bootloader需要从另外的的启动设备加载。"

msgid "Place Images on Host for Netboot"
msgstr "在主机上放置网络启动的镜像"

msgid "Copy the kernel fitimage to your tftp directory:"
msgstr "将内核fitimage复制到您的tftp目录中："

msgid "Copy the bootscript to your tftp directory:"
msgstr "将启动脚本复制到您的tftp目录中："

msgid "Make sure other users have read access to all the files in the tftp directory, otherwise they are not accessible from the target:"
msgstr "确保other用户对tftp目录中的所有文件具有读取权限，否则将无法从开发板访问它们："

msgid "Extract the rootfs to your nfs directory:"
msgstr "将根文件系统解压到您的NFS目录中："

msgid "Make sure you extract with sudo to preserve the correct ownership."
msgstr "请确保使用sudo执行命令，以保留根文件系统中文件的所属权限。"

msgid "Set the bootenv.txt for Netboot"
msgstr "设置网络启动的bootenv.txt文件"

msgid "Create a bootenv.txt file in your tftp directory and write the following variables into it."
msgstr "在您的tftp目录中创建一个bootenv.txt文件，并将以下变量写入其中。"

msgid "<overlayconfignames> has to be replaced with the devicetree overlay config names that you want to use. Separate the config names by hashtag. For example:"
msgstr "<overlayconfignames> 替换为您想要使用的设备树overlay配置名称。用#号分隔配置名称。例如："

msgid "All supported devicetree overlays are in the |ref-dt| chapter. Or can be printed with:"
msgstr "所有支持的设备树overlay文件都在 |ref-dt| 章节中。或者可以通过以下命令打印："

msgid "Network Settings on Target"
msgstr "开发板上的网络设置"

msgid "To customize the targets ethernet configuration, please follow the description here: |ref-network|"
msgstr "如果要自定义开发板上的以太网配置，请按照此处的说明进行操作： |ref-network|"

msgid "Booting from an Embedded Board"
msgstr "从开发板启动"

msgid "Boot the board into the U-boot prompt and press any key to hold."
msgstr "将开发板启动到U-boot，按任意键暂停。"

msgid "To boot from a network, call:"
msgstr "要从网络启动，请运行："

msgid "Accessing the Development states"
msgstr "获取BSP开发中版本"

msgid "Development state of current release"
msgstr "当前release的开发中版本"

msgid "These release manifests exist to give you access to the development states of the *Yocto* BSP. They will not be displayed in the phyLinux selection menu but need to be selected manually. This can be done using the following command line:"
msgstr "这些release manifest文件是为了让您访问 *Yocto* BSP的开发版本。它们不会在phyLinux选择菜单中显示，需要手动选择。可以使用以下命令行来完成此操作："

msgid "This will initialize a BSP that will track the latest development state of the current release (|yocto-manifestname|). From now on *repo sync* in this folder will pull all the latest changes from our Git repositories:"
msgstr "这将初始化一个BSP，用于跟踪当前版本（ |yocto-manifestname| ）的最新开发版本。从现在开始，在此文件夹中执行 *repo sync* 将从我们的Git仓库中拉取所有最新的更改："

msgid "Development state of upcoming release"
msgstr "即将发布版本的开发中版本"

msgid "Also development states of upcoming releases can be accessed this way. For this execute the following command and look for a release with a higher PDXX.Y number than the latest one (|yocto-manifestname|) and ``.y`` at the end:"
msgstr "即将发布版本的开发中版本可以通过这种方式访问。请执行以下命令，并查找一个比最新版本（ |yocto-manifestname| ）的PDXX.Y数字更高的版本，并且以 ``.y`` 结尾："

msgid "Accessing the Latest Upstream Support"
msgstr "获取最新的Upstream支持"

msgid "We have a vanilla manifest that makes use of the Yocto master branches (not an NXP release), Linux, and U-Boot. This can be used to test the latest upstream kernel/U-Boot."
msgstr "我们有一个使用Yocto主分支（不是NXP发布的）的manifest，他使用upstream的Linux和U-Boot。这可以用来测试最新的upstream kernel/U-Boot。"

msgid "The master manifest reflects the latest state of development. This tends to be broken from time to time. We try to fix the master on a regular basis."
msgstr "master分支的manifest反映了最新的开发状态。有时会出现一些bug。我们会定期修复master分支。"

msgid "Format SD-Card"
msgstr "格式化SD卡启动盘以允许通过SD卡进行烧录"

msgid "Most images are larger than the default root partition. To flash any storage device with SD Card, the rootfs needs to be expanded or a separate partition needs to be created. There are some different ways to format the SD Card.  The easiest way to do this is to use the UI program Gparted."
msgstr "使用单一的SD卡启动盘对存储介质进行烧写是开发过程中的常见任务。本章节针对此场景提供基础说明。大多数镜像的大小超过了默认的root分区剩余容量。要使用SD卡进行烧写，根文件系统需要扩展或创建一个单独的分区。有几种不同的方法可以格式化SD卡。最简单的方法是使用Gparted。"

msgid "Gparted"
msgstr "Gparted"

msgid "Get GParted:"
msgstr "获取 GParted："

msgid "Insert the SD Card into your host and get the device name:"
msgstr "将SD卡插入主机并获取设备名称："

msgid "Unmount all SD Card partitions."
msgstr "卸载所有SD卡分区。"

msgid "Launch GParted:"
msgstr "启动 GParted："

msgid "Expand rootfs"
msgstr "扩展根文件系统"

msgid "Running gparted on host systems which are using resize2fs version 1.46.6 and older (e.g. Ubuntu 22.04) are not able to expand the ext4 partition created with Yocto Mickledore and newer. This is due to a new default option in resize2fs which causes a incompatibility. See `release notes <https://e2fsprogs.sourceforge.net/e2fsprogs-release.html#1.47.0>`_."
msgstr "使用resize2fs版本1.46.6及更早版本的PC系统（例如Ubuntu 22.04）无法烧写在Mickledore以及更新的yocto版本上创建的partup软件包。这个是因为resize2fs新增了默认选项而导致的兼容性问题。有关详细信息，请参阅 `发布说明 <https://e2fsprogs.sourceforge.net/e2fsprogs-release.html#1.47.0>`_ 。"

msgid "Choose your SD Card device at the drop-down menu on the top right"
msgstr "在右上角的下拉菜单中选择您的SD卡设备"

msgid "Choose the ext4 root partition and click on resize:"
msgstr "选择 ext4 根分区并点击调整大小："

msgid "Drag the slider as far as you like or enter the size manually."
msgstr "您可以根据需要拖动滑块或手动输入大小。"

msgid "Confirm your entry by clicking on the \"Change size\" button."
msgstr "通过点击“Change Size”按钮确认您的输入。"

msgid "To apply your changes, press the green tick."
msgstr "要应用您的更改，请按绿色勾号。"

msgid "Now you can mount the root partition and copy e.g. the |yocto-imagename|-|yocto-machinename|.wic image to it. Then unmount it again:"
msgstr "现在您可以挂载根分区并将 |yocto-imagename|-|yocto-machinename|.wic 镜像复制到其中。然后再卸载它："

msgid "Create the Third Partition"
msgstr "创建第三个分区"

msgid "Choose the bigger unallocated  area and press \"New\":"
msgstr "选择更大的未分配区域，然后点击\"New\"："

msgid "Click \"Add\""
msgstr "点击\"Add\""

msgid "Confirm your changes by pressing the green tick."
msgstr "按绿色勾确认更改。"

msgid "Now you can mount the new partition and copy e.g. |yocto-imagename|-|yocto-machinename|.wic image to it. Then unmount it again:"
msgstr "现在您可以挂载新的分区并将 |yocto-imagename|-|yocto-machinename|.wic 镜像复制到其中。然后卸载它："

msgid "Switch back to legacyboot"
msgstr "切换旧启动模式"

msgid "As we switched to standardboot with fitimage as default, legacyboot is deprecated. We kept the option to switch back to legacyboot for this release, but it will be removed in the future."
msgstr "由于我们已经切换到fitimage启动模式，旧启动模式已被弃用。在本版本中我们保留了切换回旧启动模式的选项，但该选项将在未来移除。"

msgid "Changes in Yocto"
msgstr "Yocto中的更改"

msgid "By default, the fitImage and bootscript will be deployed into the wic.xz Image. To switch back to legacyboot, you need to replace the fitImage and bootscript for the kernel image and the devicetrees. They are still in the deploy folder from the Yocto build, so you can manually copy them to the boot partition on your device. Otherwise you can do the following changes in Yocto to get the kernel and devicetrees deployed in the Image again."
msgstr "默认情况下，fitImage和启动脚本将被部署到wic.xz镜像中。要切换回旧启动模式，您需要用内核镜像和设备树替换fitImage和启动脚本。它们在Yocto构建的deploy文件夹中，因此您可以手动将其复制到设备的引导分区上。或者，您可以在Yocto中进行以下更改，以再次在镜像中部署内核和设备树。"

msgid "First create the variable `KERNEL_DEVICETREE_DEPLOY`. This can be done for example in the local.conf file in your build directory `conf/local.conf`. The variable is basically a copy of the `KERNEL_DEVICETREE` variable that is set in conf/machine/|yocto-machinename|.conf in meta-phytec but the `freescale` at the beginning needs to be removed, so that only the devicetree filename are left. In the end it should look something like this:"
msgstr "首先创建变量 `KERNEL_DEVICETREE_DEPLOY` 。例如，可以在构建目录conf/local.conf中的local.conf文件中进行此操作。该变量是meta-phytec在 conf/machine/|yocto-machinename|.conf 中设置的 `KERNEL_DEVICETREE` 变量的副本，但需要删除开头的 `freescale` ，仅保留设备树文件名。最终应类似于以下内容："

msgid "Then add this line:"
msgstr "然后加入这一行："

msgid "A clean might be required for this to work."
msgstr "需要clean来让改动生效"

msgid "Then start the build:"
msgstr "开始构建："

msgid "Changes in U-Boot environment"
msgstr "U-Boot环境变量修改"

msgid "To re-enable legacyboot set the following variable:"
msgstr "通过设置以下变量重新使能旧启动模式："

msgid "Device Tree (DT)"
msgstr "设备树 (DT)"

msgid "Introduction"
msgstr "介绍"

msgid "The following text briefly describes the Device Tree and can be found in the Linux kernel Documentation (https://docs.kernel.org/devicetree/usage-model.html)"
msgstr "以下文本简要描述了设备树，关于设备树的相关文档可以在Linux kernel文档中找到（https://docs.kernel.org/devicetree/usage-model.html）。"

msgid "*\"The “Open Firmware Device Tree”, or simply Devicetree (DT), is a data structure and language for describing hardware. More specifically, it is a description of hardware that is readable by an operating system so that the operating system doesn't need to hard code details of the machine.\"*"
msgstr "“Open Firmware Device Tree”或简称设备树（DT）是一种用于描述硬件的数据结构和语言。更具体地说，它是一个可由操作系统读取的硬件描述，以便操作系统不需要对machine的细节进行硬编码"

msgid "The kernel documentation is a really good source for a DT introduction. An overview of the device tree data format can be found on the device tree usage page at `devicetree.org <https://www.devicetree.org/>`_."
msgstr "内核文档是学习设备树的一个非常好的资源。关于设备树数据格式的概述可以在 `devicetree.org <https://www.devicetree.org/>`_ 的设备树使用页面找到。"

msgid "PHYTEC |soc| BSP Device Tree Concept"
msgstr "PHYTEC |soc| BSP设备树概念"

msgid "The following sections explain some rules PHYTEC has defined on how to set up device trees for our |soc| SoC-based boards."
msgstr "以下部分说明了PHYTEC配置基于 |soc| 的核心板设备树的一些规则。"

msgid "Device Tree Structure"
msgstr "设备树结构"

msgid "*Module.dtsi* - Module includes all devices mounted on the SoM, such as PMIC and RAM."
msgstr "*Module.dtsi* - 文件包括所有安装在核心板上的设备，例如PMIC和RAM。"

msgid "*Board.dts* - include the module dtsi file. Devices that come from the |soc| SoC but are just routed down to the carrier board and used there are included in this dts."
msgstr "*Board.dts* - 包含核心板 dtsi 文件。从SoC |soc| 引出并在底板使用的设备也包含在此 dts 中。"

msgid "*Overlay.dtso* - enable/disable features depending on optional hardware that may be mounted or missing on SoM or baseboard (e.g SPI flash or PEB-AV-10)"
msgstr "*Overlay.dtso* - 根据核心板或底板上可选硬件（例如 SPI 闪存或 PEB-AV-10）的情况来启用/禁用一些功能。"

msgid "From the root directory of the Linux Kernel our devicetree files for |socfamily| platforms can be found in ``arch/arm64/boot/dts/freescale/``."
msgstr "在Linux内核的根目录下，我们的 |socfamily| 平台的设备树文件可以在 ``arch/arm64/boot/dts/freescale/`` 找到。"

msgid "Device Tree Overlay"
msgstr "设备树Overlay"

msgid "Device Tree overlays are device tree fragments that can be merged into a device tree during boot time. These are for example hardware descriptions of an expansion board. They are instead of being added to the device tree as an extra include, now applied as an overlay. They also may only contain setting the status of a node depending on if it is mounted or not. The device tree overlays are placed next to the other device tree files in our Linux kernel repository in the folder ``arch/arm64/boot/dts/freescale/``."
msgstr "设备树Overlay是可以在启动时合并到设备树中的设备树片段。下面是扩展板的硬件描述。对比源码中的include，overlay通过覆盖的方式来生效。overlay也可以根据实际开发板的硬件配置来设置设备树节点状态。设备树Overlay与我们Linux内核仓库中的其他设备树文件一起放在子文件夹 ``arch/arm64/boot/dts/freescale/`` 中。"

msgid "Available overlays for |yocto-machinename|.conf are:"
msgstr "|yocto-machinename|.conf 可用的overlay文件有："

msgid "Otherwise you can show the content of a FIT image including all overlay configs in the FIT image with this command in Linux:"
msgstr "可以在linux中使用以下命令来列出FIT镜像中所有的overlay配置"

msgid "or in U-Boot:"
msgstr "或者在u-boot："

msgid "The usage of overlays can be configured during runtime in Linux or U-Boot. Overlays are applied during the boot process in the bootloader after the boot command is called and before the kernel is loaded. The next sections explain the configuration in more detail."
msgstr "可以在Linux或U-Boot环境下配置overlay。overlay是在引导命令调用后、内核加载之前生效。接下来的部分将更详细地解释配置方法。"

#, python-brace-format
msgid "Set ``${overlays}`` variable"
msgstr "设置 ``${overlays}`` 变量"

#, python-brace-format
msgid "The ``${overlays}`` U-Boot environment variable contains a number-sign (#) separated list of overlays that will be applied during boot. The overlays listed in the overlays variable must be included in the FIT image. Overlays set in the $KERNEL_DEVICETREE Yocto machine variable will automatically be added to the FIT image."
msgstr "``${overlays}`` U-Boot 环境变量包含一个以井号#分隔的overlay文件列表，这些overlay文件将在启动过程中应用。overlays变量中的overlay列表会包含在FIT镜像中。在 $KERNEL_DEVICETREE 这个 Yocto machine 变量中设置的 overlay 文件将自动添加到FIT镜像中。"

#, python-brace-format
msgid "The ``${overlays}`` variable can either be set directly in the U-Boot environment or can be part of the external ``bootenv.txt`` environment file. When desired to use the overlays variable as set manually in the U-Boot environment, disable bootenv by setting ``env set no_bootenv 1`` as the overlays variable may be overwritten during the execution of the boot script. By default, the ``${overlays}`` variable comes from the external ``bootenv.txt`` environment file which is located in the boot partition. You can read and write the file on booted target from linux:"
msgstr "``${overlays}`` 变量可以直接在U-Boot环境中设置，也可以作为外部 ``bootenv.txt`` 环境文件的一部分。当希望使用在U-Boot环境中手工配置的overlay变量，可以配置 ``env set no_bootenv 1`` ，因为overlay变量可能在运行启动脚本时被覆盖。默认情况下， ``${overlays}`` 变量来自位于启动分区的 ``bootenv.txt`` 文件。您可以在已启动的开发板上从Linux读取和写入该文件："

msgid "Changes will take effect after the next reboot. If no ``bootenv.txt`` file is available the overlays variable can be set directly in the U-Boot environment."
msgstr "更改将在下次重启后生效。如果没有可用的 ``bootenv.txt`` 文件，可以直接在U-Boot环境中设置overlay变量。"

#, python-brace-format
msgid "If a user defined ``${overlays}`` variable should be directly loaded from U-Boot environment but there is still an external ``bootenv.txt`` available, the ``${no_bootenv}`` variable needs to be set as a flag:"
msgstr "如果用户定义了 ``${overlays}`` 变量，同时存在 ``bootenv.txt`` 文件，则需要设置 ``${no_bootenv}`` 变量："

msgid "More information about the external environment can be found in |ubootexternalenv|."
msgstr "有关环境的更多信息，请参见 |ubootexternalenv|。"

#, python-brace-format
msgid "We use the ``${overlays}`` variable for overlays describing expansion boards and cameras that can not be detected during run time. To prevent applying overlays unset the overlays variable and set no_bootenv to anything other than 0."
msgstr "我们使用 ``${overlays}`` 变量来描述在运行时无法自动检测的扩展板和摄像头。如果想禁用 ``${overlays}`` 变量中列出的overlay，可以在U-Boot的环境中将overlay变量unset，并且将 ``${no_overlays}`` 变量设置为 `1`。"

msgid "If desired to use the bootenv.txt file for setting U-Boot variables other than overlays and having overlays disabled, remove the overlays definition line from the bootenv.txt file instead of setting no_bootenv."
msgstr "如果希望通过 bootenv.txt 文件设置除overlay之外的 U-Boot 变量并且禁用overlay，可以从 bootenv.txt 文件中删除overlay定义行，而不是设置 no_bootenv。"

msgid "SoM Variants"
msgstr "不同的SoM配置"

msgid "Additional overlays are applied automatically to disable components that are not populated on the SoM. The detection is done with the EEPROM data (EEPROM SoM Detection) found on the SoM i2c EEPROM."
msgstr "核心板会自动加载额外的overlay，以禁用核心板未贴装的组件。通过读取出厂EEPROM数据（EEPROM SoM Detection）来实现自动加载对应的overlay。"

msgid "It depends on the SoM variant if any device tree overlays will be applied. To check if an overlay will be applied on the running SoM in U-Boot, run:"
msgstr "核心板型号会决定是否应用设备树overlay。要在U-Boot环境中查询是否会应用某个overlay，请运行："

msgid "If the EEPROM data is not available, no device tree overlays are applied."
msgstr "如果没有可用的EEPROM数据，则不加载任何设备树overlay。"

#, python-brace-format
msgid "To prevent application of the SoM variant related overlays the ``${no_extensions}`` variable can be set to `1` in the bootloader environment::"
msgstr "要禁止启动时自动加载不同核心板的overlay，可以在bootloader环境中将 ``${no_extensions}`` 变量设置为 `1` ："

msgid "U-boot External Environment"
msgstr "U-boot外部环境"

#, python-brace-format
msgid "During the start of the Linux Kernel the external environment ``bootenv.txt`` text file will be loaded from the boot partition of an MMC device or via TFTP. The main intention of this file is to store the ``${overlays}`` variable. This makes it easy to pre-define the overlays in Yocto depending on the used machine. The content from the file is defined in the Yocto recipe bootenv found in meta-phytec: |yocto-bootenv-link|"
msgstr "在Linux内核启动时，外部环境 ``bootenv.txt`` 文本文件将从MMC设备的boot分区或通过TFTP加载。该文件的主要目的是存储 ``${overlays}`` 变量。这可以针对不同的machine在Yocto中预定义不同的overlay配置。文件的内容在meta-phytec中的Yocto recipe中的bootenv中定义： |yocto-bootenv-link|"

#, python-brace-format
msgid "Other variables can be set in this file, too. They will overwrite the existing settings in the environment. But only variables evaluated after issuing the boot command can be overwritten, such as ``${nfsroot}`` or ``${mmcargs}``. Changing other variables in that file will not have an effect. See the usage during netboot as an example."
msgstr "该文件中也可以设置其他变量。这些变量将覆盖环境中现有的设置。但只有对boot命令后进行计算的变量生效，例如 ``${nfsroot}`` 或 ``${mmcargs}``。在文件中更改其他变量将不会有作用。以网络启动的用法作为示例。"

msgid "If the external environment can not be loaded the boot process will be anyway continued with the values of the existing environment settings."
msgstr "如果无法加载外部环境，启动过程将继续进行，并使用自带的环境变量值。"

msgid "Change U-boot Environment from Linux on Target"
msgstr "在Linux环境下更改开发板上的U-boot环境变量"

msgid "Libubootenv is a tool included in our images to modify the U-Boot environment of Linux on the target machine."
msgstr "Libubootenv是我们镜像中包含的一个工具，用于在开发板linux上修改U-Boot环境。"

msgid "Print the U-Boot environment using the following command:"
msgstr "使用以下命令打印U-Boot环境："

msgid "Modify a U-Boot environment variable using the following command:"
msgstr "使用以下命令修改U-Boot环境："

msgid "Libubootenv takes the environment selected in a configuration file. The environment to use is inserted there, and by default it is configured to use the eMMC environment (known as the default used environment)."
msgstr "Libubootenv会读取配置文件中配置的环境变量。要修改的环境变量会被插入到该文件中，默认情况下使用eMMC中存储环境变量。"

msgid "If the eMMC is not flashed or the eMMC environment is deleted, libubootenv will not work. You should modify the ``/etc/fw_env.config`` file to match the environment source that you want to use."
msgstr "如果eMMC没有被烧写过或者eMMC环境被擦除，libubootenv将无法工作。您应该修改 ``/etc/fw_env.config`` 文件，以匹配您想要使用的环境源。"

msgid "Accessing Peripherals"
msgstr "访问外设"

#, fuzzy
msgid "To find out which boards and modules are supported by the release of PHYTEC's |som| BSP described herein, visit |dlpage-bsp|_ web page and click the corresponding BSP release in the download section. Here you can find all hardware supported in the columns \"Hardware Article Number\" and the correct machine name in the corresponding cell under \"Machine Name\"."
msgstr "要查找本文中所述的PHYTEC的phyCORE-|soc| BSP支持的开发板和核心板，请访问  |dlpage-bsp|_ 网页，并在下载部分点击相应的BSP版本。在这里，您可以在\"Hardware Article Number\"列中找到所有支持的硬件，并在\"Machine Name\"下的相应单元格中找到正确的\"Machine Name\"。"

msgid "To achieve maximum software reuse, the Linux kernel offers a sophisticated infrastructure that layers software components into board-specific parts. The BSP tries to modularize the kit features as much as possible. When a customized baseboard or even a customer-specific module is developed, most of the software support can be reused without error-prone copy-and-paste. The kernel code corresponding to the boards can be found in device trees (DT) in the kernel repository under ``arch/arm64/boot/dts/freescale/*.dts``."
msgstr "为了最大化软件的可复用性，Linux内核提供了一个巧妙的软件架构，软件会根据不同硬件组件来分层。BSP（板级支持包）尽可能地对套件的功能进行模块化。当定制开发板或自定义核心板时，大部分软件配置可以简单的复制粘贴。与具体的开发板相关的内核代码可以在内核代码仓库中的设备树（DT）中找到，路径为 ``arch/arm64/boot/dts/freescale/*.dts`` 。"

msgid "In fact, software reuse is one of the most important features of the Linux kernel, especially of the ARM implementation which always has to fight with an insane number of possibilities of the System-on-Chip CPUs. The whole board-specific hardware is described in DTs and is not part of the kernel image itself. The hardware description is in its own separate binary, called the Device Tree Blob (DTB) (section |ref-dt|)."
msgstr "实际上，软件复用是Linux内核最重要的特性之一，尤其是在ARM架构中，它必须应对大量复杂且不同的系统级芯片（SoC）。整个开发板的硬件在设备树（DT）中描述，独立于内核镜像。硬件描述在一个单独的二进制文件中，称为设备树二进制文件（Device Tree Blob，DTB）（参见 |ref-dt|）。"

msgid "Please read section PHYTEC |soc| BSP Device Tree Concept to get an understanding of our |socfamily| BSP device tree model."
msgstr "请阅读PHYTEC |soc| BSP设备树概念部分，以了解我们的 |socfamily| BSP设备树模型。"

msgid "The following sections provide an overview of the supported hardware components and their operating system drivers on the |socfamily| platform. Further changes can be ported upon customer request."
msgstr "以下部分概述了 |socfamily| 平台上支持的硬件组件及其对应操作系统驱动程序。客户可以根据自身的需求进行更改。"

msgid "|soc| Pin Muxing"
msgstr "|soc| 引脚复用"

msgid "The |soc| SoC contains many peripheral interfaces. In order to reduce package size and lower overall system cost while maintaining maximum functionality, many of the |soc| terminals can multiplex up to eight signal functions. Although there are many combinations of pin multiplexing that are possible, only a certain number of sets, called IO sets, are valid due to timing limitations. These valid IO sets were carefully chosen to provide many possible application scenarios for the user."
msgstr "该 |soc| Soc包含许多外设接口。为了在保持最大功能性的同时减少封装尺寸和降低整体系统成本，许多 |soc| 引脚可以多路复用为多达八种信号功能。尽管存在许多可能的引脚多路复用组合，但由于时序限制，只有一定数量的组合被称为有效的 IO 集合。这些有效的 IO 集合经过精心挑选，以为用户提供尽可能多的应用场景。"

msgid "Please refer to our Hardware Manual or the NXP |soc| Reference Manual for more information about the specific pins and the muxing capabilities."
msgstr "请参考我们的硬件手册或NXP |soc| 参考手册，以获取有关特定引脚和复用能力的更多信息。"

msgid "The IO set configuration, also called muxing, is done in the Device Tree. The driver pinctrl-single reads the DT's node fsl,pins, and does the appropriate pin muxing."
msgstr "IO 集合的配置，也称为复用（muxing），是在设备树中完成的。驱动程序pinctrl-single读取设备树的节点fsl,pins，并进行引脚复用配置。"

msgid "The following is an example of the pin muxing of the UART1 device in |dt-carrierboard|.dts:"
msgstr "以下是 |dt-carrierboard|.dts中UART1设备的引脚复用示例："

msgid "The first part of the string MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX names the pad (in this example SAI2_RXFS). The second part of the string (UART1_DCE_RX) is the desired muxing option for this pad. The pad setting value (hex value on the right) defines different modes of the pad, for example, if internal pull resistors are activated or not. In this case, the internal resistors are disabled."
msgstr "字符串的第一部分 MX8MM_IOMUXC_SAI2_RXFS_UART1_DCE_TX 指定了引脚（在这个例子中是 SAI2_RXFS）。字符串的第二部分（UART1_DCE_RX）是该引脚当前的复用选项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部上拉电阻是否被激活。在当前配置中，内部电阻是禁用的。"

msgid "RS232/RS485"
msgstr "RS232/RS485"

msgid "The |soc| SoC provides up to 4 UART units. PHYTEC boards support different numbers of these UART units. UART1 can also be used as RS-485. For this, |ref-bootswitch| needs to be set correctly:"
msgstr "|soc| SoC 提供最多 4 个 UART 单元。PHYTEC 开发板支持不同数量 UART 单元。UART1 也可以用作 RS-485。为此，需要正确设置 |ref-bootswitch|："

msgid "**UART1 RS485**"
msgstr "**UART1 RS485**"

msgid "**UART1 RS232**"
msgstr "**UART1 RS232**"

msgid "RS232"
msgstr "RS232"

msgid "Display the current settings of a terminal in a human-readable format:"
msgstr "以人类可读的格式显示终端的当前设置："

msgid "Configuration of the UART interface can be done with stty. For example:"
msgstr "UART接口的配置可以通过stty命令完成。例如："

msgid "With a simple echo and cat, basic communication can be tested. Example:"
msgstr "通过简单的echo和cat，可以测试基本的通信。示例："

msgid "The host should print out \"123\"."
msgstr "主机应打印出 \"123\"。"

msgid "RS485"
msgstr "RS485"

msgid "Remember to use bus termination resistors of 120 Ohm at each end of the bus, when using longer cables."
msgstr "在使用较长电缆时，请记得在总线两端各使用120欧姆的终端电阻。"

msgid "For easy testing, look at the linux-serial-test. This tool is called the IOCTL for RS485 and sends a constant stream of data."
msgstr "为了方便测试，请查看linux-serial-test。这个工具会通过调用RS485的IOCTL，发送恒定的数据流。"

msgid "More information about the linux-serial-test tool and its parameters can be found here: `linux-serial-test <https://github.com/cbrake/linux-serial-test>`_"
msgstr "有关linux-serial-test工具及其参数的更多信息，请访问此链接：`linux-serial-test <https://github.com/cbrake/linux-serial-test>`_"

msgid "The linux-serial-test will automatically set ioctls, but they can also be set manually with rs485conf."
msgstr "linux-serial-test会自动设置ioctl，也可以通过rs485conf手动设置。"

msgid "You can show the current config with:"
msgstr "你可以用以下命令显示当前配置："

msgid "You can show all options with:"
msgstr "您可以通过以下方式列出帮助选项："

msgid "Documentation for calling the IOCTL within c-code is described in the Linux kernel documentation: https://www.kernel.org/doc/Documentation/serial/serial-rs485.txt"
msgstr "Linux kernel文档描述了如何在C代码中调用IOCTL： https://www.kernel.org/doc/Documentation/serial/serial-rs485.txt"

msgid "RS485 half-duplex"
msgstr "RS485 半双工"

msgid "For half-duplex mode your connection setup should look like this:"
msgstr "对于半双工模式，应按下图方式连接："

msgid "Which function is on which pin is described in the hardware manual."
msgstr "硬件手册中有描述各个引脚的功能。"

msgid "For half-duplex mode you can set the ioctls manually like this:"
msgstr "对于半双工模式，您可以手动设置 ioctls，如下所示："

msgid "Then you can test if sending and receiving works like this:"
msgstr "然后您可以测试发送和接收是否正常工作，方法如下："

msgid "You should see \"test\" printed out on target1. You can also switch the roles and send on target2 and receive on target1."
msgstr "您应该会在target1上看到 \"test\" 打印出来。您也可以切换角色，在target2上发送并在target1上接收。"

msgid "Alternatively you can also test with the linux-serial-test tool:"
msgstr "或者，您还可以使用 linux-serial-test 工具进行测试："

msgid "In this example target1 will be the receiver and target2 will be the transmitter. You should also be able to switch the roles. Remember to first start the receiver and then the transmitter immediately after. The receiver will receive for 8 sec and the transmitter will send for 5 sec. The receiver needs to receive for a bit longer than the transmitter sends. At the end the program will print the final \"count for this session\". There you can check, that all transmitted frames were received."
msgstr "在此示例中，target1将是接收器，target2将是发射器。您还可以切换角色。请记住，先启动接收方，然后再启动发射方。接收方将接收8秒，发射方将在5秒内发送。接收方需要比发射器发送的时间稍长一些。程序结束时会打印最终的 \"count for this session\" 。在那里，您可以检查所有发送的帧是否都被接收到。"

msgid "All the tests are target to target, but can also be done with host to target with a USB to rs485 converter. You may need to adjust the interfaces then."
msgstr "所有测试都是target到target，但也可以使用 USB 到 RS485 转换器进行主机到目标的测试。您可能需要调整接口。"

#, fuzzy
msgid "The device tree representation for RS232 and RS485: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L297`"
msgstr "RS232和RS485的设备树： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L251`"

msgid "Network"
msgstr "网络"

msgid "|sbc|-|soc| provides one Gigabit Ethernet interface."
msgstr "|sbc|-|soc| 提供一个千兆以太网接口。"

msgid "All interfaces offer a standard Linux network port that can be programmed using the BSD socket interface. The whole network configuration is handled by the systemd-networkd daemon. The relevant configuration files can be found on the target in ``/lib/systemd/network/`` as well as the BSP in ``meta-ampliphy/recipes-core/systemd/systemd-conf``."
msgstr "所有接口都提供一个标准的Linux网络端口，可以使用BSD套接字接口进行编程。整个网络配置由systemd-networkd守护进程管理。相关的配置文件可以在开发板的 ``/lib/systemd/network/`` 目录中找到，以及在BSP中的 ``meta-ampliphy/recipes-core/systemd/systemd-conf`` 目录中。"

#, fuzzy
msgid "IP addresses can be configured within \\*.network files. The interfaces are configured to static IP as default. The default IP address and netmask for eth0 is:"
msgstr "IP地址可以在\\*.network文件中进行配置。eth0的默认IP地址和子网掩码为："

msgid "To configure eth0 to dynamic IP over DHCP, go to ``/lib/systemd/network/\\*-eth0.network`` and delete the line:"
msgstr ""

#, fuzzy
msgid "The DT Ethernet setup might be split into two files depending on your hardware configuration: the module DT and the board-specific DT. The device tree set up for the ethernet where the PHY is populated on the SoM can be found here: |dt-somnetwork|."
msgstr "根据您的硬件配置，设备树的以太网设置可能会分为两个文件：核心板的DT文件和底板的DT。FEC以太网IP核心的设备树设置，其中以太网PHY被集成在核心板上，可以在这里找到：|dt-somnetwork|。"

msgid "|sbc-network|"
msgstr "|sbc-network|"

msgid "Network Environment Customization"
msgstr "网络配置"

msgid "U-boot network-environment"
msgstr "U-boot网络环境"

msgid "To find the Ethernet settings in the target bootloader:"
msgstr "要在bootloader中查找以太网设置："

msgid "With your development host set to IP 192.168.3.10 and netmask 255.255.255.0, the target should return:"
msgstr "在将主机设置为IP 192.168.3.10和子网掩码255.255.255.0的情况下，开发板应该返回："

msgid "If you need to make any changes:"
msgstr "如果您需要进行任何更改："

msgid "<parameter> should be one of ipaddr, netmask, gatewayip or serverip. <value> will be the actual value of the chosen parameter."
msgstr "<parameter> 应该是 ipaddr、netmask、gatewayip 或 serverip 中的一个。<value> 将是所选参数的设定值。"

msgid "The changes you made are temporary for now. To save these:"
msgstr "您所做的更改目前是临时的。要保存这些更改："

msgid "Here you can also change the IP address to DHCP instead of using a static one."
msgstr "在这里，您也可以将IP地址更改为DHCP，而不是使用静态IP地址。"

msgid "Configure:"
msgstr "配置："

msgid "Set up paths for TFTP and NFS. A modification could look like this:"
msgstr "设置 TFTP 和 NFS 的路径。修改可以如下所示："

msgid "Please note that these modifications will only affect the bootloader settings."
msgstr "请注意，这些修改只会影响bootloader的设置。"

msgid "Variables like nfsroot and netargs can be overwritten by the U-boot External Environment. For netboot, the external environment will be loaded from tftp. For example, to locally set the nfsroot variable in a ``bootenv.txt`` file, locate the tftproot directory:"
msgstr "像nfsroot和netargs这样的变量可以被U-boot外部环境重新赋值。对于网络启动，外部环境将通过tftp加载。例如，要在 ``bootenv.txt`` 文件中设置nfsroot变量，请在tftproot目录修改："

msgid "There is no need to store the info on the target. Please note that this does not work for variables like ipaddr or serveraddr as they need to be already set when the external environment is being loaded."
msgstr "无需在开发板上存储这些信息。请注意，U-boot外部环境对于像 ipaddr 或 serveraddr 这样的变量不起作用，因为它们在加载外部环境之前已经被设置完成。"

msgid "Kernel network-environment"
msgstr "内核网络环境"

msgid "Find the ethernet settings for eth0 in the target kernel:"
msgstr "在开发板中查找eth0的以太网设置："

msgid "Temporary adaption of the eth0 configuration:"
msgstr "临时调整eth0的配置："

msgid "WLAN"
msgstr "无线局域网"

msgid "For WLAN and Bluetooth support, we use the Sterling-LWB module from LSR. This module supports 2,4 GHz bandwidth and can be run in several modes, like client mode, Access Point (AP) mode using WEP, WPA, WPA2 encryption, and more. More information about the module can be found at https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf"
msgstr "为了支持WLAN和蓝牙，我们使用来自LSR的Sterling-LWB模块。该模块支持2.4 GHz，并且可以在多种模式下运行，如客户端模式、使用WEP、WPA、WPA2加密的接入点（AP）模式等。有关该模块的更多信息，请访问 https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf"

msgid "Connecting to a WLAN Network"
msgstr "连接到WLAN网络"

msgid "First set the correct regulatory domain for your country:"
msgstr "首先设置您所在国家的正确监管域："

msgid "You will see:"
msgstr "你将会看到："

msgid "Set up the wireless interface:"
msgstr "设置无线接口："

msgid "Now you can scan for available networks:"
msgstr "现在您可以扫描可用的网络："

msgid "You can use a cross-platform supplicant with support for WEP, WPA, and WPA2 called wpa_supplicant for an encrypted connection."
msgstr "您可以使用一个跨平台的客户端，名为wpa_supplicant，支持WEP、WPA和WPA2，以建立加密连接。"

msgid "To do so, add the network-credentials to the file ``/etc/wpa_supplicant.conf``:"
msgstr "为此，请将网络凭据添加到文件 ``/etc/wpa_supplicant.conf`` 中："

msgid "Now a connection can be established:"
msgstr "现在可以建立连接："

msgid "This should result in the following output:"
msgstr "这会得到如下输出："

msgid "The ip address is automatically configured over DHCP. For other possible IP configurations, see section `Changing the Network Configuration` in the |yocto-ref-manual|."
msgstr "ip地址自动通过DHCP配置。有关其他可能的IP配置，请参阅 |yocto-ref-manual| 中的“更改网络配置”部分。"

msgid "Bluetooth"
msgstr "蓝牙"

msgid "Bluetooth is connected to |bluetooth-uart| interface. The Bluetooth device needs to be set up manually:"
msgstr ""

msgid "Now you can scan your environment for visible Bluetooth devices. Bluetooth is not visible during a default startup."
msgstr "现在您可以扫描环境中的可见蓝牙设备。在默认配置下，蓝牙是不可见的。"

msgid "Visibility"
msgstr "可见性"

msgid "To activate visibility:"
msgstr "要激活可见性："

msgid "To disable visibility:"
msgstr "要禁用可见性："

msgid "Connect"
msgstr "连接"

msgid "If the connection fails with the error message: \"Failed to connect: org.bluez.Error.Failed\" try restarting PulseAudio with:"
msgstr "如果连接失败并出现错误信息： \"Failed to connect: org.bluez.Error.Failed\"，请尝试使用以下命令重新启动PulseAudio："

msgid "SD/MMC Card"
msgstr "SD/MMC 卡"

msgid "The |soc| supports a slot for Secure Digital Cards and MultiMedia Cards to be used as general-purpose block devices. These devices can be used in the same way as any other block device."
msgstr "该 |soc| 支持一个用于SD卡和MMC卡的接口，作为linux通用块设备。这些设备可以像其他任何块设备一样使用。"

msgid "These kinds of devices are hot-pluggable. Nevertheless, you must ensure not to unplug the device while it is still mounted. This may result in data loss!"
msgstr "这些设备是热插拔的。然而，您必须确保在设备仍然挂载时不要拔掉它。这可能会导致数据丢失！"

msgid "After inserting an SD/MMC card, the kernel will generate new device nodes in /dev. The full device can be reached via its /dev/mmcblk1 device node. SD/MMC card partitions will show up as:"
msgstr "插入SD/MMC卡后，内核将在/dev中生成新的设备节点。完整设备可以通过其/dev/mmcblk1设备节点访问。SD/MMC卡的分区将显示为："

msgid "<Y> counts as the partition number starting from 1 to the max count of partitions on this device. The partitions can be formatted with any kind of file system and also handled in a standard manner, e.g. the mount and umount command work as expected."
msgstr "<Y> 作为分区编号，从1开始计数，直到该设备的最大分区数量。分区可以使用任何类型的文件系统进行格式化，并且可以以标准方式进行处理，例如，可以使用mount 和 umount 命令进行分区挂载和卸载。"

msgid "These partition device nodes will only be available if the card contains a valid partition table (”hard disk” like handling). If no partition table is present, the whole device can be used as a file system (”floppy” like handling). In this case, /dev/mmcblk1 must be used for formatting and mounting. The cards are always mounted as being writable."
msgstr "这些分区设备节点要求SD卡包含有效的分区表（类似于“硬盘”）。如果没有分区表，则整个设备作为一个文件系统使用（类似于“软盘”）。在这种情况下，必须使用 /dev/mmcblk1 进行格式化和挂载。卡始终以可写方式挂载。"

#, fuzzy
msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L381`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L261`"

#, fuzzy
msgid "DT configuration for the eMMC interface can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phycore-som.dtsi#L293`"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"

#, fuzzy
msgid "e.MMC Devices"
msgstr "eMMC设备"

#, fuzzy
msgid "PHYTEC modules like |som| are populated with an e.MMC memory chip as the main storage. e.MMC devices contain raw Multi-Level Cells (MLC) or Triple-Level Cells (TLC) combined with a memory controller that handles ECC and wear leveling. They are connected via an SD/MMC interface to the |soc| and are represented as block devices in the Linux kernel like SD cards, flash drives, or hard disks."
msgstr "PHYTEC模块如phyCORE-|soc| 配备了eMMC存储芯片作为主要存储。eMMC设备使用多层单元（MLC）或三层单元（TLC）技术来实现存储，并集成了处理ECC和磨损均衡的存储控制器。它们通过SD/MMC接口连接到 |soc| ，并在Linux内核中作为块设备表示，如SD卡、优盘或硬盘。"

#, fuzzy
msgid "The electric and protocol specifications are provided by JEDEC (https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc). The e.MMC manufacturer's datasheet is relatively short and meant to be read together with the supported version of the JEDEC e.MMC standard."
msgstr "电气和协议规范由JEDEC提供（https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc）。eMMC制造商的数据手册相对较简单，旨在与支持的JEDEC eMMC标准版本一起阅读。"

#, fuzzy
msgid "PHYTEC currently utilizes the e.MMC chips with JEDEC Version 5.0 and 5.1"
msgstr "PHYTEC目前使用JEDEC版本5.0和5.1的eMMC芯片。"

msgid "Extended CSD Register"
msgstr "扩展CSD寄存器"

#, fuzzy
msgid "e.MMC devices have an extensive amount of extra information and settings that are available via the Extended CSD registers. For a detailed list of the registers, see manufacturer datasheets and the JEDEC standard."
msgstr "通过扩展CSD寄存器可以读取eMMC设备其他的信息和配置。有关寄存器的详细列表，请参阅制造商的数据手册和JEDEC标准。"

msgid "In the Linux user space, you can query the registers:"
msgstr "在Linux用户空间中，您可以查询寄存器："

msgid "Enabling Background Operations (BKOPS)"
msgstr "使能后台操作 (BKOPS)"

#, fuzzy
msgid "In contrast to raw NAND Flash, an e.MMC device contains a Flash Transfer Layer (FTL) that handles the wear leveling, block management, and ECC of the raw MLC or TLC. This requires some maintenance tasks (for example erasing unused blocks) that are performed regularly. These tasks are called **Background Operations (BKOPS)**."
msgstr "与原始NAND Flash相比，eMMC设备包含一个闪存传输层（FTL），该层负责处理原始MLC或TLC的磨损均衡、块管理和错误更正码（ECC）。这需要定期执行一些维护任务（例如擦除未使用的块）。这些任务被称为 **后台操作（BKOPS）** 。"

msgid "By default (depending on the chip), the background operations may or may not be executed periodically, impacting the worst-case read and write latency."
msgstr "默认情况下（取决于芯片），后台操作可能会定期执行，也可能不会，他影响读写的最大延迟时间。"

#, fuzzy
msgid "The JEDEC Standard has specified a method since version v4.41 that the host can issue BKOPS manually. See the JEDEC Standard chapter Background Operations and the description of registers BKOPS_EN (Reg: 163) and BKOPS_START (Reg: 164) in the e.MMC datasheet for more details."
msgstr "JEDEC标准自版本v4.41起规定了一种方法，主机可以手动触发BKOPS。有关更多详细信息，请参阅JEDEC标准章节“Background Operations”以及eMMC数据手册中寄存器BKOPS_EN（寄存器：163）和BKOPS_START（寄存器：164）的描述。"

msgid "Meaning of Register BKOPS_EN (Reg: 163) Bit MANUAL_EN (Bit 0):"
msgstr "寄存器 BKOPS_EN（寄存器：163）的位 MANUAL_EN（位 0）的含义："

msgid "Value 0: The host does not support the manual trigger of BKOPS. Device write performance suffers."
msgstr "值 0：主机不支持手动触发 BKOPS。设备写入性能会受到影响。"

msgid "Value 1: The host does support the manual trigger of BKOPS. It will issue BKOPS from time to time when it does not need the device."
msgstr "值1：主机支持手动触发BKOPS。当主机不进行设备读写时，它会不时触发BKOPS。"

#, fuzzy
msgid "The mechanism to issue background operations has been implemented in the Linux kernel since v3.7. You only have to enable BKOPS_EN on the e.MMC device (see below for details)."
msgstr "自v3.7版本以来，Linux内核已经实现了触发后台操作的机制。您只需在eMMC设备上启用BKOPS_EN（详细信息见下文）。"

msgid "The JEDEC standard v5.1 introduces a new automatic BKOPS feature. It frees the host to trigger the background operations regularly because the device starts BKOPS itself when it is idle (see the description of bit AUTO_EN in register BKOPS_EN (Reg: 163))."
msgstr "JEDEC标准v5.1引入了一种新的自动BKOPS功能。它使主机能够定期触发后台操作，因为设备在空闲时会自动启动BKOPS（请参见寄存器BKOPS_EN（寄存器：163）中位AUTO_EN的描述）。"

msgid "To check whether *BKOPS_EN* is set, execute:"
msgstr "要检查 *BKOPS_EN* 是否已设置，请执行："

msgid "The output will be, for example:"
msgstr "输出将会是，例如："

msgid "Where value 0x00 means BKOPS_EN is disabled and device write performance suffers. Where value 0x01 means BKOPS_EN is enabled and the host will issue background operations from time to time."
msgstr "值0x00表示BKOPS_EN被禁用，设备的写入性能受到影响。值0x01表示BKOPS_EN被启用，主机将不时发起后台操作。"

msgid "Enabling can be done with this command:"
msgstr "通过以下命令使能BKOPS_EN："

msgid "To set the BKOPS_EN bit, execute:"
msgstr "要设置BKOPS_EN位，请执行："

msgid "To ensure that the new setting is taken over and the kernel triggers BKOPS by itself, shut down the system:"
msgstr "为了确保新设置生效并且内核能够自动触发BKOPS，请先关闭系统："

msgid "The BKOPS_EN bit is one-time programmable only. It cannot be reversed."
msgstr "BKOPS_EN位是一次性可编程的，无法恢复。"

msgid "Reliable Write"
msgstr "可靠写入"

msgid "There are two different Reliable Write options:"
msgstr "有两种不同的可靠写入选项："

msgid "Reliable Write option for a whole eMMC device/partition."
msgstr "对整个eMMC设备/分区的可靠写入方式。"

msgid "Reliable Write for single write transactions."
msgstr "单次写的可靠写入方式。"

#, fuzzy
msgid "Do not confuse e.MMC partitions with partitions of a DOS, MBR, or GPT partition table (see the previous section)."
msgstr "不要将 eMMC 分区与 DOS、MBR 或 GPT 分区表的分区混淆（请参阅前一节）。"

#, fuzzy
msgid "The first Reliable Write option is mostly already enabled on the e.MMCs mounted on the |som| SoMs. To check this on the running target:"
msgstr "第一个可靠写入方式大多数情况下已经在phyCORE-|soc| SoM上挂载的eMMC上被启用。想要在运行的开发板上检查这一点："

msgid "Otherwise, it can be enabled with the mmc tool:"
msgstr "如果默认没有启用，可以使用mmc工具启用它："

msgid "The second Reliable Write option is the configuration bit Reliable Write Request parameter (bit 31) in command CMD23. It has been used in the kernel since v3.0 by file systems, e.g. ext4 for the journal and user space applications such as fdisk for the partition table. In the Linux kernel source code, it is handled via the flag REQ_META."
msgstr "第二个可靠写入方式是命令CMD23中的配置位Reliable Write Request parameter（可靠写入请求参数）（位31）。自内核版本v3.0起，文件系统（例如ext4的日志）和用户空间应用程序（如fdisk的分区表）会通过内核使用该可靠写功能。在Linux内核源代码中，它通过标志REQ_META进行处理。"

msgid "**Conclusion**: ext4 file system with mount option data=journal should be safe against power cuts. The file system check can recover the file system after a power failure, but data that was written just before the power cut may be lost. In any case, a consistent state of the file system can be recovered. To ensure data consistency for the files of an application, the system functions fdatasync or fsync should be used in the application."
msgstr "**结论**：使用挂载选项 data=journal 的 ext4 文件系统在断电情况下是安全的。文件系统检查可以在断电后恢复文件系统，但在断电前刚写入的数据可能会丢失。在各种情况下，都可以恢复文件系统的正常状态。为了确保应用程序文件的正常保存，应用程序中应使用系统函数 fdatasync 或 fsync。"

msgid "Resizing ext4 Root Filesystem"
msgstr "调整 ext4 根文件系统的大小"

#, fuzzy
msgid "When flashing the sdcard image to e.MMC the ext4 root partition is not extended to the end of the e.MMC. parted can be used to expand the root partition. The example works for any block device such as e.MMC, SD card, or hard disk."
msgstr "在将SD卡镜像写入eMMC时，ext4文件系统分区没有扩展到eMMC的末尾。可以使用parted来扩展根分区。这个示例适用于任何块设备，例如eMMC、SD卡或硬盘。"

msgid "Get the current device size:"
msgstr "获取当前设备大小："

msgid "The output looks like this:"
msgstr "输出如下："

msgid "Use parted to resize the root partition to the max size of the device:"
msgstr "使用parted将文件系统分区调整为设备的最大大小："

msgid "Resize the filesystem to a new partition size:"
msgstr "将文件系统调整为新的分区大小："

msgid "Increasing the filesystem size can be done while it is mounted.  But you can also boot the board from an SD card and then resize the file system on the eMMC partition while it is not mounted."
msgstr "在文件系统挂载时可以增加其大小。但您也可以从SD卡启动板，然后在eMMC分区未挂载时调整文件系统的大小。"

msgid "Enable pseudo-SLC Mode"
msgstr "启用伪SLC模式"

#, fuzzy
msgid "e.MMC devices use MLC or TLC (https://en.wikipedia.org/wiki/Multi-level_cell) to store the data. Compared with SLC used in NAND Flash, MLC or TLC have lower reliability and a higher error rate at lower costs."
msgstr "eMMC设备使用 `MLC或TLC <https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E5%8D%95%E5%85%83>`_ 来存储数据。与NAND Flash中使用的SLC相比，MLC或TLC在成本更低的情况下，可靠性较低且错误率较高。"

msgid "If you prefer reliability over storage capacity, you can enable the pseudo-SLC mode or SLC mode. The method used here employs the enhanced attribute, described in the JEDEC standard, which can be set for continuous regions of the device. The JEDEC standard does not specify the implementation details and the guarantees of the enhanced attribute. This is left to the chipmaker. For the Micron chips, the enhanced attribute increases the reliability but also halves the capacity."
msgstr "如果您更喜欢可靠性而不是存储容量，可以启用伪SLC模式或SLC模式。这个方法采用了增强属性，该属性在JEDEC标准中有所描述，可以对设备的一个连续区域设置。JEDEC标准并未规定增强属性的实现细节和保证，这由芯片制造商自行决定。对于美光（Micron）芯片，增强属性提高了可靠性，但也将容量减半。"

msgid "When enabling the enhanced attribute on the device, all data will be lost."
msgstr "在设备上启用增强属性时，所有数据将被丢失。"

msgid "The following sequence shows how to enable the enhanced attribute."
msgstr "以下步骤展示了如何启用增强属性。"

#, fuzzy
msgid "First obtain the current size of the e.MMC device with:"
msgstr "首先使用以下命令获取eMMC设备的当前大小："

msgid "You will receive:"
msgstr "你将收到："

msgid "As you can see this device has 63652757504 Byte = 60704 MiB."
msgstr "如您所见，该设备的容量为 63652757504 字节 = 60704 MiB。"

msgid "To get the maximum size of the device after pseudo-SLC is enabled use:"
msgstr "要获取启用伪SLC模式后的设备的大小，请使用："

msgid "which shows, for example:"
msgstr "例如："

msgid "Here the maximum size is 3719168 KiB = 3632 MiB."
msgstr "这里的最大大小是3719168 KiB = 3632 MiB。"

msgid "Now, you can set enhanced attribute for the whole device, e.g. 3719168 KiB, by typing:"
msgstr "现在，您可以通过输入以下命令为整个设备设置增强属性，例如 3719168 KiB："

msgid "You will get:"
msgstr "你将获得："

msgid "To ensure that the new setting has taken over, shut down the system:"
msgstr "为了确保新设置已生效，请关闭系统："

msgid "and perform a power cycle. It is recommended that you verify the settings now."
msgstr "并进行上下电。建议您现在确认设置是否正确。"

msgid "First, check the value of ENH_SIZE_MULT which must be 3719168 KiB:"
msgstr "首先，检查ENH_SIZE_MULT的值，它必须是3719168 KiB："

msgid "You should receive::"
msgstr "您应该看到："

msgid "Finally, check the size of the device:"
msgstr "最后，检查设备的大小："

msgid "Erasing the Device"
msgstr "擦除设备"

#, fuzzy
msgid "It is possible to erase the e.MMC device directly rather than overwriting it with zeros. The e.MMC block management algorithm will erase the underlying MLC or TLC or mark these blocks as discard. The data on the device is lost and will be read back as zeros."
msgstr "可以直接擦除eMMC设备，而不是通过写零覆盖。eMMC块管理算法将擦除底层的MLC或TLC，或者将这些块标记为可丢弃。设备上的数据将丢失，并将被读取为零。"

msgid "After booting from SD Card execute:"
msgstr "SD卡启动后执行："

msgid "The option --secure ensures that the command waits until the eMMC device has erased all blocks. The -f (force) option disables all checking before erasing and it is needed when the eMMC device contains existing partitions with data."
msgstr "选项 --secure 确保命令在 eMMC 设备擦除所有块之前会等待。-f (强制) 选项强制擦写，当 eMMC 设备包含有效数据分区时需要使用-f选项。"

msgid "also destroys all information on the device, but this command is bad for wear leveling and takes much longer!"
msgstr "该命令也会擦除设备上的所有信息，但这个命令不利于设备的磨损均衡，并且需要花费更长的时间！"

#, fuzzy
msgid "e.MMC Boot Partitions"
msgstr "eMMC Boot分区"

#, fuzzy
msgid "An e.MMC device contains four different hardware partitions: user, boot1, boot2, and rpmb."
msgstr "eMMC设备包含四个不同的硬件分区：User分区、boot1分区、boot2分区和rpmb分区。"

#, fuzzy
msgid "The user partition is called the User Data Area in the JEDEC standard and is the main storage partition. The partitions boot1 and boot2 can be used to host the bootloader and are more reliable. Which partition the |soc| uses to load the bootloader is controlled by the boot configuration of the e.MMC device. The partition rpmb is a small partition and can only be accessed via a trusted mechanism."
msgstr "User分区在JEDEC标准中称为用户数据区，是主要的存储分区。分区boot1和boot2可以用于存放bootloader，并且更可靠。 |soc| 使用哪个分区加载bootloader由eMMC设备的引导配置控制。分区rpmb是一个小分区，只能通过受信任的机制访问。"

msgid "Furthermore, the user partition can be divided into four user-defined General Purpose Area Partitions. An explanation of this feature exceeds the scope of this document. For further information, see the JEDEC Standard Chapter 7.2 Partition Management."
msgstr "此外，User分区可以分为四个自定义的一般用途分区。对此功能的解释不在本文件涵盖的范围。有关更多信息，请参阅JEDEC标准第7.2章分区管理。"

#, fuzzy
msgid "Do not confuse e.MMC partitions with partitions of a DOS, MBR, or GPT partition table."
msgstr "不要将eMMC分区与DOS、MBR或GPT分区表的分区混淆。"

#, fuzzy
msgid "The current PHYTEC BSP does not use the extra partitioning feature of e.MMC devices. The U-Boot is flashed at the beginning of the user partition. The U-Boot environment is placed at a fixed location after the U-Boot. An MBR partition table is used to create two partitions, a FAT32 boot, and ext4 rootfs partition. They are located right after the U-Boot and the U-Boot environment. The FAT32 boot partition contains the kernel and device tree."
msgstr "当前的PHYTEC BSP没有使用eMMC设备的额外分区功能。U-Boot被烧写到用户分区的开始位置。U-Boot环境被放置在U-Boot之后的固定位置。使用MBR分区表创建两个分区，一个是FAT32引导分区，另一个是ext4根文件系统分区。它们位于U-Boot和U-Boot环境之后。FAT32引导分区包含内核和设备树。"

#, fuzzy
msgid "With e.MMC flash storage it is possible to use the dedicated boot partitions for redundantly storing the bootloader. The Bootloader environment still resides in the user area before the first partition. The user area also still contains the bootloader which the image first shipped during its initialization process. Below is an example, to flash the bootloader to one of the two boot partitions and switch the boot device via userspace commands."
msgstr "使用eMMC时，可以利用专用的boot分区备份存储bootloader。U-Boot环境仍然位于第一个分区之前的用户区。用户区仍然在出厂时包含bootloader。下面是一个示例，演示如何将bootloader烧写到两个启boot分区中的一个，并通过用户空间命令切换启动设备。"

msgid "Via userspace Commands"
msgstr "通过用户空间命令"

msgid "On the host, run:"
msgstr "在主机上运行："

#, fuzzy
msgid "The partitions boot1 and boot2 are read-only by default. To write to them from user space, you have to disable ``force_ro`` in the sysfs."
msgstr "默认情况下，boot1和boot2分区是只读的。要从用户空间写入它们，您必须在sysfs中禁用force_ro。"

#, fuzzy
msgid "To manually write the bootloader to the e.MMC boot partitions, first disable the write protection:"
msgstr "要手动将bootloader写入eMMC boot分区，首先禁用写保护："

#, fuzzy
msgid "Write the bootloader to the e.MMC boot partitions:"
msgstr "将bootloader写入eMMC boot分区："

msgid "The following table is for the offset of the |soc| SoC:"
msgstr "下表是 |soc| SoC的偏移量："

msgid "0 kiB"
msgstr "0 kiB"

#, fuzzy
msgid "After that set the boot partition from user space using the ``mmc`` tool:"
msgstr "之后使用mmc工具从用户空间设置引导分区："

msgid "(for 'boot0') :"
msgstr "(对于 'boot0') :"

msgid "(for 'boot1') :"
msgstr "(对于'boot1')："

#, fuzzy
msgid "To disable booting from the e.MMC boot partitions simply enter the following command:"
msgstr "要禁用从eMMC boot分区启动，只需输入以下命令："

msgid "To explicitly enable booting from the e.MMC user area, run:"
msgstr ""

msgid "SPI Master"
msgstr "SPI主设备"

msgid "The |soc| controller has a FlexSPI and an ECSPI IP core included. The FlexSPI host controller supports two SPI channels with up to 4 devices. Each channel supports Single/Dual/Quad/Octal mode data transfer (1/2/4/8 bidirectional data lines). The ECSPI controller supports 3 SPI interfaces with one dedicated chip selected for each interface. As chip selects should be realized with GPIOs, more than one device on each channel is possible."
msgstr "|soc| 控制器包含一个 FlexSPI 和一个 ECSPI IP 核。FlexSPI 主控制器支持两个 SPI 通道，最多可连接 4 个设备。每个通道支持单通道/双通道/四通道/八通道模式的数据传输（1/2/4/8 条数据线）。ECSPI 控制器支持 3 个 SPI 接口，每个接口都有一个专用的CS（chip select）引脚。由于CS也可通过 GPIO 实现，因此每个通道上可以连接多个设备。"

msgid "SPI NOR Flash"
msgstr "SPI NOR 烧写"

#, fuzzy
msgid "|som| is equipped with a QSPI NOR Flash which connects to the |soc|'s FlexSPI interface. The QSPI NOR Flash is suitable for booting. Please see different sections for flashing and bootmode setup. Due to limited space on the SPI NOR Flash, only the bootloader is stored inside. By default, the kernel, device tree, and rootfs are taken from eMMC."
msgstr "phyCORE-|soc| 配备有一个 QSPI NOR Flash，该 Flash 连接到 |soc| 的 FlexSPI 接口。QSPI NOR Flash 可用于启动。有关烧写和启动模式设置的详细信息，请参见不同的章节。由于 SPI NOR Flash 的空间有限，因此仅可存储bootloader。默认情况下，内核、设备树和根文件系统来自 eMMC。"

msgid "The Bootloader does detect with the help of the EEPROM Introspection data if an SPI flash is mounted or not. If no SPI flash is mounted a device tree overlay is applied with the expansion command to disable the SPI flash device tree node during boot. If no introspection data is available the SPI NOR flash node is always enabled. Find more information in the device tree overlay section."
msgstr "bootloader程序通过EEPROM数据检测是否安装了SPI Flash。如果没有安装SPI Flash，则在启动期间应用设备树overlay，通过扩展命令禁用SPI Flash设备树节点。如果没有可用的EEPROM数据，SPI NOR Flash节点将始终启用。有关更多信息，请参阅设备树overlay部分。"

msgid "The bootloader also passes the SPI MTD partition table to Linux by fixing up the device tree based on the mtdparts boot parameter. The default partition layout in the BSP is set to:"
msgstr "bootloader程序还可以通过内核的mtdparts启动参数修改设备树，将SPI MTD分区表传递给Linux。BSP中的默认分区布局设置为："

msgid "This is a bootloader environment variable that is defined here and can be changed during runtime. From Linux userspace, the NOR Flash partitions are accessible via /dev/mtd<N> devices where <N> is the MTD device number associated with the NOR flash partition to access. To find the correct MTD device number for a partition, run on the target:"
msgstr "这是一个预定义的bootloader环境变量，可以在运行时更改。从Linux用户空间，可以通过/dev/mtd<N>设备访问NOR Flash分区，其中<N>是与要访问的NOR Flash分区相关联的MTD设备编号。要找到分区的正确MTD设备编号，请在目标上运行："

msgid "It lists all MTD devices and the corresponding partition names. The flash node is defined inside of the SPI master node in the module DTS. The SPI node contains all devices connected to this SPI bus which is in this case only the SPI NOR Flash."
msgstr "它列出了所有MTD设备及其对应的分区名称。闪存节点在模块DTS中的SPI主节点内定义。SPI节点包含连接到此SPI总线的所有设备，在这种情况下只有SPI NOR Flash。"

msgid "The definition of the SPI master node in the device tree can be found here:"
msgstr "设备树中SPI主节点的定义可以在这里找到："

#, fuzzy
msgid ":linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phycore-som.dtsi#L77`"
msgstr ":linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L76`"

msgid "GPIOs"
msgstr "GPIOs"

msgid "The |sbc| has a set of pins especially dedicated to user I/Os. Those pins are connected directly to |soc| pins and are muxed as GPIOs. They are directly usable in Linux userspace. The processor has organized its GPIOs into five banks of 32 GPIOs each (GPIO1 – GPIO5) GPIOs. gpiochip0, gpiochip32, gpiochip64, gpiochip96, and gpiochip128 are the sysfs representation of these internal |soc| GPIO banks GPIO1 – GPIO5."
msgstr "|sbc| 具有一组专门用于GPIO的引脚。这些引脚直接连接到 |soc| 引脚，并被复用为 GPIO。它们可以直接在 Linux 用户空间中使用。处理器将其 GPIO 组织为5个GPIO组（GPIO1 – GPIO5），每个组包含 32 个GPIO。gpiochip0、gpiochip32、gpiochip64、gpiochip96 和 gpiochip128 是这些内部 |soc| GPIO 组 GPIO1 – GPIO5 的 sysfs 表示。"

msgid "The GPIOs are identified as GPIO<X>_<Y> (e.g. GPIO5_07). <X> identifies the GPIO bank and counts from 1 to 5, while <Y> stands for the GPIO within the bank. <Y> is being counted from 0 to 31 (32 GPIOs on each bank)."
msgstr "GPIO被标识为GPIO<X>_<Y>（例如：GPIO5_07）。<X>表示GPIO Bank，从1计数到5，而<Y>表示该Bank内的GPIO。<Y>从0计数到31（每个bank有32个GPIO）。"

msgid "By contrast, the Linux kernel uses a single integer to enumerate all available GPIOs in the system. The formula to calculate the right number is:"
msgstr "相比之下，Linux内核使用一个单一的整数来枚举系统中所有可用的GPIO。计算正确数字的公式是："

msgid "Accessing GPIOs from userspace will be done using the libgpiod. It provides a library and tools for interacting with the Linux GPIO character device. Examples of some usages of various tools:"
msgstr "从用户空间访问GPIO将使用libgpiod。它提供了一个库和工具，用于与Linux GPIO字符设备进行交互。以下是一些工具的用法示例："

msgid "Detecting the gpiochips on the chip:"
msgstr "检测芯片上的gpiochips："

msgid "Show detailed information about the gpiochips. Like their names, consumers, direction, active state, and additional flags:"
msgstr "显示关于gpiochips的详细信息，包括它们的名称、consumer、方向、活动状态和附加flag："

msgid "Read the value of a GPIO (e.g GPIO 20 from chip0):"
msgstr "读取GPIO的值（例如从gpiochip0的GPIO 20）："

msgid "Set the value of GPIO 20 on chip0 to 0 and exit tool:"
msgstr "将gpiochip0上的GPIO 20的值设置为0并退出工具："

msgid "Help text of gpioset shows possible options:"
msgstr "gpioset的帮助文本显示了可能的选项："

msgid "Some of the user IOs are used for special functions. Before using a user IO, refer to the schematic or the hardware manual of your board to ensure that it is not already in use."
msgstr "某些GPIO用于特殊功能。在使用某个GPIO之前，请参考您板子的原理图或硬件手册，以确保该IO未被其他功能占用。"

msgid "GPIOs via sysfs"
msgstr "通过sysfs访问GPIO"

msgid "Accessing gpios via sysfs is deprecated and we encourage to use libgpiod instead."
msgstr "通过sysfs访问GPIO已经过时了，我们建议使用libgpiod。"

msgid "Support to access GPIOs via sysfs is not enabled by default any more. It is only possible with manually enabling ``CONFIG_GPIO_SYSFS`` in the kernel configuration. To make ``CONFIG_GPIO_SYSFS`` visible in menuconfig the option ``CONFIG_EXPERT`` has to be enabled first."
msgstr "默认情况下不再支持通过sysfs访问GPIO。只有手动在内核配置中启用 ``CONFIG_GPIO_SYSFS`` 后才能支持。要在menuconfig中使 ``CONFIG_GPIO_SYSFS`` 可见，必须首先启用选项 ``CONFIG_EXPERT`` 。"

#, fuzzy
msgid "You can also add this option for example to the defconfig you use in ``arch/arm64/configs/`` in the linux kernel sources. For our NXP based releases, this could be for example |kernel-defconfig|::"
msgstr "您也可以将此选项添加到您在 Linux 内核源代码 ``arch/arm64/configs/`` 目录下使用的 defconfig 中。例如，我们基于 NXP 的BSP版本，这个defconfig可以是  ``imx8_phytec_distro.config`` ::"

msgid "Otherwise you can create a new config fragment. This is described in our |yocto-ref-manual-kernel-and-bootloader-conf|."
msgstr "您也可以创建一个新的config片段。有关详细信息，请参阅我们的 |yocto-ref-manual-kernel-and-bootloader-conf|。"

msgid "Pinmuxing of some GPIO pins in the device tree |dt-carrierboard|.dts:"
msgstr "设备树 |dt-carrierboard|.dts 中一些GPIO引脚的管脚复用："

msgid "LEDs"
msgstr "LED灯"

msgid "If any LEDs are connected to GPIOs, you have the possibility to access them by a special LED driver interface instead of the general GPIO interface (section GPIOs). You will then access them using ``/sys/class/leds/`` instead of ``/sys/class/gpio/``. The maximum brightness of the LEDs can be read from the ``max_brightness`` file. The brightness file will set the brightness of the LED (taking a value from 0 up to max_brightness). Most LEDs do not have hardware brightness support and will just be turned on by all non-zero brightness settings."
msgstr "如果有任何LED灯连接到GPIO管脚，您可以通过特定的LED驱动程序接口访问它们，而不是使用通用的GPIO接口（请参见GPIO部分）。您将通过 ``/sys/class/leds/`` 而不是 ``/sys/class/gpio/`` 来访问它们。LED的最大亮度可以从 ``max_brightness`` 文件中读取。brightness文件将设置LED的亮度（取值范围从0到max_brightness）。大多数LED硬件上不支持调整亮度，所以在所有非零亮度下都会点亮。"

msgid "Below is a simple example."
msgstr "下面是一个简单的例子。"

msgid "To get all available LEDs, type:"
msgstr "要获取所有可用的LED，请输入："

msgid "Here the LEDs blue-mmc, green-heartbeat, and red-emmc are on the |sbc|."
msgstr "这里的 LED 灯包括蓝色的 mmc、绿色的 心跳和红色的 emmc，它们都在 |sbc| 上。"

msgid "To toggle the LEDs ON:"
msgstr "打开LED灯："

msgid "To toggle OFF:"
msgstr "关闭LED："

#, fuzzy
msgid "Device tree configuration for the User I/O configuration can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L47`"
msgstr "GPIO的设备树配置：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L160`"

msgid "I²C Bus"
msgstr "I²C总线"

msgid "The |soc| contains several Multimaster fast-mode I²C modules. PHYTEC boards provide plenty of different I²C devices connected to the I²C modules of the |soc|. This section describes the basic device usage and its DT representation of some I²C devices integrated into our |sbc|."
msgstr "该 |soc| 包含多个多主支持快速模式的 I²C模块。PHYTEC板提供了许多不同的I²C设备，这些设备连接到 |soc| 的I²C模块。 本节描述了我们 |sbc| 中集成的一些I²C设备的基本设备使用及其设备树（DT）表示。"

msgid "The device tree node for i2c contains settings such as clock-frequency to set the bus frequency and the pin control settings including scl-gpios and sda-gpios which are alternate pin configurations used for bus recovery."
msgstr "i2c的设备树节点包含一些设置，例如时钟频率，用于设置总线频率，以及引脚控制设置，包括scl-gpios和sda-gpios，这些是用于总线恢复的备用引脚配置。"

#, fuzzy
msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phycore-som.dtsi#L105`"
msgstr "I²C3 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L88`"

#, fuzzy
msgid "General I²C4 bus configuration (e.g. |dt-carrierboard|.dts): :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L246`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L145`"

msgid "EEPROM"
msgstr "EEPROM"

msgid "On the |som| there is an i2c EEPROM flash populated. It has two addresses. The main EEPROM space (bus: I2C-0 address: 0x51) can be accessed via the sysfs interface in Linux. The first 256 bytes of the main EEPROM and the ID-page (bus: I2C-0 address: 0x59) are used for board detection and must not be overwritten. Therefore the ID-page can not be accessed via the sysfs interface. Overwriting reserved spaces will result in boot issues."
msgstr "在 |som| 上贴了一个 i2c 接口的 EEPROM 存储。它有两个地址。主 EEPROM 空间（总线：I2C-0 地址：0x51）可以通过 Linux 中的 sysfs 接口访问。主 EEPROM 的前 256 字节和 ID 页（总线：I2C-0 地址：0x59）用于板检测，不可修改。因此，ID 页不能通过 sysfs 接口访问。覆盖保留空间将导致启动问题。"

msgid "If you deleted reserved EEPROM spaces, please contact our support!"
msgstr "如果您删除了保留的EEPROM空间数据，请联系我们的支持团队！"

msgid "I2C EEPROM on |som|"
msgstr "|som| 上的I2C EEPROM"

msgid "The EEPROM ID page (bus: I2C-0 addr: 0x59) and the first 256 bytes of the normal EEPROM area (bus: I2C-0 addr: 0x51) should not be erased or overwritten. As this will influence the behavior of the bootloader. The board might not boot correctly anymore."
msgstr "EEPROM ID页面（总线：I2C-0 地址：0x59）和正常EEPROM区域的前256个字节（总线：I2C-0 地址：0x51）不可被擦除或修改。这将影响bootloader的行为。板子可能无法正确启动。"

msgid "The I2C EEPROM on the |som| SoM is connected to I2C address 0x51 on the I2C-0 bus. It is possible to read and write directly to the device populated:"
msgstr "|som| SoM上的I2C EEPROM连接到I2C-0总线的I2C地址0x51。可以直接对该设备进行读写操作："

msgid "To read and print the first 1024 bytes of the EEPROM as a hex number, execute:"
msgstr "要读取并以十六进制打印 EEPROM 的前 1024 字节，请执行："

msgid "To fill the 4KiB EEPROM (bus: I2C-0 addr: 0x51) with zeros leaving out the EEPROM data use:"
msgstr "要用零填充4KiB的EEPROM（总线：I2C-0 地址：0x51），并保留EEPROM数据，请使用："

msgid "EEPROM SoM Detection"
msgstr "EEPROM SoM 检测"

msgid "The I2C EEPROM, populated on the |som|, has a separate ID page that is addressable over I2C address 0x59 on bus 0 and a normal area that is addressable over I2C address 0x51 on bus 0. PHYTEC uses this data area of 32 Bytes to store information about the SoM. This includes PCB revision and mounting options."
msgstr "在 |som| 上配置的I2C EEPROM具有一个可通过I2C地址0x59在i2c0上寻址的独立ID页面，以及一个可通过I2C地址0x51在i2c0上寻址的正常区域。PHYTEC使用这个32字节的数据区域来存储关于SoM的信息，包括PCB版本和配置。"

msgid "The EEPROM data is read at a really early stage during startup. It is used to select the correct RAM configuration. This makes it possible to use the same bootloader image for different RAM sizes and choose the correct DTS overlays automatically."
msgstr "在启动的早期阶段读取EEPROM数据。它用于选择正确的DDR RAM配置。这使得可以使用相同的bootloader镜像来支持不同的RAM大小，并自动选择正确的DTS overlay。"

msgid "If the EEPROM ID page data and the first 256 bytes of the normal area are deleted, the bootloader will fall back to the |som| Kit RAM setup, which is |kit-ram-size| RAM."
msgstr "如果EEPROM ID页面数据和正常区域的前256个字节被删除，bootloader程序将回退到 |som| Kit RAM设置，即 |kit-ram-size| RAM。"

msgid "SoMs that are flashed with data format API revision 2 will print out information about the module in the early stage."
msgstr "使用API修订版2数据格式烧写的核心板将在早期启动阶段打印出有关模块的信息。"

#, fuzzy
msgid "DT representation, e.g. in |som| file |dt-som|.dtsi can be found in our PHYTEC git: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phycore-som.dtsi#L278`"
msgstr "核心板 phyCORE-|soc| 的设备树可以在PHYTEC git中找到： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L172`"

msgid "RTC"
msgstr "RTC"

msgid "RTCs can be accessed via ``/dev/rtc*``. Because PHYTEC boards have often more than one RTC, there might be more than one RTC device file."
msgstr "RTC可以通过 ``/dev/rtc*`` 访问。由于PHYTEC板通常有多个RTC，因此可能会有多个RTC设备文件。"

msgid "To find the name of the RTC device, you can read its sysfs entry with:"
msgstr "要找到RTC设备的名称，可以通过以下方式读取其sysfs条目："

msgid "You will get, for example:"
msgstr "例如，你将得到："

msgid "This will list all RTCs including the non-I²C RTCs. Linux assigns RTC device IDs based on the device tree/aliases entries if present."
msgstr "这将列出所有实时时钟（RTC），包括非I²C接口的RTC。如果存在设备树/aliases条目，Linux会根据这些条目分配RTC设备ID。"

msgid "Date and time can be manipulated with the ``hwclock`` tool and the date command. To show the current date and time set on the target:"
msgstr "日期和时间可以通过 ``hwclock`` 工具和date命令进行操作。要显示目标上设置的当前日期和时间："

msgid "Change the date and time with the date command. The date command sets the time with the following syntax \"YYYY-MM-DD hh:mm:ss (+|-)hh:mm\":"
msgstr "使用日期命令更改日期和时间。日期命令以以下语法设置时间：\"YYYY-MM-DD hh:mm:ss (+|-)hh:mm\"："

msgid "Your timezone (in this example +0100) may vary."
msgstr "您的时区（在此示例中为 +0100）可能会有所不同。"

msgid "Using the date command does not change the time and date of the RTC, so if we were to restart the target those changes would be discarded. To write to the RTC we need to use the ``hwclock`` command. Write the current date and time (set with the date command) to the RTC using the ``hwclock`` tool and reboot the target to check if the changes were applied to the RTC:"
msgstr "使用date命令并不会改变实时时钟（RTC）的时间和日期，因此如果我们重启开发板，这些更改将会被丢弃。要写入RTC，我们需要使用 ``hwclock`` 命令。使用 ``hwclock`` 工具将当前的日期和时间（通过date命令设置）写入RTC，然后重启开发板以检查更改是否已应用到RTC上："

msgid "To set the time and date from the RTC use:"
msgstr "要从实时时钟（RTC）设置系统时间和日期，请使用："

msgid "RTC Wakealarm"
msgstr "RTC唤醒alarm"

msgid "It is possible to issue an interrupt from the RTC to wake up the system. The format uses the Unix epoch time, which is the number of seconds since UTC midnight on 1 January 1970. To wake up the system after 4 minutes from suspend to ram state, type:"
msgstr "可以从实时时钟（RTC）发出中断以唤醒系统。该格式使用Unix纪元时间，即自1970年1月1日UTC午夜以来的秒数。要在从挂起到RAM状态后的4分钟唤醒系统，请输入："

msgid "Internally the wake alarm time will be rounded up to the next minute since the alarm function doesn't support seconds."
msgstr "内部唤醒alarm时间将被向上舍入到下一个分钟，因为alarm功能不支持秒。"

msgid "RTC Parameters"
msgstr "RTC参数"

msgid "RTCs have a few abilities which can be read/set with the help of ``hwclock`` tool."
msgstr "实时时钟（RTC）具有一些功能，可以通过 ``hwclock`` 工具进行读取和设置。"

msgid "We can check RTC supported features with:"
msgstr "我们可以通过以下方式检查RTC支持的功能："

msgid "What this value means is encoded in kernel, each set bit translates to:"
msgstr "这个值的含义在内核中进行了编码，每个位的定义为："

msgid "We can check RTC BSM (Backup Switchover Mode) with:"
msgstr "我们可以通过以下方式检查RTC BSM（Backup Switchover Mode 备份切换模式）："

msgid "We can set RTC BSM with:"
msgstr "我们可以通过以下方式设置RTC BSM："

msgid "What BSM values mean translates to these values:"
msgstr "BSM位的定义为："

msgid "You should set BSM mode to DSM or LSM for RTC to switch to backup power source when the initial power source is not available. Check **RV-3028** RTC datasheet to read what LSM (Level Switching Mode) and DSM (Direct Switching Mode) actually mean."
msgstr "您应该将BSM模式设置为DSM或LSM，以便在初始电源不可用时，RTC可以切换到备用电源。请查看 **RV-3028** RTC的Datasheet，以了解LSM（电平切换模式）和DSM（直接切换模式）这两个定义的工作模式。"

#, fuzzy
msgid "DT representation for I²C RTCs: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phycore-som.dtsi#L286`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L208`"

msgid "USB Host Controller"
msgstr "USB主控制器"

msgid "The USB controller of the |soc| SoC provides a low-cost connectivity solution for numerous consumer portable devices by providing a mechanism for data transfer between USB devices with a line/bus speed up to 480 Mbps (HighSpeed 'HS'). The USB subsystem has two independent USB controller cores. Both cores are On-The-Go (OTG) controller cores and are capable of acting as a USB peripheral device or a USB host. Each is connected to a USB 2.0 PHY."
msgstr "|soc| SoC的USB控制器为众多消费类便携设备提供了一种低成本的连接以及数据传输解决方案，传输速率最高可达480 Mbps（高速 'HS'）。USB子系统具有两个独立的USB控制器IP。两个IP都是即插即用（OTG）控制器IP，能够充当USB外设设备或USB主机。每个IP都连接到一个USB 2.0物理层（PHY）。"

msgid "The unified BSP includes support for mass storage devices and keyboards. Other USB-related device drivers must be enabled in the kernel configuration on demand. Due to udev, all mass storage devices connected get unique IDs and can be found in ``/dev/disk/by-id``. These IDs can be used in ``/etc/fstab`` to mount the different USB memory devices in different ways."
msgstr "BSP支持大容量存储设备（优盘）和键盘。其他与USB相关的设备驱动程序必须根据需要在内核配置中启用。由于udev，所有连接的存储设备都会获得唯一的ID，并可以在 ``/dev/disk/by-id`` 中找到。这些ID可以在 ``/etc/fstab`` 中用于以不同的方式挂载不同的USB存储设备。"

msgid "User USB2 (host) configuration is in the kernel device tree |dt-carrierboard|.dts:"
msgstr "USB2（host）配置在内核设备树 |dt-carrierboard|.dts 中："

#, fuzzy
msgid "DT representation for USB Host: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L353`"
msgstr "USB Host的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L380`"

msgid "USB OTG"
msgstr "USB OTG"

msgid "Most PHYTEC boards provide a USB OTG interface. USB OTG ports automatically act as a USB device or USB host. The mode depends on the USB hardware attached to the USB OTG port. If, for example, a USB mass storage device is attached to the USB OTG port, the device will show up as ``/dev/sda``."
msgstr "大多数PHYTEC板提供USB OTG接口。USB OTG端口会自动作为USB设备或USB主机工作。模式取决于连接到USB OTG端口的USB硬件。例如，如果将USB大容量存储设备连接到USB OTG端口，该设备将显示为 ``/dev/sda`` 。"

msgid "USB Device"
msgstr "作为USB设备"

msgid "In order to connect the board's USB device to a USB host port (for example a PC), you need to configure the appropriate USB gadget. With USB configfs you can define the parameters and functions of the USB gadget. The BSP includes USB configfs support as a kernel module."
msgstr "为了将开发板作为USB设备连接到USB主机（例如PC），您需要配置相应的USB gadget。通过USB configfs，您可以定义USB gadget的参数和功能。BSP包含作为kernel module 的USB configfs支持。"

msgid "**Example**:"
msgstr "**例子**:"

msgid "First, define the parameters such as the USB vendor and product IDs, and set the information strings for the English (0x409) language:"
msgstr "首先，定义参数，例如USB Vendor和product ID，并为英语（0x409）设置信息字符串："

msgid "To save time, copy these commands and execute them in a script"
msgstr "为了节省时间，请复制这些命令并在脚本中执行它们"

msgid "Next, create a file for the mass storage gadget:"
msgstr "接下来，为大容量存储 gadget 创建一个文件："

msgid "Now you should create the functions you want to use:"
msgstr "现在你可以创建你想要使用的功能："

msgid "*acm*: Serial gadget, creates serial interface like ``/dev/ttyGS0``."
msgstr "*acm*: 串行设备 gadget，创建类似 ``/dev/ttyGS0`` 的串行接口。"

msgid "*ecm*: Ethernet gadget, creates ethernet interface, e.g. usb0"
msgstr "*ecm*: 以太网 gadget，创建以太网接口，例如 usb0"

msgid "*mass_storage*: The host can partition, format, and mount the gadget mass storage the same way as any other USB mass storage."
msgstr "*mass_storage*: 主机可以像处理其他USB大容量存储设备一样，对设备的大容量存储进行分区、格式化和挂载。"

msgid "Bind the defined functions to a configuration:"
msgstr "将定义的功能绑定到配置："

msgid "Finally, start the USB gadget with the following commands:"
msgstr "最后，使用以下命令启动USB gadget："

msgid "If your system has more than one USB Device or OTG port, you can pass the right one to the USB Device Controller (UDC)."
msgstr "如果您的系统有多个USB设备或OTG端口，您可以将正确的端口传递给USB设备控制器（UDC）。"

msgid "To stop the USB gadget and unbind the used functions, execute:"
msgstr "要停止USB gadget 并解除绑定已使用的功能，请执行："

#, fuzzy
msgid "Both USB interfaces are configured as host in the kernel device tree |dt-carrierboard|.dts. See: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L342`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L239`"

msgid "CAN FD"
msgstr "CAN FD"

msgid "The |sbc| has one CAN interface supporting CAN FD. It is supported by the Linux standard CAN framework which builds upon then the Linux network layer. Using this framework, the CAN interfaces behave like an ordinary Linux network device, with some additional features special to CAN. More information can be found in the Linux Kernel documentation: https://www.kernel.org/doc/html/latest/networking/can.html"
msgstr "|sbc| 具有一个支持CAN FD的flexCAN接口。它们由Linux标准CAN框架支持，该框架建立在Linux网络层之上。使用该框架，CAN接口表现得像普通的Linux网络设备，并具有一些特定于CAN的附加功能。更多信息可以在Linux内核文档中找到：https://www.kernel.org/doc/html/latest/networking/can.html"

msgid "phyBOARD-Polis has an external CANFD chip MCP2518FD connected over SPI. There are different interfaces involved, which limits the datarate capabilities of CANFD."
msgstr "phyBOARD-Polis 具有一个通过 SPI 连接的外部 CAN FD 芯片 MCP2518FD。由于使用了SPI，限制了 CAN FD 的数据传输速率上限。"

msgid "On phyBOARD-Polis-i.MX8MM a terminating resistor can be enabled by setting S5 to ON if required."
msgstr "在phyBOARD-Polis-i.MX8MM上，如果需要，可以通过将S5设置为ON来启用端接电阻。"

msgid "Use:"
msgstr "使用："

msgid "to see the state of the interfaces. The two CAN interfaces should show up as can0 and can1."
msgstr "查看接口的状态。两个CAN接口显示为can0和can1。"

msgid "To get information on can0, such as bit rate and error counters, type:"
msgstr "要获取有关can0的信息，例如比特率和错误计数器，请输入："

msgid "The information for can0 will look like:"
msgstr "can0的信息将如下所示："

msgid "The output contains a standard set of parameters also shown for Ethernet interfaces, so not all of these are necessarily relevant for CAN (for example the MAC address). The following output parameters contain useful information:"
msgstr "输出包含一组标准参数，这些参数也适用于以太网接口，因此并非所有参数对于CAN都是相关的（例如MAC地址）。以下输出参数包含有用的信息："

msgid "can0"
msgstr "can0"

msgid "Interface Name"
msgstr "接口名称"

msgid "NOARP"
msgstr "NOARP"

msgid "CAN cannot use ARP protocol"
msgstr "CAN无法使用ARP协议"

msgid "MTU"
msgstr "MTU"

msgid "Maximum Transfer Unit"
msgstr "最大传输单元"

msgid "RX packets"
msgstr "RX packets"

msgid "Number of Received Packets"
msgstr "接收的数据包数量"

msgid "TX packets"
msgstr "TX packets"

msgid "Number of Transmitted Packets"
msgstr "发送的数据包数量"

msgid "RX bytes"
msgstr "RX bytes"

msgid "Number of Received Bytes"
msgstr "接收字节数"

msgid "TX bytes"
msgstr "TX bytes"

msgid "Number of Transmitted Bytes"
msgstr "发送字节数"

msgid "errors..."
msgstr "errors..."

msgid "Bus Error Statistics"
msgstr "总线错误统计信息"

msgid "The CAN configuration is done in the systemd configuration file ``/lib/systemd/network/can0.network``. For a persistent change of (as an example, the default bitrates), change the configuration in the BSP under ``./meta-ampliphy/recipes-core/systemd/systemd-conf/can0.network`` in the root filesystem and rebuild the root filesystem."
msgstr "CAN配置是在systemd配置文件 ``/lib/systemd/network/can0.network`` 中完成的。为了持久化更改（例如，默认比特率），请在BSP中更改根文件系统下的 ``./meta-ampliphy/recipes-core/systemd/systemd-conf/can0.network`` 中的配置，并重新编译根文件系统。"

msgid "The bitrate can also be changed manually, for example, to make use of the flexible bitrate:"
msgstr "比特率也可以手动更改，例如，设置为灵活比特率（flexible bitrate）："

msgid "You can send messages with cansend or receive messages with candump:"
msgstr "您可以使用cansend发送消息，或使用candump接收消息："

msgid "To generate random CAN traffic for testing purposes, use cangen:"
msgstr "要生成用于测试目的的随机CAN流量，请使用cangen："

msgid "``cansend --help`` and ``candump --help`` provide help messages for further information on options and usage."
msgstr "``cansend --help`` 和 ``candump --help`` 提供了关于选项和用法的帮助信息。"

msgid "The mcp2518fd SPI to CANfd supports only baudrates starting from 125kB/s. Slower rates can be selected but may not work correctly."
msgstr "mcp2518fd SPI到CAN FD只支持从125kB/s开始的波特率。可以选择更慢的速率，但可能无法正常工作。"

#, fuzzy
msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L178`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L130`"

msgid "PCIe"
msgstr "PCIe"

#, fuzzy
msgid "The |som| has one Mini-PCIe slot. In general, PCIe autodetects new devices on the bus. After connecting the device and booting up the system, you can use the command lspci to see all PCIe devices recognized."
msgstr "phyCORE-|soc| 具有一个 Mini-PCIe 插槽。一般来说，PCIe 会自动检测总线上的新设备。在连接设备并启动系统后，您可以使用命令 lspci 查看所有被识别的 PCIe 设备。"

msgid "Type:"
msgstr "输入："

msgid "In this example, the PCIe device is the *Intel Corporation WiFi Link 5100*."
msgstr "在这个例子中，PCIe设备是 *英特尔 WiFi Link 5100* 。"

msgid "For PCIe devices, you have to enable the correct driver in the kernel configuration. This WLAN card, for example, is manufactured by Intel. The option for the driver, which must be enabled, is named ``CONFIG_IWLWIFI`` and can be found under *Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimat* in the kernel configuration."
msgstr "对于PCIe设备，您必须在内核配置中启用正确的驱动程序。例如，这款WLAN卡是由英特尔制造的。必须启用的驱动程序选项名为 ``CONFIG_IWLWIFI`` ，可以在内核配置中的 *Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate* 下找到。"

msgid "In order to activate the driver, follow the instructions from our |yocto-ref-manual-kernel-and-bootloader-conf|."
msgstr "为了激活驱动程序，请按照我们的Yocto手册中的说明进行操作： |yocto-ref-manual-kernel-and-bootloader-conf| "

msgid "The linux-imx is represented by: **virtual/kernel**"
msgstr "linux-imx的表示为：**virtual/kernel**"

msgid "For some devices like the WLAN card, additional binary firmware blobs are needed. These firmware blobs have to be placed in ``/lib/firmware/`` before the device can be used."
msgstr "对于某些设备，如WLAN卡，需要额外的二进制固件文件。这些固件文件必须放置在 ``/lib/firmware/`` 目录中，才能使用该设备。"

msgid "For example, if you try to bring up the network interface:"
msgstr "例如，如果您尝试启动网络接口："

msgid "You will get the following output on the serial console:"
msgstr "您将在串口控制台上获得以下输出："

msgid "Some PCIe devices, e.g. the Ethernet card, may function properly even if no firmware blob is loaded from ``/lib/firmware/`` and you received an error message as shown in the first line of the output above. This is because some manufacturers provide the firmware as a fallback on the card itself. In this case, the behavior and output depend strongly on the manufacturer's firmware."
msgstr "某些PCIe设备，例如以太网卡，即使没有从 ``/lib/firmware/`` 加载固件文件，也可能正常工作，而你收到了如上输出第一行所示的错误消息。这是因为一些制造商在板卡本身提供了固件作为后备。在这种情况下，设备的行为和输出在很大程度上依赖于制造商的固件。"

#, fuzzy
msgid "Device Tree PCIe configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-rdk.dts#L260`"
msgstr "|dt-carrierboard|.dts 的设备树 PCIE 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L345`"

msgid "Audio"
msgstr "音频"

msgid "The PEB-AV-10-Connector exists in two versions and the 1531.1 version is populated with a TI TLV320AIC3007 audio codec. Audio support is done via the I2S interface and controlled via I2C."
msgstr "PEB-AV-10-Connector有两个版本，其中1531.1版本配备了TI TLV320AIC3007音频编解码器（CODEC）。音频数据通过I2S传输，并通过I2C进行控制。"

msgid "There is a 3.5mm headset jack with OMTP standard and an 8-pin header to connect audio devices with the AV-Connector.  The 8-pin header contains a mono speaker, headphones, and line-in signals."
msgstr "有一个符合OMTP标准的3.5mm耳机插孔和一个8针接口，用于连接带有AV连接器的音频设备。这个8针接口包含单声道扬声器、耳机和线路输入信号（line-in）。"

msgid "To check if your soundcard driver is loaded correctly and what the device is called, type for playback devices:"
msgstr "要检查您的声卡驱动程序是否正确加载以及设备名称，请输入以下命令以查看播放设备："

msgid "Or type for recording devices:"
msgstr "或输入录音设备："

msgid "Alsamixer"
msgstr "Alsamixer"

msgid "To inspect the capabilities of your soundcard, call:"
msgstr "要检查声卡的功能，请输入："

msgid "You should see a lot of options as the audio-IC has many features you can experiment with. It might be better to open alsamixer via ssh instead of the serial console, as the console graphical effects are better. You have either mono or stereo gain controls for all mix points. \"MM\" means the feature is muted (both output, left & right), which can be toggled by hitting '**m**'. You can also toggle by hitting '**<**' for left and '**>**' for right output. With the **tab** key, you can switch between controls for playback and recording."
msgstr "您应该会看到很多选项，因为音频IC具有许多可以测试的功能。通过SSH打开alsamixer的图形界面比通过调试串口打开更易于使用。所有混音点都有单声道或立体声增益控制。\"MM\"表示该功能被静音（左右输出均为静音），可以通过按' **m** '切换。您还可以通过按' **<** ' 左和 ' **>** '切换右声道输出。使用 **tab** 键，您可以在播放和录音控制之间切换。"

msgid "Restore default volumes"
msgstr "恢复默认音量"

msgid "There are some default settings stored in ``/var/lib/alsa/asound.state``. You can save your current alsa settings with:"
msgstr "一些默认设置存储在 ``/var/lib/alsa/asound.state`` 中。您可以使用以下命令保存当前的alsa设置："

msgid "You can restore saved alsa settings with:"
msgstr "您可以通过以下方式恢复已保存的alsa设置："

msgid "ALSA configuration"
msgstr "ALSA配置"

msgid "Our BSP comes with a ALSA configuration file ``/etc/asound.conf``."
msgstr "我们的BSP附带一个ALSA配置文件 ``/etc/asound.conf`` 。"

msgid "The ALSA configuration file can be edited as desired or deleted since it is not required for ALSA to work properly."
msgstr "ALSA配置文件可以根据需要进行编辑或删除，它并不是ALSA正常工作所必需的。"

msgid "To set PEB-AV-10 as output, set *playback.pcm* from \"dummy\" to \"pebav10\":"
msgstr "要将PEB-AV-10设置为输出，请将 *playback.pcm* 从 \"dummy\" 设置为 \"pebav10\":"

msgid "If the sound is not audible change playback devices to the software volume control playback devices, set *playback.pcm* to the respective softvol playback device e.g. \"softvol_pebav10\". Use alsamixer controls to vary the volume levels."
msgstr "如果听不到声音，请将播放设备更改为软件音量控制播放设备，将 *playback.pcm* 设置为相应的软音量播放设备，例如“softvol_pebav10”。使用alsamixer控制来调整音量级别。"

msgid "Pulseaudio Configuration"
msgstr "PulseAudio 配置"

msgid "For applications using *Pulseaudio*, check for available sinks:"
msgstr "对于使用 *Pulseaudio* 的应用程序，请检查可用的音频输出设备："

msgid "To select the output device, type:"
msgstr "要选择输出设备，请输入："

msgid "Playback"
msgstr "播放"

msgid "Run speaker-test to check playback availability:"
msgstr "运行speaker-test以检查播放功能："

msgid "To playback simple audio streams, you can use aplay. For example to play the ALSA test sounds:"
msgstr "要播放简单的音频流，您可以使用aplay。例如，要播放ALSA测试音频："

msgid "To playback other formats like mp3 for example, you can use Gstreamer:"
msgstr "要播放其他格式，例如mp3，您可以使用Gstreamer："

msgid "Capture"
msgstr "录音"

msgid "``arecord`` is a command-line tool for capturing audio streams which use Line In as the default input source. To select a different audio source you can use ``alsamixer``. For example, switch on *Right PGA Mixer Mic3R* and *Left PGA Mixer Mic3R* in order to capture the audio from the microphone input of the TLV320-Codec using the 3.5mm jack."
msgstr "``arecord`` 是一个命令行工具，用于录制音频流，默认输入源为线路输入。要选择不同的音频源，可以使用 ``alsamixer``。例如，打开 *右侧 PGA 混音器 Mic3R* 和 *左侧 PGA 混音器 Mic3R*，以便通过 3.5mm 插孔录制来自 TLV320 编解码器的麦克风输入音频。"

msgid "Since playback and capture share hardware interfaces, it is not possible to use different sampling rates and formats for simultaneous playback and capture operations."
msgstr "由于播放和录音共享硬件接口，因此无法在同时进行播放和录音操作时使用不同的采样率和格式。"

#, fuzzy
msgid "Device Tree Audio configuration: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-peb-av-10.dtso#L52`"
msgstr "音频的设备树配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso#L56`"

msgid "Video"
msgstr "视频"

msgid "Videos with Gstreamer"
msgstr "视频与Gstreamer"

msgid "One example video is installed by default in the BSP at `/usr/share/qtphy/videos/`. Start the video playback with one of these commands:"
msgstr "默认情况下，BSP安装了一个示例视频，路径为 `/usr/share/qtphy/videos/` 。可以使用以下命令之一开始视频播放："

msgid "Or:"
msgstr "或者："

msgid "Display"
msgstr "显示"

msgid "The 10\" Display is always active. If the PEB-AV-Connector is not connected, an error message may occur at boot."
msgstr "10英寸显示屏始终处于使能状态。如果PEB-AV连接器未连接，启动时可能会出现错误信息。"

msgid "Qt Demo"
msgstr "Qt Demo"

msgid "With the ``phytec-qt6demo-image``, Weston starts during boot. Our Qt6 demo application named \"qtphy\" can be stopped with:"
msgstr "使用 ``phytec-qt6demo-image`` 时，Weston会在启动时启动。我们的Qt6 DEMO应用程序名为“qtphy”，可以通过以下方式停止："

msgid "To start the demo again, run:"
msgstr "要重新开始Demo，请运行："

msgid "To disable autostart of the demo, run:"
msgstr "要禁用Demo的自动启动，请运行："

msgid "To enable autostart of the demo, run:"
msgstr "要启用Demo的自动启动，请运行："

msgid "Weston can be stopped with:"
msgstr "Weston可以通过以下方式停止："

msgid "The Qt demo must be closed before Weston can be closed."
msgstr "在关闭Weston之前，必须先关闭Qt Demo。"

msgid "Backlight Control"
msgstr "背光控制"

msgid "If a display is connected to the PHYTEC board, you can control its backlight with the Linux kernel sysfs interface. All available backlight devices in the system can be found in the folder /sys/class/backlight. Reading the appropriate files and writing to them allows you to control the backlight."
msgstr "如果LCD连接到PHYTEC开发板，可以通过Linux内核的sysfs接口控制其背光。系统中所有可用的背光设备可以在文件夹/sys/class/backlight中找到。读取相应的文件并向其写入数据可以控制背光。"

msgid "Some boards with multiple display connectors might have multiple backlight controls in /sys/class/backlight. For example: backlight0 and backlight1"
msgstr "一些具有多显示的开发板在 /sys/class/backlight 有多个背光控制。比如：backlight0和backlight1"

msgid "To get, for example, the maximum brightness level (max_brightness) execute:"
msgstr "例如，要获取最大亮度级别（max_brightness），请执行："

msgid "Valid brightness values are 0 to <max_brightness>."
msgstr "有效的亮度值范围是 0 到 <max_brightness>。"

msgid "To obtain the current brightness level, type:"
msgstr "要获取当前亮度级别，请输入："

msgid "Write to the file brightness to change the brightness:"
msgstr "写入文件brightness以更改亮度："

msgid "turns the backlight off for example."
msgstr "例如，关闭背光。"

msgid "For documentation of all files, see https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-class-backlight."
msgstr "有关所有文件的文档，请参见 https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-class-backlight。"

#, fuzzy
msgid "The device tree of PEB-AV-10 can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx8mm-phyboard-polis-peb-av-10.dtso`"
msgstr "PEB-AV-10的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso`"

msgid "Power Management"
msgstr "电源管理"

msgid "CPU Core Frequency Scaling"
msgstr "CPU核心频率调节"

msgid "The CPU in the |soc| SoC is able to scale the clock frequency and the voltage. This is used to save power when the full performance of the CPU is not needed. Scaling the frequency and the voltage is referred to as 'Dynamic Voltage and Frequency Scaling' (DVFS). The |soc| BSP supports the DVFS feature. The Linux kernel provides a DVFS framework that allows each CPU core to have a min/max frequency and a governor that governs it. Depending on the |socfamily| variant used, several different frequencies are supported."
msgstr "|soc| SoC中的CPU能够调整时钟频率和电压。这用于在不需要CPU的全部性能时节省电力。调整频率和电压被称为“动态电压和频率调整”（DVFS）。|soc| BSP支持DVFS功能。Linux内核提供了一个DVFS框架，允许每个CPU核心设置最小或最大频率和一个管理其运行的governor。根据使用的 |socfamily| 型号，支持几种不同的频率。"

msgid "Although the DVFS framework provides frequency settings for each CPU core, a change in the frequency settings of one CPU core always affects all other CPU cores too. So all CPU cores always share the same DVFS setting. An individual DVFS setting for each core is not possible."
msgstr "尽管DVFS框架为每个CPU核心提供了频率设置，但一个CPU核心的频率更改会影响其他CPU核心。因此，所有CPU核心始终共享相同的DVFS设置。每个核心的单独DVFS设置是不可能的。"

msgid "To get a complete list type:"
msgstr "要获取完整列表，请输入："

msgid "In case you have, for example, i.MX 8MPlus CPU with a maximum of approximately 1,6 GHz, the result will be:"
msgstr "例如 i.MX 8MPlus CPU，最高可达约 1.6 GHz，则结果将是："

msgid "To ask for the current frequency type:"
msgstr "要查询当前的频率输入："

msgid "So-called governors are automatically selecting one of these frequencies in accordance with their goals."
msgstr "governor 会根据它们的目标自动选择这些频率中的一个。"

msgid "List all governors available with the following command:"
msgstr "列出所有可用的 governor，使用以下命令："

msgid "The result will be:"
msgstr "结果是："

msgid "**conservative** is much like the ondemand governor. It differs in behavior in that it gracefully increases and decreases the CPU speed rather than jumping to max speed the moment there is any load on the CPU."
msgstr "**conservative** governor 与 ondemand governor 非常相似。只是它的行为有所不同，它会更保守地增减CPU速度，而不是在CPU有任何负载的瞬间就跳到最大速度。"

msgid "**ondemand** (default) switches between possible CPU core frequencies in reference to the current system load. When the system load increases above a specific limit, it increases the CPU core frequency immediately."
msgstr "**ondemand** （默认）根据当前系统负载在可能的CPU核心频率之间切换。当系统负载超过特定值时，它会立即提高CPU核心频率。"

msgid "**powersave** always selects the lowest possible CPU core frequency."
msgstr "**powersave** 始终选择最低的CPU核心频率。"

msgid "**performance** always selects the highest possible CPU core frequency."
msgstr "**performance** 始终选择最高的CPU核心频率。"

msgid "**userspace** allows the user or userspace program running as root to set a specific frequency (e.g. to 1600000). Type:"
msgstr "**userspace** 允许以root身份运行的用户或用户空间程序设置特定频率（例如，设置为1600000）。输入："

msgid "In order to ask for the current governor, type:"
msgstr "要查询当前的 governor，请输入："

msgid "You will normally get:"
msgstr "您通常会得到："

msgid "Switching over to another governor (e.g. userspace) is done with:"
msgstr "切换到另一个governor（例如，userspace）可以通过以下方式完成："

msgid "Now you can set the speed:"
msgstr "现在你可以设置频率："

msgid "For more detailed information about the governors, refer to the Linux kernel documentation in the linux kernel repository at ``Documentation/admin-guide/pm/cpufreq.rst``."
msgstr "有关governor的更详细信息，请参阅Linux内核代码库中的Linux内核文档，路径为 ``Documentation/admin-guide/pm/cpufreq.rst`` 。"

msgid "CPU Core Management"
msgstr "CPU核心管理"

msgid "The |soc| SoC can have multiple processor cores on the die. The |soc|, for example, has 4 ARM Cores which can be turned on and off individually at runtime."
msgstr "该 |soc| SoC 芯片上可以有多个处理器核心。例如，该 |soc| 具有 4 个 ARM 核心，可以在运行时单独开启和关闭。"

msgid "To see all available cores in the system, execute:"
msgstr "要查看系统中所有可用的核心，请执行："

msgid "This will show, for example:"
msgstr "这将显示，例如："

msgid "Here the system has four processor cores. By default, all available cores in the system are enabled to get maximum performance."
msgstr "这里系统有四个处理器核心。默认情况下，系统中所有可用的核心都被启用，以获得最佳性能。"

msgid "To switch off a single-core, execute:"
msgstr "要关闭某个核，请执行："

msgid "As confirmation, you will see:"
msgstr "作为确认，您将看到："

msgid "Now the core is powered down and no more processes are scheduled on this core."
msgstr "现在核心已关闭电源，并且该核心上不再安排任何进程。"

msgid "You can use top to see a graphical overview of the cores and processes:"
msgstr "您可以使用 top 命令查看核心和进程的图形概览："

msgid "To power up the core again, execute:"
msgstr "要重新启用核心，请执行："

msgid "Suspend to RAM"
msgstr "挂起到RAM"

msgid "The |som| supports basic suspend and resume. Different wake-up sources can be used. Suspend/resume is possible with:"
msgstr "|som| 支持基本的挂起和恢复。可以使用不同的唤醒源。挂起/恢复可以通过以下方式实现："

msgid "To wake up with serial console run"
msgstr "要通过串行控制台唤醒，请运行"

msgid "Thermal Management"
msgstr "热管理"

msgid "U-Boot"
msgstr "U-Boot"

msgid "The previous temperature control in the U-Boot was not satisfactory. Now the u-boot has a temperature shutdown to prevent the board from getting too hot during booting. The temperatures at which the shutdown occurs are identical to those in the kernel."
msgstr "之前U-Boot中的温度控制不够理想。现在，U-Boot增加了温度关机功能，以防止在启动过程中板子过热。关机发生的温度与内核中的温度一致。"

msgid "The individual temperature ranges with the current temperature are displayed in the boot log:"
msgstr "当前温度的各个温度范围在启动日志中显示："

msgid "Kernel"
msgstr "内核"

msgid "The Linux kernel has integrated thermal management that is capable of monitoring SoC temperatures, reducing the CPU frequency, driving fans, advising other drivers to reduce the power consumption of devices, and – worst-case – shutting down the system gracefully (https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt)."
msgstr "Linux内核集成了热管理功能，能够监测芯片（SoC）温度，降低CPU频率，控制风扇，通知其他驱动程序减少功耗，并在最坏的情况下关闭系统（https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt）。"

msgid "This section describes how the thermal management kernel API is used for the |soc| SoC platform. The |socfamily| has internal temperature sensors for the SoC."
msgstr "本节描述了如何在 |soc| SoC 平台上使用热管理内核 API。 |socfamily| 具有用于 SoC 的内部温度传感器。"

msgid "The current temperature can be read in millicelsius with:"
msgstr "当前温度可以以毫摄氏度为单位读取："

msgid "There are two trip points registered by the imx_thermal kernel driver. These differ depending on the CPU variant. A distinction is made between Industrial and Commercial."
msgstr "imx_thermal内核驱动注册了两个触发点。这些触发点根据CPU型号的不同而有所不同。主要区分工业版和商业版。"

msgid "Commercial"
msgstr "商业"

msgid "Industrial"
msgstr "工业"

msgid "passive (warning)"
msgstr "被动（警告）"

msgid "85°C"
msgstr "85°C"

msgid "95°C"
msgstr "95°C"

msgid "critical (shutdown)"
msgstr "严重（关机）"

msgid "90°C"
msgstr "90°C"

msgid "100°C"
msgstr "100°C"

msgid "(see kernel sysfs folder ``/sys/class/thermal/thermal_zone0/``)"
msgstr "（请查看内核 sysfs 文件夹 ``/sys/class/thermal/thermal_zone0/``）"

msgid "The kernel thermal management uses these trip points to trigger events and change the cooling behavior. The following thermal policies (also named thermal governors) are available in the kernel: Step Wise, Fair Share, Bang Bang, and Userspace. The default policy used in the BSP is step_wise. If the value of the SoC temperature in the sysfs file temp is above *trip_point_0*, the CPU frequency is set to the lowest CPU frequency. When the SoC temperature drops below *trip_point_0* again, the throttling is released."
msgstr "内核热管理使用这些触发点来触发事件并实施冷却措施。内核中可用的热政策（也称为thermal governor）包括：Step Wise、Fair Share、Bang Bang和Userspace。BSP中使用的默认策略是Step Wise。如果sysfs文件temp中的SoC温度值高于 *trip_point_0* ，则CPU频率将设置为最低CPU频率。当SoC温度降到 *trip_point_0* 以下时，限制将被解除。"

msgid "The actual values of the thermal trip points may differ since we mount CPUs with different temperature grades."
msgstr "由于我们安装了不同温度等级的CPU，因此热触发点的实际值可能会有所不同。"

msgid "GPIO Fan"
msgstr "GPIO风扇"

msgid "|pollux-fan-note|"
msgstr "|pollux-fan-note|"

msgid "A GPIO fan can be connected to the |sbc|-|soc|. The SoC only contains one temperature sensor which is already used by the thermal frequency scaling. The fan can not be controlled by the kernel. We use lmsensors with hwmon for this instead. lmsensors reads the temperature periodically and enables or disables the fan at a configurable threshold. For the |sbc|-|soc|, this is 60°C."
msgstr "一个GPIO控制的风扇可以连接到 |sbc|-|soc|。该SoC包含一个温度传感器，该传感器被用于热频率调节。风扇无法通过内核进行控制。我们使用lmsensors和hwmon来实现这一点。lmsensors定期读取温度，并在可配置的阈值下启用或禁用风扇。对于  |sbc|-|soc|，这个阈值是60°C。"

msgid "The settings can be configured in the configuration file:"
msgstr "设置可以在配置文件中进行配置："

msgid "Fan control is started by a systemd service during boot. This can be disabled with:"
msgstr "风扇控制在启动时由systemd服务启动。可以通过以下方式禁用它："

msgid "Watchdog"
msgstr "看门狗"

msgid "The PHYTEC |soc| modules include a hardware watchdog that is able to reset the board when the system hangs. The watchdog is started on default in U-Boot with a timeout of 60s. So even during early kernel start, the watchdog is already up and running. The Linux kernel driver takes control over the watchdog and makes sure that it is fed. This section explains how to configure the watchdog in Linux using systemd to check for system hangs and during reboot."
msgstr "PHYTEC |soc| 模块包含一个硬件看门狗，当系统挂起时能够重置开发板。看门狗在 U-Boot 中默认启动，超时时间为 60 秒。因此，即使在早期内核启动过程中，看门狗也已经开始运行。Linux 内核驱动程序控制看门狗，并确保它有被踢到。本节将解释如何使用 systemd 在 Linux 中配置看门狗，以避免系统挂起和重启期间的情况。"

msgid "Watchdog Support in systemd"
msgstr "Systemd中的看门狗支持"

msgid "Systemd has included hardware watchdog support since version 183."
msgstr "Systemd 从版本 183 开始支持硬件看门狗。"

msgid "To activate watchdog support, the file system.conf in ``/etc/systemd/`` has to be adapted by enabling the options:"
msgstr "要启用看门狗支持，需要通过启用选项来配置 ``/etc/systemd/`` 中的文件system.conf文件："

msgid "*RuntimeWatchdogSec* defines the timeout value of the watchdog, while *ShutdownWatchdogSec* defines the timeout when the system is rebooted. For more detailed information about hardware watchdogs under systemd can be found at http://0pointer.de/blog/projects/watchdog.html. The changes will take effect after a reboot or run:"
msgstr "*RuntimeWatchdogSec* 定义了看门狗的超时时间，而 *ShutdownWatchdogSec* 定义了系统重启时的超时时间。有关 systemd 下硬件看门狗的更多详细信息，请访问 http://0pointer.de/blog/projects/watchdog.html。更改将在重启后生效，或者运行："

msgid "On-Chip OTP Controller (OCOTP_CTRL) - eFuses"
msgstr "片上一次性可编程控制器 (OCOTP_CTRL) - eFuse"

msgid "The |soc| provides one-time programmable fuses to store information such as the MAC address, boot configuration, and other permanent settings (\"On-Chip OTP Controller (OCOTP_CTRL)\" in the |soc| Reference Manual). The following list is an abstract from the |soc| Reference Manual and includes some useful registers in the OCOTP_CTRL (at base address 0x30350000):"
msgstr "该 |soc| 提供一次性可编程fuse，用于存储信息，例如 MAC 地址、启动配置和其他永久设置（在 |soc| reference manual中称为“片上 OTP 控制器 (OCOTP_CTRL)”）。以下列表摘自 |soc| reference manual，包括 OCOTP_CTRL 中的一些有用寄存器（基地址为0x30350000）："

msgid "Name"
msgstr "名称"

msgid "Bank"
msgstr "Bank"

msgid "Word"
msgstr "字"

msgid "Memory offset at 0x30350000"
msgstr "内存偏移量为0x30350000"

msgid "Description"
msgstr "描述"

msgid "OCOTP_MAC_ADDR0"
msgstr "OCOTP_MAC_ADDR0"

msgid "9"
msgstr "9"

msgid "0"
msgstr "0"

msgid "0x640"
msgstr "0x640"

msgid "contains lower 32 bits of ENET0 MAC address"
msgstr "包含ENET0 MAC地址的低32位"

msgid "OCOTP_MAC_ADDR1"
msgstr "OCOTP_MAC_ADDR1"

msgid "1"
msgstr "1"

msgid "0x650"
msgstr "0x650"

msgid "contains upper 16 bits of ENET0 MAC address and the lower 16 bits of ENET1 MAC address"
msgstr "包含ENET0 MAC地址的高16位和ENET1 MAC地址的低16位"

msgid "OCOTP_MAC_ADDR2"
msgstr "OCOTP_MAC_ADDR2"

msgid "2"
msgstr "2"

msgid "0x660"
msgstr "0x660"

msgid "contains upper 32 bits of ENET1 MAC address"
msgstr "包含 ENET1 MAC 地址的高 32 位"

msgid "A complete list and a detailed mapping between the fuses in the OCOTP_CTRL and the boot/mac/... configuration are available in the section \"Fuse Map\" of the |soc| Security Reference Manual."
msgstr "关于OCOTP_CTRL中的fuse与启动配置之间的完整列表和详细映射，请参阅 |soc| Security Reference Manual中的 \"Fuse Map\" 部分。"

msgid "Reading Fuse Values in uBoot"
msgstr "在uBoot中读取fuse的值"

msgid "You can read the content of a fuse using memory-mapped shadow registers. To calculate the memory address, use the fuse Bank and Word in the following formula:"
msgstr "您可以使用内存映射的shadow寄存器读取fuse寄存器。要计算内存地址，请使用以下公式计算："

msgid "OCOTP_MAC_ADDR:"
msgstr "OCOTP_MAC_ADDR:"

msgid "Reading Fuse Values in Linux"
msgstr "在Linux中读取fuse值"

msgid "To access the content of the fuses in Linux NXP provides the NVMEM_IMX_OCOTP module. All fuse content of the memory-mapped shadow registers is accessible via sysfs:"
msgstr "要访问Linux中的fuse内容，NXP提供了NVMEM_IMX_OCOTP模块。所有内存映射的shadow寄存器的fuse内容可以通过sysfs访问："

msgid "|soc| |mcore|"
msgstr "|soc| |mcore|"

msgid "In addition to the Cortex-A53 cores, there is a Cortex-|mcore| as MCU integrated into the |soc| SoC. Our Yocto-Linux-BSP runs on the A53-Cores and the |mcore| can be used as a secondary core for additional tasks using bare-metal or RTOS firmware. Both cores have access to the same peripherals and thus peripheral usage needs to be limited either in the |mcore|'s firmware or the devicetree for the Linux operating system. This section describes how to build firmware examples and how to run them on |sbc|."
msgstr "除了Cortex-A53核心外，SoC中还集成了一个Cortex-|mcore| 作为MCU。我们的Yocto-Linux-BSP在A53核心上运行，而 |mcore| 可以作为辅助CPU，用于使用裸机或RTOS固件执行额外任务。两种核心都可以访问相同的外设，因此外设的使用需要在 |mcore| 的固件或Linux操作系统的设备树中进行限制。本节将描述如何编译固件示例以及如何在 |sbc| 上运行它们。"

msgid "The |sbc| is currently supported by the NXP MCUXpresso SDK and by The Zephyr Project. This section only describes the NXP MCUXpresso SDK because the MCUXpresso SDK has more supported features at the moment."
msgstr "|sbc| 目前由 NXP MCUXpresso SDK 和 Zephyr 项目支持。本节仅描述 NXP MCUXpresso SDK，因为目前 MCUXpresso SDK 支持的功能更多。"

msgid "If you want to use the |mcore| with The Zephyr Project, please refer to the The Zephyr Project documentation:"
msgstr "如果您想在Zephyr项目中使用 |mcore| ，请参考Zephyr项目文档："

msgid "|mcore-zephyr-docs|"
msgstr "|mcore-zephyr-docs|"

msgid "Getting the Firmware Examples"
msgstr "获取固件示例"

msgid "The firmware can be built using the NXP MCUxpresso SDK with a compatible compiler toolchain using command-line tools."
msgstr "固件可以使用NXP MCUxpresso SDK和兼容的编译工具链通过命令行工具进行编译。"

msgid "Getting the Sources"
msgstr "获取源代码"

msgid "The MCUX SDK and the examples for the |soc| can be obtained from PHYTEC's GitHub page:"
msgstr "MCUX SDK以及 |soc| 的示例可以从PHYTEC的GitHub页面获取："

msgid "https://github.com/phytec/mcux-sdk/"
msgstr "https://github.com/phytec/mcux-sdk/"

msgid "https://github.com/phytec/mcux-sdk-phytec-examples/"
msgstr "https://github.com/phytec/mcux-sdk-phytec-examples/"

msgid "Initialize the MCUX SDK via west:"
msgstr "通过west初始化MCUX SDK："

msgid "This will create a mcuxsdk directory with the mcux-sdk repository in it. The ``mcux-sdk-phytec-examples`` repository will be automatically cloned into the mcuxsdk directory. The given argument <VERSION> is a the branch name of the mcux-sdk repository that represents the MCUX SDK version. For the newest tested version you can use |mcore-sdk-version|."
msgstr "这将创建一个 mcuxsdk 目录，并在其中包含 mcux-sdk 仓库。``mcux-sdk-phytec-examples`` 仓库将自动克隆到 mcuxsdk 目录中。给定的参数 <VERSION> 是 mcux-sdk 仓库的分支名称，代表 MCUX SDK 版本。要获取最新的测试版本，您可以使用 |mcore-sdk-version|。"

msgid "``west`` is a repository management tool and a part of the Zephyr Project. To install west, you can use pip. In this example west is installed in a python virtual environment::"
msgstr "``west`` 是一个仓库管理工具，也是 Zephyr 项目的一部分。要安装 west，您可以使用 pip。在这个示例中，west 被安装在一个 Python 虚拟环境中::"

msgid "Update the dependencies:"
msgstr "更新依赖项："

msgid "The directory ``examples-phytec`` contains all examples ported and tested for |sbc| with version |mcore-sdk-version| of MCUX."
msgstr "目录 ``examples-phytec`` 包含了所有移植并测试过的示例，适用于 |sbc| 和版本为 |mcore-sdk-version| 的 MCUX。"

msgid "To build the firmware, a compiler toolchain and make/cmake are required. The GNU Arm Embedded Toolchain may be available in your distribution's repositories, e.g. for Ubuntu."
msgstr "要编译固件，需要一个编译器工具链和make/cmake。GNU ARM 嵌入式工具链可能在您的主机linux发行版的仓库中可用，例如Ubuntu。"

msgid "The compiler toolchain can also be obtained directly from https://developer.arm.com/. After the archive has been extracted, the ``ARMGCC_DIR`` has to be added to the environment, e.g. for the ARM toolchain 10-2020-q4-major release located in the home directory:"
msgstr "编译器工具链也可以直接从 https://developer.arm.com/ 获取。在解压缩文件后，必须将 ``ARMGCC_DIR`` 添加到环境变量中，例如，对于位于主目录中的 ARM toolchain 10-2020-q4-major 版本："

msgid "Building the Firmware"
msgstr "编译固件"

msgid "To build the PHYTEC samples an environment has to be sourced"
msgstr "要编译PHYTEC示例，需要先设置环境"

msgid "The scripts to build the firmware are located in <sdk-directory>/phytec-mcux-boards/phyboard-pollux/<example_category>/<example>/armgcc. There are scripts for each memory location the firmware is supposed to run in, e.g."
msgstr "编译固件的脚本位于 <sdk-directory>/phytec-mcux-boards/phyboard-pollux/<example_category>/<example>/armgcc。每个可运行的内存位置都有相应的编译脚本，例如："

msgid "to build the firmware for the |mcore|'s TCM. The output will be placed under release/ in the armgcc directory. .bin files and can be run in U-Boot and .elf files within Linux."
msgstr "要编译运行在 |mcore| 的 TCM 上的固件。输出将放置在 armgcc 目录下的 release/ 中。.bin 文件可以在 U-Boot 中运行，而 .elf 文件可以在 Linux 中运行。"

msgid "To build the firmware for the DRAM, run the script build_ddr_release. The script of the firmware that is supposed to run, e.g."
msgstr "要编译在DRAM上运行的固件，请运行脚本build_ddr_release。例如。"

msgid "The output will be placed under ddr_release/ in the armgcc directory. .bin files and can be run in U-Boot and .elf files within Linux."
msgstr "输出将放置在armgcc目录下的ddr_release/中。.bin文件可以在U-Boot中运行，而.elf文件可以在Linux中运行。"

msgid "Running |mcore| Examples"
msgstr "运行 |mcore| 示例"

msgid "There are two ways to run the |mcore| with the built firmware, U-Boot and Remoteproc within a running Linux."
msgstr "有两种方法可以运行 |mcore| 的固件，在Linux中使用Remoteproc以及在U-Boot。"

msgid "To receive debug messages start your favorite terminal software (e.g. Minicom, Tio, or Tera Term) on your host PC and configure it for 115200 baud, 8 data bits, no parity, and 1 stop bit (8n1) with no handshake."
msgstr "要接收调试信息，请在您的主机PC上启动您喜欢的终端软件（例如Minicom、Tio或Tera Term），并将其配置为115200波特率、8个数据位、无奇偶校验和1个停止位（8n1），且不使用握手。"

msgid "Once a micro-USB cable is connected to the USB-debug port on the |sbc|, two ttyUSB devices are registered. One prints messages from A53-Core's debug UART and the other one from the |mcore|'s debug UART."
msgstr "一旦Micro USB电缆连接到 |sbc| 上的USB调试端口，就会注册两个ttyUSB设备。一个打印来自A53核心的调试UART的消息，另一个打印来自 |mcore| 的调试UART的消息。"

msgid "Running Examples from U-Boot"
msgstr "从U-Boot运行示例"

msgid "To load firmware using the bootloader U-Boot, the bootaux command can be used:"
msgstr "要使用bootloader U-Boot加载固件，可以使用bootaux命令："

msgid "Prepare an SD Card with our Yocto-BSP"
msgstr "准备一张烧写了BSP镜像的SD卡"

msgid "Copy the generated .bin file to the SD Cards first partition"
msgstr "将生成的 .bin 文件复制到 SD 卡的第一个分区"

msgid "Stop the autoboot by pressing any key"
msgstr "通过按任意键停止自动启动"

msgid "Type the command depending on the type of firmware:"
msgstr "根据固件类型输入命令："

msgid "For firmware built to run in the |mcore|'s TCM::"
msgstr "对于在 |mcore| 的TCM中运行的固件："

msgid "For firmware built to run in the DRAM::"
msgstr "用于在DRAM中运行的固件："

msgid "The program's output should appear on the |mcore|'s debug UART."
msgstr "程序的输出应显示在 |mcore| 的调试UART上。"

msgid "Running Examples from Linux using Remoteproc"
msgstr "通过Remoteproc在Linux上运行示例"

msgid "Remoteproc is a module that allows you to control the |mcore| from Linux during runtime. Firmware built for TCM can be loaded and the execution started or stopped. To use Remoteproc a devicetree overlay needs to be set:"
msgstr "Remoteproc是一个模块，允许您在运行时从Linux控制 |mcore| 。可以加载为TCM编译的固件，并可以启动或停止执行。要使用Remoteproc，需要设置设备树Overlay："

msgid "Edit the bootenv.txt file located in the /boot directory on the target by adding |dtbo-rpmsg|:"
msgstr "在开发板的/boot目录中编辑bootenv.txt文件，添加 |dtbo-rpmsg| ："

msgid "Restart the target and execute in U-Boot::"
msgstr "重启目标并在U-Boot中执行::"

msgid "Firmware .elf files for the |mcore| can be found under /lib/firmware. To load the firmware, type:"
msgstr "|mcore| 的固件 .elf 文件可以在 /lib/firmware 下找到。要加载固件，请输入："

msgid "To load a different firmware, the |mcore| needs to be stopped:"
msgstr "要加载不同的固件，|mcore| 需要停止："

msgid "The samples found in ``/lib/firmware`` on the target come from NXP's Yocto layer meta-imx. To use the samples you built yourself through MCUX SDK, please copy them to ``/lib/firmware`` on the target after building them."
msgstr "在开发板上找到的 ``/lib/firmware`` 中的例子来自NXP的Yocto层meta-imx。要使用您通过MCUX SDK自己编译的样本，请在编译后将它们复制到开发板的 ``/lib/firmware`` 中。"

msgid "Debugging Using J-Link"
msgstr "使用J-Link进行调试"

msgid "The Segger software can be obtained from https://www.segger.com/downloads/jlink/. As of version V7.20a of the Segger software, accessing the |soc|' |mcore| requires additional configuration files to be copied into the J-Link software directory: NXP J-Link files for |soc|"
msgstr "Segger软件可以从https://www.segger.com/downloads/jlink/获取。从Segger软件的V7.20a版本开始，访问 |soc| 的 |mcore| 需要将额外的配置文件复制到J-Link软件目录中：NXP J-Link文件用于 |soc| "

msgid "Together with the J-Link, GDB Server can be used for running and debugging the software.  On the |sbc|, the JTAG-Pins are accessible via the |expansion-connector| Expansion Connector. The simplest way is to use a PEB-EVAL-01 board that has the JTAG-Pins reachable with a pin header on the top."
msgstr "与J-Link一起，GDB服务器可用于运行和调试软件。在 |sbc| 上，JTAG引脚可以通过 |expansion-connector| 扩展连接器访问。最简单的方法是使用PEB-EVAL-01开发板，该开发板的顶部有一个JTAG接口。"

msgid "To start the J-Link software, type:"
msgstr "要启动J-Link软件，请输入："

msgid "To start GDB with a firmware example in another window, type:"
msgstr "使用GDB调试运行固件，请输入："

msgid "BSP Extensions"
msgstr "BSP扩展"

msgid "Chromium"
msgstr "Chromium"

msgid "Our BSP for the |sbc|-|soc| supports Chromium. You can include it in the |yocto-imagename| with only a few steps."
msgstr "我们的BSP支持Chromium。您只需几个步骤即可将其包含在 |yocto-imagename| 中。"

msgid "Adding Chromium to Your local.conf"
msgstr "将Chromium添加到您的local.conf文件中"

msgid "To include Chromium you have to add the following line into your local.conf. You can find it in <yocto_dir>/build/conf/local.conf. This adds Chromium to your next image build. ::"
msgstr "要包含Chromium，您需要在您的local.conf中添加以下行。您可以在<yocto_dir>/build/conf/local.conf中找到这个配置文件。这将把Chromium添加到您下一个镜像编译中。::"

msgid "Compiling Chromium takes a long time."
msgstr "编译Chromium需要很长时间。"

msgid "Get Chromium Running on the Target"
msgstr "在开发板上运行Chromium"

msgid "To run Chromium, it needs a few arguments to use the hardware graphics acceleration::"
msgstr "要运行Chromium，需要一些参数来使用硬件图形加速："

msgid "If you want to start Chromium via SSH, you must first define the display on which Chromium will run. For example::"
msgstr "如果您想通过SSH启动Chromium，您必须首先定义运行Chromium的显示器。例如："

msgid "After you have defined this, you can start it via virtual terminal on Weston as shown above."
msgstr "在您定义完这个之后，您可以通过上述所示的Weston虚拟终端启动它。"

msgid "Table of Contents"
msgstr "目录"

msgid "HEAD"
msgstr "HEAD"

#, fuzzy
msgid "BSP-Yocto-NXP-i.MX8MM-PD25.1.0"
msgstr "BSP-Yocto-NXP-i.MX8MM-PD23.1.0"

msgid "BSP-Yocto-NXP-i.MX8MM-PD23.1.0"
msgstr "BSP-Yocto-NXP-i.MX8MM-PD23.1.0"

msgid "BSP-Yocto-NXP-i.MX8MM-PD22.1.1"
msgstr "BSP-Yocto-NXP-i.MX8MM-PD22.1.1"

msgid "|soc| BSP Manual"
msgstr "|soc| BSP手册"

msgid "2023/05/25"
msgstr "2023/05/25"

msgid "|yocto-manifestname|"
msgstr "|yocto-manifestname|"

msgid "Minor"
msgstr "小更新"

msgid "2023/05/23"
msgstr "2023/05/23"

msgid "Released"
msgstr "已发布"

msgid "The |kit| is shipped with a pre-flashed SD card. It contains the |yocto-imagename| and can be used directly as a boot source. The eMMC is programmed with only a U-boot by default. You can get all sources from the `PHYTEC download server <dl-server_>`_. This chapter explains how to flash a BSP image to SD card and how to start the board."
msgstr "该 |kit| 包含预先烧写好的SD卡。它包含 |yocto-imagename| ，可以直接用作启动盘。默认情况下，核心板的eMMC仅烧写了U-boot。您可以从 `PHYTEC下载服务器 <dl-server_>`_ 获取所有源代码。本章解释了如何将BSP镜像烧录到SD卡以及如何启动开发板。"

msgid "The WIC image contains all BSP files in several, correctly pre-formatted partitions and can be copied to an SD card easily using the single Linux command ``dd``. It can be built by Yocto or downloaded from the PHYTEC download server."
msgstr "WIC镜像包含预先格式化的分区信息以及分区中包含的BSP文件，可以使用单个Linux命令 ``dd`` 轻松写入到SD卡上。WIC镜像可以通过Yocto编译或从PHYTEC下载服务器下载。"

msgid "Get the WIC file from the download server:"
msgstr "从下载服务器获取WIC文件："

msgid "To create your bootable SD card with the ``dd`` command, you must have root privileges. Be very careful when specifying the destination device with ``dd``! All files on the selected destination device will be erased immediately without any further query!"
msgstr "要使用 ``dd`` 命令创建SD卡启动盘，您必须具有root权限。在使用 ``dd`` 指定目标设备时请务必小心！所选设备上的所有文件将在命令执行后立即被擦除，而且擦除前不会有任何进一步的确认！"

msgid "Selecting the wrong device may result in **data loss** and e.g. could erase your currently running system!"
msgstr "选择错误的设备可能会导致 **数据丢失** ，例如，可能会擦除您当前所在PC上的系统！"

msgid "To create your bootable SD card, you must first find the correct device name of your SD card and possible partitions. Unmount any mounted partitions before you start copying the image to the SD card."
msgstr "要创建SD卡启动盘，首先要找到PC上您SD卡对应的正确设备名称。在开始将镜像复制到SD卡之前，请卸载任何已挂载的分区。"

msgid "In order to get the correct device name, remove your SD card and execute::"
msgstr "为了获取正确的设备名称，请移除您的SD卡并执行："

msgid "Now insert your SD card and execute the command again::"
msgstr "现在插入你的SD卡，然后再次执行该命令："

msgid "Unmount all partitions, e.g.::"
msgstr "卸载所有分区，例如："

msgid "After having unmounted all partitions, you can create your bootable SD card::"
msgstr "在卸载所有分区后，您可以创建SD卡启动盘："

msgid "Again, make sure to replace ``/dev/sdX`` with your actual device name found previously."
msgstr "再次确保将 ``/dev/sdX`` 替换为之前找到的设备名称。"

msgid "An alternative and much faster way to prepare an SD card can be done by using `bmap-tools <https://github.com/intel/bmap-tools>`_ from Intel. Yocto automatically creates a block map file (``<IMAGENAME>-<MACHINE>.wic.bmap``) for the WIC image that describes the image content and includes checksums for data integrity. *bmaptool* is packaged by various Linux distributions. For Debian-based systems install it by issuing::"
msgstr "准备SD卡启动盘的另一种更快的方法是使用Intel的 `bmap-tools <https://github.com/intel/bmap-tools>`_ 。Yocto会自动为WIC镜像创建一个block map文件（ ``<IMAGENAME>-<MACHINE>.wic.bmap`` ），该文件描述了镜像内容并包含数据完整性的校验。 *bmaptool* 已被多种Linux发行版支持。对于基于Debian的系统，可以通过以下命令安装："

msgid "Flash a WIC image to SD card by calling::"
msgstr "通过以下命令将WIC镜像烧写到SD卡："

msgid "**phytec-qt5demo-image\\*.tar.gz**: Root file system"
msgstr "**phytec-qt5demo-image\\*.tar.gz**: 根文件系统"

msgid "**phytec-qt5demo-image\\*.wic**: SD card image"
msgstr "**phytec-qt5demo-image\\*.wic**: SD卡镜像"

msgid "To boot from eMMC, make sure that the BSP image is flashed correctly to the eMMC and the |ref-bootswitch| is set to **Default SOM boot**."
msgstr "要从eMMC启动，请确保BSP镜像已正确烧录到eMMC，并且 |ref-bootswitch| 设置为 **默认SOM启动** 。"

msgid "Flash eMMC from Network in u-boot on Target"
msgstr "在开发板的u-boot环境中从网络烧写eMMC"

msgid "These steps will show how to update the eMMC via a network. However, they only work if the size of the image file is less than 1GB. If the image file is larger, go to the section Format SD Card. Configure the |ref-bootswitch| to boot from SD Card and put in an SD card. Power on the board and stop in U-Boot prompt."
msgstr "这些步骤将展示如何通过网络更新eMMC。然而，此步骤仅在镜像文件小于1GB的情况下会被执行成功。如果镜像文件更大，请转到“格式化SD卡”一节。配置 |ref-bootswitch| 以从SD卡启动，并插入一张SD卡。给开发板上电并进入U-Boot环境。"

msgid "A working network is necessary! Setup Network Host."
msgstr "需要保证设备和存储镜像的主机之间的网络正常！设置主机网络。"

msgid "Take a compressed or uncompressed image on the host and send it with ssh through the network (then uncompress it, if necessary) to the eMMC of the target with a one-line command:"
msgstr "使用一条命令，通过网络ssh协议将带有块映射的压缩或未压缩的镜像发送到开发板的eMMC上使用,执行："

msgid "Send the image with the command dd command combined with ssh through the network to the eMMC of your device:"
msgstr "通过网络使用ssh将镜像用dd命令发送到您设备的eMMC："

msgid "Flash eMMC u-boot image via Network from running u-boot"
msgstr "在u-boot中通过网络烧写eMMC u-boot镜像"

msgid "Update the standalone u-boot image imx-boot is also possible from u-boot. This can be used if the bootloader on eMMC is located in the eMMC user area."
msgstr "如果eMMC上的bootloader位于eMMC的User区，从u-boot中更新独立的u-boot镜像imx-boot也是可能的。"

msgid "Flash eMMC from USB"
msgstr "从USB烧写eMMC"

msgid "Flash eMMC from USB in u-boot on Target"
msgstr "在u-boot上从USB烧写eMMC"

msgid "This step only works if the size of the image file is less than 1GB due to limited usage of RAM size in Bootloader after enabling the OPTEE."
msgstr "此步骤仅在镜像文件大小小于1GB时有效，因为在启用OPTEE后，Bootloader中可用的RAM大小有限。"

msgid "These steps will show how to update the eMMC via a USB device. Configure the bootmode switch to |ref-bootswitch| and put in an SD card. Power on the board and stop in u-boot prompt. Insert a USB device with the copied WIC image to the USB slot."
msgstr "下面这些步骤展示如何通过USB设备更新eMMC。将启动模式开关配置为 |ref-bootswitch| 并插入SD卡。给开发板上电并进入U-Boot环境。将已存储了未压缩WIC镜像的优盘插入开发板USB接口。"

msgid "These steps will show how to flash the eMMC on Linux with a USB stick. You only need a complete image saved on the USB stick and a bootable WIC image. (e.g. |yocto-imagename|-|yocto-machinename|.wic). Set the bootmode switch to |ref-bootswitch|."
msgstr "下面这些步骤展示如何在Linux系统上使用USB大容量存储设备烧写eMMC。您需要一个保存了完整镜像的U盘和一个可从SD卡启动的核心板（例如 |yocto-imagename|-|yocto-machinename|.wic）。将引导模式开关设置为 |ref-bootswitch|。"

msgid "Show list of available MMC devices:"
msgstr "显示可用的MMC设备列表："

msgid "The eMMC device can be recognized by the fact that it contains two boot partitions: (mmcblk2boot0; mmcblk2boot1)"
msgstr "eMMC设备的特征是它包含两个boot分区：(mmcblk2boot0; mmcblk2boot1)"

msgid "Before this will work, you need to configure the multi-port switch to **Default SOM Boot** to |ref-bootswitch|."
msgstr "在此之前，您需要将启动配置开关配置 |ref-bootswitch| 设置为 **默认SOM启动**。"

msgid "Flash eMMC from SD card in u-boot on Target"
msgstr "在u-boot上从SD卡烧写eMMC"

msgid "This step only works if the size of the image file is less than 1GB due to limited usage of RAM size in Bootloader after enabling the OPTEE. If the image file is too large use the `Updating eMMC from SD card in Linux on Target` subsection."
msgstr "此步骤仅在镜像文件大小小于1GB的情况下有效，因为在启用OPTEE后，Bootloader中可用的RAM大小有限。如果镜像文件太大，请使用“在目标上使用Linux从SD卡更新eMMC”一节。"

msgid "Flash an SD card with a working image and create a third FAT partition. Copy the WIC image (for example |yocto-imagename|.wic) to this partition."
msgstr "将一个可用的镜像烧写到SD卡，并创建一个FAT格式的第三分区。将WIC镜像（例如 |yocto-imagename|.wic）复制到该分区。"

msgid "Configure the bootmode switch to boot from the SD Card and insert the SD card."
msgstr "将启动模式开关配置为从SD卡启动，并插入SD卡。"

msgid "Power on the board and stop in u-boot."
msgstr "给开发板上电并进入u-boot环境。"

msgid "Flash your WIC image (for example |yocto-imagename|.wic) from the SD card to eMMC. This will partition the card and copy imx-boot, Image, dtb, dtbo, and root file system to eMMC."
msgstr "将您的WIC镜像（例如 |yocto-imagename|.wic）从SD卡烧写到eMMC。这将对卡进行分区，并将imx-boot、Image、dtb、dtbo和根文件系统复制到eMMC。"

msgid "Switch the mmc dev:"
msgstr "切换mmc设备："

msgid "Power off the board and change the multi-port switch to Default SOM Boot to boot from eMMC."
msgstr "关闭电源，将启动模式开关切换到默认SOM启动，以从eMMC启动。"

msgid "You can also flash the eMMC on Linux. You only need a complete image saved on the SD card (e.g. |yocto-imagename|-|yocto-machinename|.wic)."
msgstr "您也可以在Linux上烧写eMMC。您只需在SD卡上保存一个完整的镜像（例如 |yocto-imagename|-|yocto-machinename|.wic）。"

msgid "Show your saved image files on the SD card:"
msgstr "查看您在SD卡上保存的镜像文件："

msgid "The eMMC device can be recognized by the fact that it contains two boot partitions: (mmcblk2\\ **boot0**; mmcblk2\\ **boot1**)"
msgstr "eMMC设备的特征是它包含两个boot分区：(mmcblk2\\  **boot0**; mmcblk2\\  **boot1**)"

#, fuzzy
msgid "Write the image to the |som| eMMC (MMC device 2 **without** partition):"
msgstr "将镜像写入 phyCORE-|soc| 的 eMMC (MMC 设备 2 **不带** 分区)："

msgid "Before this will work, you need to configure the |ref-bootswitch| to Default SOM Boot to boot from eMMC."
msgstr "在此之前，您需要将 |ref-bootswitch| 配置为默认SOM启动，以从eMMC启动。"

msgid "The |som| modules are optionally equipped with SPI NOR Flash. To boot from SPI Flash, set |ref-bootswitch| to **QSPI boot** to boot from QSPI. The SPI Flash is usually quite small. The phyBOARD-Pollux-i.MX8MP kit only has 32MB SPI NOR flash populated. Only the bootloader and the environment can be stored. The kernel, device tree, and file system are taken from eMMC by default."
msgstr "|som| 模块可选配SPI NOR Flash。要从SPI Flash启动，请将 |ref-bootswitch| 设置为 **QSPI启动** 以从QSPI启动。SPI Flash通常容量较小。phyBOARD-Pollux-i.MX8MP套件仅配备32MB SPI NOR Flash。只能存储bootloader及其环境。内核、设备树和文件系统默认保存在eMMC。"

msgid "Flash SPI NOR from Network in u-boot on Target"
msgstr "在开发板的u-boot环境中从网络烧写SPI NOR"

msgid "Similar to updating the eMMC over a network, be sure to set up the development host correctly. The IP needs to be set to 192.168.3.10, the netmask to 255.255.255.0, and a TFTP server needs to be available. Before reading and writing is possible, the SPI-NOR flash needs to be probed:"
msgstr "与通过网络更新eMMC类似，请确保正确设置开发主机。IP需要设置为192.168.3.10，子网掩码设置为255.255.255.0，并且需要有一个TFTP服务器。在进行读写操作之前，需要对SPI-NOR Flash进行probe："

msgid "A specially formatted u-boot image for the SPI NOR flash is used. Ensure you use the correct image file. Load the image over tftp, erase and write the bootloader to the flash:"
msgstr "需要用特殊格式的SPI NOR Flash u-boot镜像。请确保使用正确的镜像文件。通过tftp加载镜像，擦除并将bootloader写入flash："

msgid "Erasing the complete SPI NOR flash when it is fully written will take quite some time. This can trigger the watchdog to reset. Due to this, erase the full flash in Linux."
msgstr "在写满后擦除整个SPI NOR Flash将需要相当长的时间。这可能会触发看门狗复位。因此，请在Linux中擦除整个闪存。"

msgid "Find the number of erase blocks of the U-boot partition:"
msgstr "找到U-boot分区的擦除块数量："

msgid "Flash SPI NOR from SD Card in u-boot on Target"
msgstr "在开发板的u-boot环境中从SD卡烧写SPI NOR"

msgid "Copy the SPI NOR flash U-boot image imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi to the FAT partition on the SD Card. Before reading and writing are possible, the SPI-NOR flash needs to be probed:"
msgstr "将SPI NOR Flash的U-boot镜像imx-boot-|yocto-machinename|-fspi.bin-flash_evk_flexspi复制到SD卡的FAT分区。在进行读写操作之前，需要对SPI-NOR flash进行probe："

msgid "Find the number of erase blocks of the u-boot partition:"
msgstr "查找u-boot分区的擦除块数量："

msgid "The RAUC (Robust Auto-Update Controller) mechanism support has been added to meta-ampliphy. It controls the procedure of updating a device with new firmware. This includes updating the Linux kernel, Device Tree, and root filesystem. PHYTEC has written an online manual on how we have intergraded RAUC into our BSPs: `L-1006e.A3 RAUC Update & Device Management Manual <https://www.phytec.de/cdocuments/?doc=BKXvGQ>`__."
msgstr "BSP支持RAUC（Robust Auto-Update Controller）。它管理设备固件更新的过程。这包括更新Linux内核、设备树和根文件系统。PHYTEC已撰写了一份在线手册，介绍如何在我们的BSP中集成RAUC：`L-1006e.A3 RAUC 更新与设备管理手册 <https://www.phytec.de/cdocuments/?doc=BKXvGQ>`__。"

msgid "Copy the kernel image to your tftp directory:"
msgstr "将内核镜像复制到您的tftp目录中："

msgid "Copy the devicetree to your tftp directory:"
msgstr "将设备树复制到您的tftp目录："

msgid "Copy all the overlays you want to use into your tftp directory:"
msgstr "将您想要使用的所有overlay文件复制到您的tftp目录中："

msgid "<overlayfilenames> has to be replaced with the devicetree overlay filenames that you want to use. Separate the filenames by spaces. For example:"
msgstr "<overlayfilenames> 必须替换为您想要使用的overlay设备树文件名。用空格分隔文件名。例如："

msgid "All supported devicetree overlays are in the |ref-dt| chapter."
msgstr "所有支持的设备树overlay在 |ref-dt| 章节中。"

msgid "Download imx-boot from our server or get it from your Yocto build directory at build/deploy/images/|yocto-machinename|/. For flashing a wic image to eMMC, you will also need |yocto-imagename|-|yocto-machinename|.wic."
msgstr "可以从我们的服务器下载imx-boot，或者从Yocto编译目录中的build/deploy/images/|yocto-machinename|/获取它。要将wic镜像烧写到eMMC，你还需要 |yocto-imagename|-|yocto-machinename|.wic。"

msgid "The **tag** needed at this release is called |u-boot-tag|"
msgstr "此版本的 **tag** 称为 |u-boot-tag|"

msgid "Technically, you can now build the U-Boot, but practically there are some further steps necessary:"
msgstr "从技术上讲，您现在可以编译U-Boot，但实际上还需要一些进一步的步骤："

msgid "Create your own development branch:"
msgstr "创建您自己的开发分支："

msgid "You can name your development branch as you like, this is just an example."
msgstr "您可以根据您的需要自行命名您的开发分支，这只是一个示例。"

msgid "Set this environment variable before building the Image:"
msgstr "在编译镜像之前，请设置此环境变量："

msgid "The flash.bin can be found at u-boot-imx/ directory and now can be flashed. A chip-specific offset is needed:"
msgstr "flash.bin 文件可以在 u-boot-imx/ 目录中找到。需要一个特定于芯片的偏移量："

msgid "/dev/mmcblk2"
msgstr "/dev/mmcblk2"

msgid "The Image can be found at ~/|kernel-repo-name|/arch/arm64/boot/Image"
msgstr "镜像可以在 ~/|kernel-repo-name|/arch/arm64/boot/Image 找到"

msgid "Copy Kernel to SD Card"
msgstr "将内核复制到SD卡"

msgid "When one-time boot via netboot is not sufficient, the kernel along with its modules and the corresponding device tree blob may be copied directly to a mounted SD card."
msgstr "内核及module和对应的设备树二进制文件可以用以下方式复制到已挂载的SD卡上。"

msgid "*Carrierboard.dtsi* - Devices that come from the |soc| SoC but are just routed down to the carrier board and used there are included in this dtsi."
msgstr "*Carrierboard.dtsi* - 包括来自于 |soc| SoC 的外设，在底板上使用的外设的设备树配置包含在这个 dtsi 中。"

#, fuzzy
msgid "*Board.dts* - include the carrier board and module dtsi files. There may also be some hardware configuration nodes enabled on the carrier board or the module (i.e. the Board .dts shows the special characteristics of the board configuration). For example, there are |som| SOMs which may or may not have a MIPI DSI to LVDS converter mounted. The converter is enabled (if available) in the Board .dts and not in the Module .dtsi"
msgstr "*Board.dts* - 包含底板和核心板的dtsi文件。以及使能一些底板或核心板上的器件和配置。例如，phyCORE-|soc| 核心板可能安装MIPI DSI到LVDS的转换器也可能没有，则Board.dts文件会根据安装情况来对该转换器进行使能配置。而不是在Module.dtsi中配置"

msgid "Device Tree overlays are device tree fragments that can be merged into a device tree during boot time. These are for example hardware descriptions of an expansion board. They are instead of being added to the device tree as an extra include, now applied as an overlay. They also may only contain setting the status of a node depending on if it is mounted or not. The device tree overlays are placed next to the other device tree files in our Linux kernel repository in the subfolder ``arch/arm64/boot/dts/freescale/overlays``."
msgstr "设备树Overlay是可以在启动时合并到设备树中的设备树片段。例如扩展板的硬件描述。对比源码中的include，overlay是用覆盖的方式来生效。overlay也可以根据节点是否连接来设置节点状态。设备树Overlay与我们Linux内核仓库中的其他设备树文件一起放在子文件夹 ``arch/arm64/boot/dts/freescale/overlays`` 中。"

#, python-brace-format
msgid "The ``${overlays}`` U-Boot environment variable contains a space-separated list of overlays that will be applied during boot. Depending on the boot source the overlays have to either be placed in the boot partition of eMMC/SD-Card or are loaded over tftp. Overlays set in the $KERNEL_DEVICETREE Yocto machine variable will be automatically added to the boot partition of the final WIC image."
msgstr "``${overlays}`` U-Boot 环境变量包含一个以空格分隔的overlay文件列表，这些overlay文件将在启动过程中应用。根据启动源，overlay文件必须放置在 eMMC/SD 卡的启动分区中，或者通过 tftp 加载。在 $KERNEL_DEVICETREE 这个 Yocto machine 变量中设置的 overlay 文件将自动添加到最终 WIC 镜像的启动分区中。"

#, python-brace-format
msgid "The ``${overlays}`` variable can be either set directly in the U-Boot environment or can be part of the external ``bootenv.txt`` environment file. By default, the ``${overlays}`` variable comes from the external ``bootenv.txt`` environment file which is located in the boot partition. You can read and write the file on booted target from linux:"
msgstr "``${overlays}`` 变量可以直接在U-Boot环境中设置，也可以作为外部 ``bootenv.txt`` 环境文件的一部分。默认情况下， ``${overlays}`` 变量来自位于启动分区的 ``bootenv.txt`` 文件。您可以在已启动的开发板上从Linux读取和写入该文件："

#, python-brace-format
msgid "We use the ``${overlays}`` variable for overlays describing expansion boards and cameras that can not be detected during run time. To prevent applying overlays listed in the ``${overlays}`` variable during boot, the ``${no_overlays}`` variable can be set to `1` in the bootloader environment."
msgstr "我们使用 ``${overlays}`` 变量来描述在运行时无法自动检测的扩展板和摄像头。如果想禁用 ``${overlays}`` 变量中列出的overlay，可以在U-Boot的环境中将 ``${no_overlays}`` 变量设置为 `1`。"

msgid "Extension Command"
msgstr "扩展命令"

msgid "The U-Boot extension command makes it possible to easily apply overlays that have been detected and added to a list by the board code callback `extension_board_scan() <overlaycallback_>`_. Overlays applied this way disable components that are not populated on the SoM. The detection is done with the EEPROM data (EEPROM SoM Detection) found on the SoM i2c EEPROM."
msgstr "使用U-Boot扩展命令能够轻松加载由回调函数  `extension_board_scan() <overlaycallback_>`_ 检测并添加到列表中的overlay。以这种方式应用的overlay会禁用核心板上未贴装的组件。检测是通过读取出厂EEPROM数据（EEPROM SoM Detection）来实现的。"

#, python-brace-format
msgid "To prevent running the extension command during boot the ``${no_extensions}`` variable can be set to `1` in the bootloader environment::"
msgstr "为了禁止在启动时自动运行扩展命令，可以在bootloader环境中将 ``${no_extensions}`` 变量设置为 `1` ："

msgid "The following is an example of the pin muxing of the UART1 device in imx8mm-phyboard-polis.dtsi:"
msgstr "以下是imx8mm-phyboard-polis.dtsi中UART1设备的引脚复用示例："

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n188`"
msgstr "RS232和RS485的设备树表示：:imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n188`"

msgid "To finish the configuration you can configure DHCP to receive an IP address (supported by most WLAN access points). For other possible IP configurations, see section `Changing the Network Configuration` in the |yocto-ref-manual|_."
msgstr "要完成配置，您可以配置DHCP以接收IP地址（大多数WLAN接入点都支持）。有关其他可能的IP配置，请参阅 |yocto-ref-manual|_ 中的“更改网络配置”部分。"

msgid "First, create the directory:"
msgstr "首先，创建目录："

msgid "Then add the following configuration snippet in ``/etc/systemd/network/10-wlan0.network``:"
msgstr "然后在 ``/etc/systemd/network/10-wlan0.network`` 中添加以下配置片段："

msgid "Now, restart the network daemon so that the configuration takes effect:"
msgstr "现在，请重启网络守护进程以使配置生效："

msgid "Bluetooth is connected to |bluetooth-uart| interface. More information about the module can be found at https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf. The Bluetooth device needs to be set up manually:"
msgstr "蓝牙连接到 |bluetooth-uart| 接口。有关该模块的更多信息，请访问 https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf。蓝牙设备需要手动设置："

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n266`"
msgstr "MMC（SD卡插槽）接口的DT配置可以在这里找到： :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n266`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n315`"
msgstr "eMMC接口的DT配置可以在这里找到：:imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n315`"

msgid "eMMC Devices"
msgstr "eMMC设备"

#, fuzzy
msgid "PHYTEC modules like |som| is populated with an eMMC memory chip as the main storage. eMMC devices contain raw MLC memory cells combined with a memory controller that handles ECC and wear leveling. They are connected via an SD/MMC interface to the |soc| and are represented as block devices in the Linux kernel like SD cards, flash drives, or hard disks."
msgstr "PHYTEC模块，如phyCORE-|soc|，配备了一个eMMC存储芯片作为主要存储。eMMC设备包含MLC存储单元，并集成了处理ECC和磨损均衡的存储控制器。它们通过SD/MMC接口连接到 |soc|，并在Linux内核中被表示为块设备，类似于SD卡、优盘或硬盘。"

msgid "The electric and protocol specifications are provided by JEDEC (https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc). The eMMC manufacturer's datasheet is relatively short and meant to be read together with the supported version of the JEDEC eMMC standard."
msgstr "电气和协议规范由JEDEC提供（https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc）。eMMC制造商的数据手册相对较简单，旨在与支持的JEDEC eMMC标准版本一起阅读。"

msgid "PHYTEC currently utilizes the eMMC chips with JEDEC Version 5.0 and 5.1"
msgstr "PHYTEC目前使用JEDEC版本5.0和5.1的eMMC芯片。"

msgid "eMMC devices have an extensive amount of extra information and settings that are available via the Extended CSD registers. For a detailed list of the registers, see manufacturer datasheets and the JEDEC standard."
msgstr "通过扩展CSD寄存器可以读取eMMC设备其他的信息和配置。有关寄存器的详细列表，请参阅制造商的数据手册和JEDEC标准。"

msgid "In contrast to raw NAND Flash, an eMMC device contains a Flash Transfer Layer (FTL) that handles the wear leveling, block management, and ECC of the raw MLC cells. This requires some maintenance tasks (for example erasing unused blocks) that are performed regularly. These tasks are called **Background Operations (BKOPS)**."
msgstr "与原始NAND Flash相比，eMMC设备包含一个闪存传输层（FTL），负责处理原始MLC单元的磨损平衡、块管理和错误纠正码（ECC）。这需要定期进行一些维护任务（例如擦除未使用的块）。这些任务被称为 **后台操作（BKOPS）** 。"

msgid "The JEDEC Standard has specified a method since version v4.41 that the host can issue BKOPS manually. See the JEDEC Standard chapter Background Operations and the description of registers BKOPS_EN (Reg: 163) and BKOPS_START (Reg: 164) in the eMMC datasheet for more details."
msgstr "JEDEC标准自版本v4.41起规定了一种方法，主机可以手动触发BKOPS。有关更多详细信息，请参阅JEDEC标准章节“Background Operations”以及eMMC数据手册中寄存器BKOPS_EN（寄存器：163）和BKOPS_START（寄存器：164）的描述。"

msgid "The mechanism to issue background operations has been implemented in the Linux kernel since v3.7. You only have to enable BKOPS_EN on the eMMC device (see below for details)."
msgstr "自v3.7版本以来，Linux内核已经实现了触发后台操作的机制。您只需在eMMC设备上启用BKOPS_EN（详细信息见下文）。"

msgid "The userspace tool mmc does not currently support enabling automatic BKOPS features."
msgstr "mmc这个linux工具目前不支持启用自动BKOPS功能。"

msgid "Do not confuse eMMC partitions with partitions of a DOS, MBR, or GPT partition table (see the previous section)."
msgstr "不要将 eMMC 分区与 DOS、MBR 或 GPT 分区表的分区混淆（请参阅前一节）。"

#, fuzzy
msgid "The first Reliable Write option is mostly already enabled on the eMMCs mounted on the |som| SoMs. To check this on the running target:"
msgstr "第一个可靠写入方式大多数情况下已经在phyCORE-|soc| SoM上挂载的eMMC上被启用。想要在运行的开发板上检查这一点："

msgid "When flashing the sdcard image to eMMC the ext4 root partition is not extended to the end of the eMMC. parted can be used to expand the root partition. The example works for any block device such as eMMC, SD card, or hard disk."
msgstr "在将SD卡镜像写入eMMC时，ext4文件系统分区没有扩展到eMMC的末尾。可以使用parted来扩展根分区。这个示例适用于任何块设备，例如eMMC、SD卡或硬盘。"

msgid "eMMC devices use MLC memory cells (https://en.wikipedia.org/wiki/Multi-level_cell) to store the data. Compared with SLC memory cells used in NAND Flash, MLC memory cells have lower reliability and a higher error rate at lower costs."
msgstr "eMMC设备使用 `多层单元内存（MLC） <https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E5%8D%95%E5%85%83>`_ 来存储数据。与NAND Flash中使用的单层单元（SLC）内存单元相比，MLC内存单元具有更低的可靠性和更高的错误率，但成本更低。"

msgid "First obtain the current size of the eMMC device with:"
msgstr "首先使用以下命令获取eMMC设备的当前大小："

msgid "It is possible to erase the eMMC device directly rather than overwriting it with zeros. The eMMC block management algorithm will erase the underlying MLC memory cells or mark these blocks as discard. The data on the device is lost and will be read back as zeros."
msgstr "可以直接擦除eMMC设备，而不是用零覆盖它。eMMC块管理算法将会擦除MLC存储单元或将这些块标记为丢弃。设备上的数据将丢失，并且读取为零。"

msgid "The partitions boot1 and boot2 are read-only by default. To write to them from user space, you have to disable force_ro in the sysfs."
msgstr "默认情况下，boot1和boot2分区是只读的。要从用户空间写入它们，您必须在sysfs中禁用force_ro。"

msgid "After that set the boot partition from user space using the mmc tool:"
msgstr "之后使用mmc工具从用户空间设置引导分区："

msgid "To choose back to the user area u-boot environment:"
msgstr "返回到User分区启动："

msgid "fdisk can be used to expand the root filesystem. The example works for any block device such as eMMC, SD Card, or hard disk."
msgstr "fdisk可以用来扩展根文件系统。这个例子适用于任何块设备，比如eMMC、SD卡或硬盘。"

msgid "The output looks like:"
msgstr "输出如下："

msgid "Use fdisk to delete and create a partition with a max size of the device:"
msgstr "使用fdisk删除并创建一个最大化使用设备容量的分区："

msgid "Increasing the file system size can be done while it is mounted. An online resizing operation is performed. But you can also boot the board from an SD card and then resize the file system on the eMMC partition while it is not mounted. Furthermore, the board has to be rebooted so that the new partition table will be read."
msgstr "可以在文件系统挂载时修改文件系统的大小。这是一个在线调整大小的操作。但您也可以从SD卡启动，然后在eMMC分区未挂载时调整其文件系统的大小。此外，必须重启板子，以便读取新的分区表。"

msgid ":imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n71`"
msgstr ":imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n71`"

msgid "You can also add this option for example to the defconfig you use in ``arch/arm64/configs/`` in the linux kernel sources. For our NXP based releases, this could be for example ``imx8_phytec_distro.config``::"
msgstr "您也可以将此选项添加到您在 Linux 内核源代码 ``arch/arm64/configs/`` 目录下使用的 defconfig 中。例如，我们基于 NXP 的BSP版本，这个defconfig可以是  ``imx8_phytec_distro.config`` ::"

msgid "Otherwise you can create a new config fragment. This is described in our `Yocto Reference Manual <yocto-ref-manual-kernel-and-bootloader-config_>`_."
msgstr "您也可以创建一个新的config片段。有关详细信息，请参阅我们的《Yocto参考手册<yocto-ref-manual-kernel-and-bootloader-config_>》。"

msgid "Pinmuxing of some GPIO pins in the device tree |dt-carrierboard|.dtsi::"
msgstr "设备树中的某些GPIO引脚的引脚复用 |dt-carrierboard|.dtsi::"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n37`"
msgstr "GPIO的设备树配置可以在这里找到：:imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n37`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy#n102`"
msgstr "I²C1 总线配置（例如 |dt-som|.dtsi）：:imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy#n102`"

msgid "General I²C4 bus configuration (e.g. |dt-carrierboard|.dtsi): :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n149`"
msgstr "I²C4总线配置（例如 |dt-carrierboard|.dtsi）：:imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n149`"

msgid "On the |som| there is an i2c EEPROM flash populated. It has two addresses. The main EEPROM space (bus: I2C-0 address: 0x51) and the ID-page (bus: I2C-0 address: 0x59) can be accessed via the sysfs interface in Linux. The first 256 bytes of the main EEPROM and the ID-page are used for board detection and must not be overwritten. Overwriting reserved spaces will result in boot issues."
msgstr "在 |som| 上有一个i2c EEPROM闪存。它有两个地址。主EEPROM空间（总线：I2C-0 地址：0x51）和ID页（总线：I2C-0 地址：0x59）可以通过Linux中的sysfs接口进行访问。主EEPROM和ID页的前256个字节用于板检测，不可被覆盖。覆盖保留的空间将导致启动问题。"

msgid "Rescue EEPROM Data"
msgstr "恢复EEPROM数据"

msgid "The hardware introspection data is pre-written on both EEPROM data spaces. If you have accidentally deleted or overwritten the normal area, you can copy the hardware introspection from the ID area to the normal area."
msgstr "硬件数据已预先写入两个EEPROM数据空间。如果您不小心删除或覆盖了Normal区域，可以将ID区域的硬件检查数据复制到正常区域。"

msgid "If you deleted both EEPROM spaces, please contact our support!"
msgstr "如果您删除了两个EEPROM空间，请联系我们的支持团队！"

#, fuzzy
msgid "DT representation, e.g. in |som| file |dt-som|.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n271`"
msgstr "phyCORE-|soc| 文件 |dt-som|.dtsi 可以在我们的PHYTEC git中找到：:imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n271`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n277`"
msgstr "I²C RTC的DT：：imx-dt:`imx8mm-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n277`"

msgid "User USB2 (host) configuration is in the kernel device tree |kernel-socname|.dtsi::"
msgstr "USB2（host）配置在内核设备树 |kernel-socname|.dtsi::"

msgid "DT representation for USB Host: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy9#n240`"
msgstr "USB Host的DT：:imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy9#n240`"

msgid "Both USB interfaces are configured as host in the kernel device tree imx8mm-phyboard-polis.dtsi. See: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n228`"
msgstr "两个USB接口在内核设备树imx8mm-phyboard-polis.dtsi中配置为Host。请参见：:imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n228`"

msgid "Device Tree CAN configuration of imx8mm-phyboard-polis.dtsi: :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n106`"
msgstr "imx8mm-phyboard-polis.dtsi的设备树CAN配置： :imx-dt:`imx8mm-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n106`"

msgid "In order to activate the driver, follow the instructions from our `Yocto Reference Manual <yocto-ref-manual-kernel-and-bootloader-config_>`_."
msgstr "使能驱动的方法。请参阅我们的 `Yocto Reference Manual <yocto-ref-manual-kernel-and-bootloader-config_>`_。"

msgid "You should see a lot of options as the audio-IC has many features you can experiment with. It might be better to open alsamixer via ssh instead of the serial console, as the console graphical effects are better. You have either mono or stereo gain controls for all mix points. \"MM\" means the feature is muted (both output, left & right), which can be toggled by hitting **m**. You can also toggle by hitting '**<**' for left and '**>**' for right output. With the **tab** key, you can switch between controls for playback and recording."
msgstr "您应该会看到很多选项，因为音频IC具有许多可以配置的功能选项。通过SSH打开alsamixer可能比通过串口控制台更好，因为控制台的图形效果更佳。您可以为所有混合点使用单声道或立体声增益控制。“MM”表示该功能被静音（左右输出均为静音），可以通过按 **m** 键切换。您还可以通过按'**<**'键切换左声道和'**>**'键切换右声道。使用 **tab** 键，您可以在播放和录音的控制之间切换。"

msgid "To set PEB-AV-10 as output, set playback.pcm from \"dummy\" to \"pebav10\":"
msgstr "要将PEB-AV-10设置为输出，请将playback.pcm从“dummy”设置为“pebav10”："

msgid "For applications using Pulseaudio, check for available sinks:"
msgstr "对于使用Pulseaudio的应用程序，请检查可用的输出设备："

msgid "To select PEB-AV-10, type:"
msgstr "要选择PEB-AV-10，请输入："

msgid "Device Tree Audio configuration: :imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n56`"
msgstr "设备树音频配置：:imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n56`"

msgid "The video is installed by default in the BSP:"
msgstr "这个视频在BSP中默认安装："

msgid "kmssink Plugin ID Evaluation"
msgstr "kmssink 插件 ID 确认"

msgid "The kmssink plugin needs a connector ID. To get the connector ID, you can use the tool modetest."
msgstr "kmssink插件需要一个连接器ID。要获取连接器ID，您可以使用工具modetest。"

msgid "The output will show something like:"
msgstr "输出如："

msgid "With the phytec-qt5demo-image, Weston starts during boot. The phytec-qt5demo can be stopped with:"
msgstr "使用phytec-qt5demo-image时，Weston会在启动时启动。可以通过以下命令停止phytec-qt5demo："

msgid "To disable autostart of the demo run:"
msgstr "要禁用Demo的自动启动，请运行："

msgid "The device tree of PEB-AV-10 can be found here: :imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17`"
msgstr "PEB-AV-10的设备树可以在这里找到：:imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17`"

msgid "Kirkstone"
msgstr "Kirkstone"

msgid "2024/01/10"
msgstr "2024/01/10"

msgid "BSP Release Date"
msgstr "BSP发布日期"

msgid "Major"
msgstr "大版本"

msgid "2023/12/12"
msgstr "2023/12/12"

msgid "*partup* has the advantage of allowing to clear specific raw areas in the MMC user area, which is used in our provided partup packages to erase any existing U-Boot environments. This is a known issue *bmaptool* does not solve, as mentioned below."
msgstr "*partup* 的优点在于能够清除 MMC 用户区中的特定区域，这在我们的应用场景中用于擦除 U-Boot 环境。这是一个 *bmaptool* 无法解决的已知问题，如下所述。"

msgid "An alternative and also fast way to prepare an SD card is using `bmap-tools <https://github.com/yoctoproject/bmaptool>`_. Yocto automatically creates a block map file (``<IMAGENAME>-<MACHINE>.wic.bmap``) for the WIC image that describes the image content and includes checksums for data integrity. *bmaptool* is packaged by various Linux distributions. For Debian-based systems install it by issuing:"
msgstr "准备SD卡的另一种方法是使用 `bmap-tools <https://github.com/yoctoproject/bmaptool>`_。Yocto会自动为WIC镜像创建一个映射文件（``<IMAGENAME>-<MACHINE>.wic.bmap``），该文件描述了镜像内容并包含数据完整性的校验。 *bmaptool* 已被多种Linux发行版支持。对于基于Debian的系统，可以通过以下命令安装："

msgid "**phytec-qt6demo-image\\*.wic**: SD card image"
msgstr "**phytec-qt6demo-image\\*.wic**: SD卡镜像"

msgid "Take a compressed or uncompressed image with accompanying block map on the host and send it with ssh through the network to the eMMC of the target with a one-line command:"
msgstr "使用一条命令，通过网络ssh协议将带有块映射的压缩或未压缩的镜像发送到开发板的eMMC上使用，执行："

msgid "These steps will show how to update the eMMC via a USB device. Configure the |ref-bootswitch| to SD Card and insert an SD card. Power on the board and stop in U-Boot prompt. Insert a USB device with the copied WIC image to the USB slot."
msgstr "下面这些步骤展示如何通过USB设备更新eMMC。将|ref-bootswitch| 配置为SD卡启动，并插入SD卡。给开发板上电并进入U-Boot环境。将已存储了未压缩WIC镜像的优盘插入开发板USB接口。"

msgid "These steps will show how to flash the eMMC on Linux with a USB stick. You only need a complete image saved on the USB stick and a bootable WIC image. (e.g. |yocto-imagename|-|yocto-machinename|.wic). Set the |ref-bootswitch| to SD Card."
msgstr "下面这些步骤展示如何在Linux系统上使用USB大容量存储设备烧写eMMC。您需要一个保存了完整镜像的U盘和一个可从SD卡启动的核心板（例如 |yocto-imagename|-|yocto-machinename|.wic）。将 |ref-bootswitch| 设置为SD卡启动。"

msgid "Flash an SD card with a working image and create a third ext4 partition. Copy the WIC image (for example |yocto-imagename|.wic) to this partition."
msgstr "将一个可用的镜像烧写到SD卡，并创建一个EXT4格式的第三分区。将WIC镜像（例如 |yocto-imagename|.wic）复制到该分区。"

msgid "The regulator for the SD card reset pin has been disabled to ensure compatibility with 1532.1 revision baseboards. If you have a revision 1532.2(a) or higher baseboard, you may enable the device tree nodes for highest performance. In the imx8mm-phyboard-polis-rdk-u-boot.dtsi file, remove the following lines::"
msgstr "SD卡复位引脚的regulator已被禁用，以确保与1532.1版本底板的兼容性。如果您拥有1532.2(a)或更高版本的主板，您可以启用设备树节点以获得最佳性能。在imx8mm-phyboard-polis-rdk-u-boot.dtsi文件中，删除以下行："

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n291`"
msgstr "RS232和RS485的设备树表示：:imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n291`"

msgid "To finish the configuration you can configure DHCP to receive an IP address (supported by most WLAN access points). For other possible IP configurations, see section `Changing the Network Configuration` in the |yocto-ref-manual|."
msgstr "要完成配置，您可以配置DHCP以接收IP地址（大多数WLAN接入点都支持）。有关其他可能的IP配置，请参阅 |yocto-ref-manual| 中的“更改网络配置”部分。"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n383`"
msgstr "MMC（SD卡插槽）接口的DT配置可以在这里找到：:imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n383`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n335`"
msgstr "eMMC接口的DT配置可以在这里找到：:imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n335`"

msgid ":imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n87`"
msgstr ":imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n87`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n36`"
msgstr "用户输入/输出配置的设备树配置可以在这里找到：:imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n36`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n119`"
msgstr "通用 I²C1 总线配置（例如 |dt-som|.dtsi）： :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n119`"

msgid "General I²C4 bus configuration (e.g. |dt-carrierboard|.dts): :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n244`"
msgstr "通用 I²C4 总线配置（例如 |dt-carrierboard|.dts）： :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n244`"

#, fuzzy
msgid "DT representation, e.g. in |som| file |dt-som|.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n311`"
msgstr "DT 表示法，例如在 phyCORE-|soc| 文件 |dt-som|.dtsi 中，可以在我们的 PHYTEC git 中找到： :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n311`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n319`"
msgstr "I²C RTCs的DT表示: :imx-dt:`imx8mm-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n319`"

msgid "DT representation for USB Host: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n347`"
msgstr "USB主机的DT表示：:imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n347`"

msgid "Both USB interfaces are configured as host in the kernel device tree |dt-carrierboard|.dts. See: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n335`"
msgstr "两个USB接口在内核设备树 |dt-carrierboard|.dts 中被配置为主机。请参见： :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n335`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n175`"
msgstr "|dt-carrierboard| 的设备树CAN配置.dts: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n175`"

msgid "Device Tree Audio configuration: :imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtsi?h=v5.15.71_2.2.2-phy3#n54`"
msgstr "设备树音频配置：:imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtsi?h=v5.15.71_2.2.2-phy3#n54`"

msgid "The device tree of PEB-AV-10 can be found here: :imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtsi?h=v5.15.71_2.2.2-phy3`"
msgstr "PEB-AV-10的设备树可以在这里找到: :imx-dt:`overlays/imx8mm-phyboard-polis-peb-av-010.dtsi?h=v5.15.71_2.2.2-phy3`"

msgid "|doc-id| |soc| BSP Manual"
msgstr "|doc-id| |soc| BSP手册"

msgid "Scarthgap"
msgstr "Scarthgap"

#, fuzzy
msgid "2025/03/28"
msgstr "2024/06/26"

msgid "The |sbc| populated with the |soc| SoC is supported."
msgstr "支持的 |soc| 系统芯片 (SoC) 的 |sbc|。"

msgid "SD Card Boot"
msgstr "SD卡启动"

msgid "**bl31-imx8mn.bin**: ARM Trusted Firmware binary"
msgstr "**bl31-imx8mn.bin**: ARM可信固件二进制文件"

msgid "**imx8mn-phyboard-polis*.dtb**: Kernel device tree file"
msgstr "**imx8mn-phyboard-polis*.dtb**: 内核设备树文件"

msgid "**imx8mn-phy*.dtbo**: Kernel device tree overlay files"
msgstr "**imx8mn-phy*.dtbo**：内核设备树overlay文件"

msgid "**phytec-headless-image\\*.tar.gz**: Root file system"
msgstr "**phytec-headless-image\\*.tar.gz**: 根文件系统"

msgid "**phytec-headless-image\\*.rootfs.wic.xz**: compressed SD card image"
msgstr "**phytec-headless-image\\*.rootfs.wic.xz**: 压缩的SD卡镜像"

msgid "Hardware revision baseboard: 1532.2 and newer"
msgstr "硬件修订主板：1532.2及更新版本"

msgid "USB Serial Downloader"
msgstr "USB串行下载器"

msgid "Internal Fuses"
msgstr "内部fuse"

msgid "\\"
msgstr "\\"

msgid "Switch between USB HOST/OTG using Pos5 of switch(S1)"
msgstr "通过开关(S1)的第5位在USB HOST/OTG之间切换。"

msgid "USB HOST"
msgstr "USB 主机"

msgid "Switch between UART1 RS485/RS232 using Pos4 of switch(S1)"
msgstr "通过开关(S1)的第4位在UART1的RS485/RS232之间切换。"

msgid "The first part of the string MX8MN_IOMUXC_SAI2_RXFS_UART1_DCE_TX names the pad (in this example SAI2_RXFS). The second part of the string (UART1_DCE_RX) is the desired muxing option for this pad. The pad setting value (hex value on the right) defines different modes of the pad, for example, if internal pull resistors are activated or not. In this case, the internal resistors are disabled."
msgstr "字符串的第一部分 MX8MN_IOMUXC_SAI2_RXFS_UART1_DCE_TX 指定了引脚（在此示例中为 SAI2_RXFS）。字符串的第二部分 (UART1_DCE_RX) 是该引脚的复用选项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部上拉电阻是否被激活。在当前配置下，内部电阻被禁用。"

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n220`"
msgstr "RS232和RS485的设备树：:imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n220`"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n301`"
msgstr "MMC（SD卡插槽）接口的DT配置：:imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n301`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n309`"
msgstr "eMMC接口的DT配置可以在这里找到：:imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n309`"

msgid ":imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n78`"
msgstr ":imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n78`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n45`"
msgstr "GPIO配置的设备树配置可以在这里找到：:imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n45`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n106`"
msgstr "I²C1总线的DT配置（例如 |dt-som|.dtsi）： :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n106`"

msgid "General I²C3 bus configuration (e.g. |dt-carrierboard|.dts): :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n196`"
msgstr "I²C3总线DT配置（例如 |dt-carrierboard|.dts）：:imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n196`"

#, fuzzy
msgid "DT representation, e.g. in |som| file |dt-som|.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n259`"
msgstr "DT表示，例如在phyCORE-|soc| 文件 |dt-som|.dtsi中，可以在我们的PHYTEC git中找到：:imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n259`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n267`"
msgstr "I²C RTC的设备树表示：:imx-dt:`imx8mn-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n267`"

msgid "The USB controller of the |soc| SoC provides a low-cost connectivity solution for numerous consumer portable devices by providing a mechanism for data transfer between USB devices with a line/bus speed up to 480 Mbps (HighSpeed 'HS')."
msgstr "|soc| SoC 的 USB 控制器为众多消费类便携设备提供了一种低成本的连接解决方案，通过提供一种数据传输机制，使 USB 设备之间的线路/总线速度可达到 480 Mbps（高速 'HS'）。"

msgid "The |soc| SoC has a single USB controller core that is set to OTG mode. To use the micro USB / OTG port dip switch S1 Pos5 has to be set to on."
msgstr "该 |soc| SoC 具有一个设置为 OTG 模式的 USB 控制器IP。要使用Micro USB / OTG 端口，拨码开关 S1 的第 5 位必须设置为开启。"

msgid "The USB interface is configured as host in the kernel device tree |dt-carrierboard|.dts. See: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n264`"
msgstr "USB接口在内核设备树|dt-carrierboard|.dts中配置为Host。请参见：:imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n264`"

msgid "On phyBOARD-Polis-i.MX8MN a terminating resistor can be enabled by setting S5 to ON if required."
msgstr "在phyBOARD-Polis-i.MX8MN上，如果需要，可以通过将S5设置为ON来启用端接电阻。"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n125`"
msgstr "|dt-carrierboard|.dts的设备树CAN配置: :imx-dt:`imx8mn-phyboard-polis.dts?h=v5.15.71_2.2.2-phy3#n125`"

msgid "**imx8mn-phyboard-polis-dsi*.dtb**: Kernel device tree file"
msgstr "**imx8mn-phyboard-polis-dsi*.dtb**: 内核设备树文件"

msgid "**phytec-headless-image\\*.wic**: SD card image"
msgstr "**phytec-headless-image\\*.wic**: SD卡镜像"

msgid "The following is an example of the pin muxing of the UART1 device in imx8mn-phyboard-polis.dtsi:"
msgstr "以下是imx8mn-phyboard-polis.dtsi中UART1设备的引脚复用示例："

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n166`"
msgstr "RS232和RS485的设备树表示：:imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n166`"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n238`"
msgstr "MMC（SD卡插槽）接口的DT配置可以在这里找到：:imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n238`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n293`"
msgstr "eMMC接口的DT配置：:imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n293`"

msgid ":imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n75`"
msgstr ":imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n75`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n35`"
msgstr "GPIO设备树配置：:imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n35`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n98`"
msgstr "I²C1总线的DT配置（例如 |dt-som|.dtsi）： :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n98`"

msgid "General I²C3 bus configuration (e.g. |dt-carrierboard|.dtsi): :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n147`"
msgstr "I²C3总线的DT配置（例如 |dt-carrierboard|.dtsi）： :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n147`"

#, fuzzy
msgid "DT representation, e.g. in |som| file |dt-som|.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n248`"
msgstr "phyCORE-|soc| 的设备树配置 |dt-som|.dtsi可以在我们的PHYTEC git中找到： :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n248`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n254`"
msgstr "I²C RTCs的DT表示：:imx-dt:`imx8mn-phycore-som.dtsi?h=v5.10.72_2.2.0-phy9#n254`"

msgid "Both USB interfaces are configured as host in the kernel device tree |dt-carrierboard|.dtsi. See: :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n206`"
msgstr "两个USB接口在内核设备树 |dt-carrierboard|.dtsi 中配置为Host。请参见：:imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n206`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dtsi: :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n104`"
msgstr "|dt-carrierboard| 的设备树CAN配置： :imx-dt:`imx8mn-phyboard-polis.dtsi?h=v5.10.72_2.2.0-phy17#n104`"

msgid "|doc-id| |soc| FPSC BSP ManualHead"
msgstr "|doc-id| |soc| FPSC BSP ManualHead"

msgid "|doc-id| |soc| FPSC BSP Manual Head"
msgstr "|doc-id| |soc| FPSC BSP 手册模板"

msgid "On our web page, you can see all supported Machines with the available Article Numbers for this release: |yocto-manifestname| `download <dlpage-bsp_>`_."
msgstr "在我们的网页上，您可以查看适用于BSP版本 |yocto-manifestname| 的所有Machine及其对应的Article Numbers(产品型号)： `网页 <dlpage-bsp_>`_."

msgid "If you choose a specific **Machine Name** in the section **Supported Machines**, you can see which **Article Numbers** are available under this machine and also a short description of the hardware information. In case you only have the **Article Number** of your hardware, you can leave the **Machine Name** drop-down menu empty and only choose your **Article Number**. Now it should show you the necessary **Machine Name** for your specific hardware"
msgstr "如果您在“Supported Machines”一栏选择了特定的 **Machine Name** ，您可以查看该machine下可用的 **Article Numbers** 以及硬件信息的简短描述。如果您只有硬件的 **Article Numbers** ，您可以将 **Machine Name** 下拉菜单留空，仅选择您的 **Article Numbers** 。现在，它应该会显示您特定硬件所需的 **Machine Name** "

msgid "**Libra Components (top)**"
msgstr "Libra 器件（顶部）"

msgid "**Libra Components (bottom)**"
msgstr "Libra 器件（底部）"

msgid "To boot from an SD card, the |ref-bootswitch| needs to be set to the following position:"
msgstr "要从SD卡启动， |ref-bootswitch| 需要设置为以下位置："

msgid "**bl31-imx8mp.bin**: ARM Trusted Firmware binary"
msgstr "**bl31-imx8mp.bin**: ARM可信固件二进制文件"

msgid "**fitImage-its\\*.its**"
msgstr "**fitImage-its\\*.its**"

msgid "**imx8mp-libra-rdk-fpsc*.dtb**: Kernel device tree file"
msgstr "**imx8mp-libra-rdk-fpsc*.dtb**: 内核设备树文件"

msgid "**imx8mp-phy*.dtbo**: Kernel device tree overlay files"
msgstr "**imx8mp-phy*.dtbo**: 内核设备树overlay文件"

msgid "**phytec-qt6demo-image\\*.rootfs.wic.xz**: compressed SD card image"
msgstr "**phytec-qt6demo-image\\*.rootfs.wic.xz**: 压缩的SD卡镜像"

msgid "Bootmode Switch (S3)"
msgstr "启动模式开关 (S3)"

msgid "Hardware revision baseboard: 1552.2"
msgstr "硬件修订版底板：1552.2"

#, fuzzy
msgid "The |sbc| features a boot switch with four individually switchable ports to select the |som| default bootsource."
msgstr "该 |sbc| 具有一个（启动源配置）开关，配有四个可单独切换的位，用于选择phyCORE-|soc| 默认的启动源。"

msgid "eMMC"
msgstr "eMMC"

msgid "JTAG Mode"
msgstr "JTAG模式"

msgid "The first part of the string MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX names the pad (in this example UART1_RXD). The second part of the string (UART1_DCE_RX) is the desired muxing option for this pad. The pad setting value (hex value on the right) defines different modes of the pad, for example, if internal pull resistors are activated or not. In this case, the internal resistors are disabled."
msgstr "字符串的第一部分 MX8MP_IOMUXC_UART1_RXD_UART1_DCE_RX 指定了引脚（在这个例子中是 UART1_RXD）。字符串的第二部分（UART1_DCE_RX）是该引脚所选的复用项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部拉电阻是否被激活。在当前情况下，内部拉电阻被禁用。"

msgid "The device tree representation for UART1 pinmuxing: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L373`"
msgstr "UART1引脚复用的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L373`"

#, fuzzy
msgid "The |som| supports up to 4 UART units. On the |sbc|, TTL level signals of UART1 (the standard console) and UART4 are routed to Silicon Labs CP2105 UART to USB converter expansion. This USB is brought out at Micro-USB connector X1. UART3 is at X6 (Expansion Connector) at TTL level. UART2 is connected to a multi-protocol transceiver for RS-232 and RS-485, available at pin header connector |ref-serial| at the RS-232 level, or at the RS-485 level. The configuration of the multi-protocol transceiver is done by jumpers |ref-jp3| and |ref-jp4| on the baseboard. For more information about the correct setup please refer to the |som|/|sbc| Hardware Manual section UARTs."
msgstr "phyCORE-|soc| 支持最多 4 个 UART 单元。在 |sbc| 上，UART1（调试串口）和 UART4 的 TTL 电平信号被连接到 Silicon Labs CP2105 UART 到 USB 转换IC。这个 USB 信号通过 Micro-USB 连接器 X1 输出。UART3 位于 X6（扩展连接器），为 TTL 电平信号。UART2 连接到一个多协议收发器IC，可转换为 RS-232 或 RS-485，RS-232 和 RS-485 信号位于连接器 |ref-serial| 。多协议配置通过主板上的跳线 |ref-jp3| 和 |ref-jp4| 完成。更多信息，请参阅 phyCORE-|soc|/|sbc| 硬件手册中的 UARTs 部分。"

msgid "We use the same device tree node for RS-232 and RS-485. RS-485 mode can be enabled with ioctl TIOCSRS485. Also, full-duplex support is also configured using ioctls. Have a look at our small example application rs485test, which is also included in the BSP. The jumpers |ref-jp3| and |ref-jp4| need to be set correctly."
msgstr "对于RS-232和RS-485，使用相同的设备树节点。RS485模式可以通过ioctl TIOCSRS485 来启用。双向通讯支持也可以通过ioctl进行配置。请查看我们的小示例应用程序rs485test，该程序也包含在BSP中。需要设置跳线 |ref-jp3| 和 |ref-jp4| 。"

msgid "RS485 full-duplex"
msgstr "RS485 全双工"

msgid "For full-duplex mode your connection setup should look like this:"
msgstr "对于全双工模式，您应按下图连接："

msgid "For full-duplex mode you can set the ioctls manually like this:"
msgstr "对于全双工模式，您可以手动设置 ioctls，如下所示："

msgid "Also here you can do the echo test to see if sending and receiving works:"
msgstr "您还可以进行echo测试以查看发送和接收是否正常工作："

msgid "To check if the full-duplex operation works, you need to use the linux-serial-test tool:"
msgstr "要检查全双工操作是否正常工作，您需要使用 linux-serial-test 工具："

msgid "In this example both targets will send and receive simultaneously. They will receive for 15sec and send for 10sec. The receiver needs to receive a bit longer, so that all sent messages will get received. Remember to start both targets almost simultaneously. A small difference in start time is accounted for with the ``-W 2`` option. At the end the program will print the final \"count for this session\". There you can check that all transmitted frames were received."
msgstr "在此示例中，两个目标设备将同时发送和接收。它们将在15秒内接收并在10秒内发送。接收方需要接收更长时间，以便所有发送的消息都能接收到。请记住几乎同时启动两个目标设备。启动时间的微小差异可以通过-W 2选项来弥补。最后程序将打印“本会话的最终计数”。在那里您可以检查所有传输的帧是否都被接收。"

msgid "All the test examples are target to target, but can also be done with host to target with a USB to rs485 converter. You may need to adjust the interfaces for commands to work on the host then."
msgstr "所有的测试示例都是目标设备到目标设备的，但也可以通过USB到RS485转换器在主机与目标之间完成。可能需要调整接口以便命令在主机上正常工作。"

msgid "The device tree representation for RS232 and RS485: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L412`"
msgstr "RS232和RS485的设备树： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L412`"

msgid "|sbc|-|soc| provides two ethernet interfaces. A gigabit Ethernet is provided by our module and board."
msgstr "|sbc|-|soc| 提供两个以太网接口。我们的核心板和底板各提供一个千兆以太网接口。"

msgid "The naming convention of the Ethernet interfaces in the hardware (ethernet0 and ethernet1) do not align with the network interfaces (eth0 and eth1) in Linux. So, be aware of these differences:"
msgstr "硬件中的以太网接口命名约定（ethernet0 和 ethernet1）与Linux中的网络接口（eth0 和 eth1）不一致。因此，请注意这些差异："

msgid "ethernet1 = eth0"
msgstr "ethernet1 = eth0"

msgid "ethernet0 = eth1"
msgstr "ethernet0 = eth1"

msgid "WLAN and Bluetooth on the |sbc| are provided by the PEB-WLBT-05 expansion card. The PEB-WLBT-05 for |sbc| Quickstart Guide shows you how to install the PEB-WLBT-05."
msgstr "在 |sbc| 上，WLAN和蓝牙由PEB-WLBT-05扩展板提供。PEB-WLBT-05的 |sbc| 快速入门指南向您展示了如何安装PEB-WLBT-05。"

msgid "With the BSP Version PD22.1 and newer, the PEB-WLBT-05 overlay needs to be activated first, otherwise the PEB-WLBT-05 won't be recognized."
msgstr "对于BSP版本PD22.1及更新版本，需要先激活PEB-WLBT-05 Overlay，否则PEB-WLBT-05将无法被识别。"

msgid "Afterwards the bootenv.txt file should look like this (it can also contain other devicetree overlays!):"
msgstr "之后，bootenv.txt 文件应该如下所示（它还可以包含其他设备树overlay！）："

msgid "The changes will be applied after a reboot:"
msgstr "更改将在重启后应用："

msgid "For further information about devicetree overlays, read the |ref-dt| chapter."
msgstr "有关设备树overlay的更多信息，请阅读 |ref-dt| 章节。"

msgid "Bluetooth is supported on |sbc| with the PEB-WLBT-05 expansion card. How this can be activated is described in the WLAN section."
msgstr "开发板 |sbc| 可以通过PEB-WLBT-05扩展板支持蓝牙。如何在系统中使能它在WLAN部分中有描述。"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L422`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L422`"

#, fuzzy
msgid "DT configuration for the e.MMC interface can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"

msgid "Automatic failover"
msgstr ""

msgid "The ROM loader implements an automatic failover mechanism for e.MMC boot partitions. If booting from the primary partition fails, the system automatically attempts to boot from the secondary partition. This failover is indicated by a change in the boot message from ``Boot Stage: Primary boot`` to ``Boot Stage: Secondary boot``. This functionality is limited to boot0 and boot1 partitions and does not apply to the user area."
msgstr ""

msgid ":linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L76`"
msgstr ":linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L76`"

msgid "Device tree configuration for the User I/O configuration can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L255`"
msgstr "GPIO的设备树配置：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L255`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L113`"
msgstr "I²C1 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L113`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L239`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L239`"

#, fuzzy
msgid "DT representation, e.g. in |som| file imx8mp-phycore-som.dtsi can be found in our PHYTEC git: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L201`"
msgstr "核心板 phyCORE-|soc| 的设备树imx8mp-phycore-som.dtsi可以在PHYTEC git中找到： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L201`"

msgid "DT representation for I²C RTCs: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L208`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L208`"

msgid "The USB controller of the |soc| SoC provides a low-cost connectivity solution for numerous consumer portable devices by providing a mechanism for data transfer between USB devices with a line/bus speed of up to 4 Gbit/s (SuperSpeed 'SS'). The USB subsystem has two independent USB controller cores. Both cores are capable of acting as a USB peripheral device or a USB host. Each is connected to a USB 3.0 PHY."
msgstr "|soc| SoC的USB控制器为众多消费类便携设备提供了一种低成本的连接解决方案，实现USB设备之间的数据传输，传输速度可达4 Gbit/s（超高速'SS'）。USB子系统具有两个独立的USB控制器。这两个控制器都能够作为USBDevice或USB Host使用。每个核心都连接到一个USB 3.0物理层（PHY）。"

msgid "DT representation for USB Host: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L380`"
msgstr "USB Host的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L380`"

msgid "The |sbc| has two flexCAN interfaces supporting CAN FD. They are supported by the Linux standard CAN framework which builds upon then the Linux network layer. Using this framework, the CAN interfaces behave like an ordinary Linux network device, with some additional features special to CAN. More information can be found in the Linux Kernel documentation: https://www.kernel.org/doc/html/latest/networking/can.html"
msgstr "|sbc| 支持两个 flexCAN 接口，支持 CAN FD。这些接口支持 Linux 标准 CAN 框架，该框架建立在 Linux 网络层之上。使用这个框架，CAN 接口表现得像普通的 Linux 网络设备，同时具备一些 CAN 特有的附加功能。更多信息可以在 Linux 内核文档中找到：https://www.kernel.org/doc/html/latest/networking/can.html"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L203`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L203`"

msgid "Device Tree PCIe configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L345`"
msgstr "|dt-carrierboard|.dts 的设备树 PCIE 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L345`"

msgid "Playback devices supported for |sbc| are HDMI and the TI TLV320AIC3007 audio codec on the PEB-AV-10 connector. On the AV-Connector there is a 3.5mm headset jack with OMTP-standard and an 8-pin header. The 8-pin header contains a mono speaker, headphones, and line in signals."
msgstr "支持的播放设备包括HDMI和PEB-AV-10连接器上的TI TLV320AIC3007音频编解码器（CODEC）IC。在AV连接器上，有一个符合OMTP标准的3.5mm耳机插孔和一个8针排针。8针排针包含单声道扬声器、耳机和line-in信号。"

msgid "Using the PEB-AV-10 connector for display output along HDMI as audio output is not supported. The audio output device must match the video output device."
msgstr "使用PEB-AV-10连接器进行显示输出时，不支持通过HDMI作为音频输出。音频输出设备必须与视频输出设备匹配。"

msgid "Device Tree Audio configuration: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-peb-av-10.dtso#L58`"
msgstr "|dt-carrierboard|.dts 的设备树 音频 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-peb-av-10.dtso#L58`"

msgid "The |sbc| supports up to 3 different display outputs. Two can be used simultaneously. The following table shows the required extensions and devicetree overlays for the different interfaces."
msgstr "该 |sbc| 支持多达3种不同的显示输出。可以同时使用两种。下表显示了不同接口所需的扩展板和设备树overlay。"

msgid "Interface"
msgstr "接口"

msgid "Expansion"
msgstr "扩展板"

msgid "devicetree overlay"
msgstr "设备树overlay"

msgid "HDMI"
msgstr "HDMI"

msgid "|sbc|"
msgstr "|sbc|"

msgid "no overlay needed (enabled by default)"
msgstr "不需要overlay（默认启用）"

msgid "LVDS0"
msgstr "LVDS0"

msgid "PEB-AV-10"
msgstr "PEB-AV-10"

msgid "|dtbo-peb-av-10| (loaded by default)"
msgstr "|dtbo-peb-av-10| （默认加载）"

msgid "LVDS1"
msgstr "LVDS1"

msgid "disabled if PEB-AV-10 overlay is used"
msgstr "如果使用PEB-AV-10 overlay，则禁用"

msgid "When changing Weston output, make sure to match the audio output as well."
msgstr "在更改Weston输出时，请确保音频输出也相匹配。"

msgid "LVDS0 (PEB-AV-10) and LVDS1 (onboard)can not be used at the same time."
msgstr "LVDS0 (使用PEB-AV-10扩展) 和 LVDS1 (板载) 不能同时使用。"

msgid "HDMI is always enabled in the devicetree. The other interfaces can be enabled with Device Tree Overlay."
msgstr "HDMI在设备树中始终启用。其他接口可以通过设备树overlay进行启用。"

msgid "The default-enabled Interfaces are HDMI and LVDS0 (PEB-AV-010). We support a 10'' edt,etml1010g0dka display for the |lvds-display-adapters|."
msgstr "默认启用的接口是HDMI和LVDS0（PEB-AV-010）。我们的 |lvds-display-adapters| 支持10英寸edt,etml1010g0dka显示屏。"

msgid "The current display driver limits the pixel clock for a display connected to LVDS to 74.25Mhz (or a divider of it).  If this does not fit your display requirements, please contact Support for further help."
msgstr "当前的显示驱动程序将连接到LVDS的LCD的像素时钟限制为74.25MHz（或其分频）。如果这满足不了您的需求，请联系支持团队以获得进一步的帮助。"

msgid "Weston Configuration"
msgstr "Weston 配置"

msgid "In order to get an output from Weston on the correct display, it still needs to be configured correctly. This will be done at /etc/xdg/weston/weston.ini."
msgstr "为了让Weston正确的显示，需要进行正确的配置。这将在/etc/xdg/weston/weston.ini中完成。"

msgid "Single Display"
msgstr "单一显示器"

msgid "In our BSP, the default Weston output is set to HDMI."
msgstr "在我们的BSP中，默认的Weston输出设置为HDMI。"

msgid "When using the LVDS0 (PEB-AV-10) as output, set the output mode to off for HDMI-A-1 and for LVDS-1 to current."
msgstr "当使用LVDS0（PEB-AV-10）作为输出时，将HDMI-A-1的输出模式设置为off，将LVDS-1的输出模式设置为current。"

msgid "If you want to use LVDS1 (onboard) then you need to load no overlay. Remove the imx8mp-phyboard-pollux-peb-av-xxx.dtbo from bootenv.txt."
msgstr "如果您想使用LVDS1（板载），则需要去掉overlay。请从bootenv.txt中移除imx8mp-phyboard-pollux-peb-av-xxx.dtbo。"

msgid "Dual Display"
msgstr "双显示器"

msgid "For dual and triple display output you can not use LVDS1 (onboard) and HDMI together."
msgstr "对于双显示和三显示输出，您无法同时使用LVDS1（板载）和HDMI。"

msgid "For dual display in dual view mode at HDMI and LVDS0 (PEB-AV-10), both modes have to be set to the:"
msgstr "在HDMI和LVDS0（PEB-AV-10）的双屏模式下进行双显示时，两个模式必须设置为："

msgid "Device tree description of LVDS-1 and HDMI can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L294` :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L218`"
msgstr "LVDS-1和HDMI的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L294` :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L218`"

msgid "The device tree of LVDS-0 on PEB-AV-10 can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-peb-av-10.dtso#L133`"
msgstr "PEB-AV-10扩展板的LVDS-0的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-peb-av-10.dtso#L133`"

msgid "The device tree description of GPIO Fan can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L35`"
msgstr "GPIO风扇的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L35`"

msgid "snvs Power Key"
msgstr "snvs电源按键"

msgid "The X_ONOFF pin connected to the ON/OFF button can be pressed long to trigger Power OFF without SW intervention or used to wake up the system out of suspend. With the *snvs_pwrkey* driver, the KEY_POWER event is also reported to userspace when the button is pressed. On default, systemd is configured to ignore such events. The function of Power OFF without SW intervention and the wake-up from suspend are not configured. Triggering a power off with systemd when pushing the ON/OFF button can be configured under ``/etc/systemd/logind.conf`` and set using:"
msgstr "连接到开关按钮的 X_ONOFF 引脚可以长按以触发关机，而无需软件干预，或用于唤醒系统以退出挂起状态。使用 *snvs_pwrkey* 驱动程序时，当按下按钮时，KEY_POWER 事件也会报告给用户空间。默认情况下，systemd 被配置为忽略此类事件。关机而无需软件干预的功能以及从挂起状态唤醒的功能未被配置。可以在 ``/etc/systemd/logind.conf`` 中配置按下开/关按钮时通过 systemd 触发关机，配置方法如下："

msgid "NPU"
msgstr "NPU"

#, fuzzy
msgid "The |soc| SoC contains a Neural Processing Unit up to 2.3 TOPS as an accelerator for artificial intelligence operations. Refer to our latest |som| AI Kit Guide on the |som| download section to get information about the NPU: `L-1015e.A1 phyCORE-i.MX 8M Plus AI Kit Guide <https://www.phytec.de/cdocuments/?doc=9oB5Hg>`_"
msgstr "|soc| SoC包含一个高达2.3 TOPS的人工智能运算加速器。有关NPU的信息，请参考我们最新的phyCORE-|soc| AI套件指南，该指南可以在phyCORE-|soc| 下载部分找到：`L-1015e.A1 phyCORE-i.MX 8M Plus AI Kit Guide <https://www.phytec.de/cdocuments/?doc=9oB5Hg>`_"

msgid "ISP"
msgstr "ISP"

msgid "The |soc| SoC contains an Image Signal Processor (ISP). For more information see Using the ISPs on the |sbc| |soc| documentation. This documentation is also available in German."
msgstr "|soc| SoC包含一个图像信号处理器（ISP）。有关更多信息，请参阅|sbc| |soc| 文档中的使用ISP部分。"

msgid "|doc-id| |soc| BSP ManualHead"
msgstr "|doc-id| |soc| BSP ManualHead"

msgid "**phyBOARD-Pollux Components (top)**"
msgstr "**phyBOARD-Pollux 器件图（顶部）**"

msgid "**phyBOARD-Pollux Components (bottom)**"
msgstr "**phyBOARD-Pollux 器件图（底部）**"

msgid "**imx8mp-phyboard-pollux-rdk*.dtb**: Kernel device tree file"
msgstr "**imx8mp-phyboard-pollux-rdk*.dtb**: 内核设备树文件"

msgid "Test Mode"
msgstr "测试模式"

msgid "Build U-Boot With a Fixed RAM Size and Frequency"
msgstr "编译支持固定RAM大小与频率的U-Boot"

#, fuzzy
msgid "Starting with PD23.1.0 NXP or PD24.1.2 mainline release, the |som| SoMs with revision 1549.3 and newer also support 2GHz RAM timings. These will be enabled for supported boards automatically, but they can also be enabled or disabled manually."
msgstr "从PD23.1.0 NXP或PD24.1.2 Mainline 版本开始，PCB为1549.3版本的核心板及更新版本的phyCORE-|soc| SoM支持2GHz内存时序。这些将在支持的板上自动启用，但也可以手动启用或禁用。"

msgid "Edit the file configs/|u-boot-defconfig|. The fixed RAM size with 2GHz timings will be used:"
msgstr "编辑文件 configs/|u-boot-defconfig|。将使用2GHz时序大小固定的RAM配置："

msgid "After saving the changes, follow the remaining steps from |ref-build-uboot|."
msgstr "在保存更改后，按照 |ref-build-uboot| 中剩下的步骤操作。"

msgid "Build U-Boot With a Fixed RAM Frequency"
msgstr "编译固定的RAM频率的U-Boot"

msgid "Starting with PD24.1.2 mainline release or PD24.1.0 NXP release, U-Boot can also be built with just fixed RAM Frequency while the RAM size will still be used from EEPROM."
msgstr "从PD24.1.2 Mainline版本或者 PD24.1.0 NXP 版本开始，U-Boot可以编译成只固定RAM频率，RAM大小还是保持从EEPROM读取。"

msgid "Edit the file configs/|u-boot-defconfig|. The RAM size from EEPROM with fixed frequency will be used:"
msgstr "编辑文件 configs/|u-boot-defconfig|。将使用EEPROM中配置的容量与固定的频率RAM配置："

msgid "DT configuration for the eMMC interface can be found here: :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"

msgid "Mainline HEAD"
msgstr "Mainline HEAD"

msgid "BSP-Yocto-NXP-i.MX8MP-PD24.1.0"
msgstr "BSP-Yocto-NXP-i.MX8MP-PD24.1.0"

msgid "BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.2"
msgstr "BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.2"

msgid "BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.1"
msgstr "BSP-Yocto-Ampliphy-i.MX8MP-PD24.1.1"

msgid "BSP-Yocto-NXP-i.MX8MP-PD23.1.0"
msgstr "BSP-Yocto-NXP-i.MX8MP-PD23.1.0"

msgid "BSP-Yocto-NXP-i.MX8MP-PD22.1.2"
msgstr "BSP-Yocto-NXP-i.MX8MP-PD22.1.2"

msgid "BSP-Yocto-NXP-i.MX8MP-PD22.1.1"
msgstr "BSP-Yocto-NXP-i.MX8MP-PD22.1.1"

msgid "|doc-id| |soc| BSP Mainline Manual Head"
msgstr "|doc-id| |soc| BSP Mainline Manual Head"

msgid "**lpddr4_pmu_train_1d_dmem_202006.bin, lpddr4_pmu_train_1d_imem_202006.bin, lpddr4_pmu_train_2d_dmem_202006.bin, lpddr4_pmu_train_2d_imem_202006.bin**: DDR PHY firmware images"
msgstr "**lpddr4_pmu_train_1d_dmem_202006.bin, lpddr4_pmu_train_1d_imem_202006.bin, lpddr4_pmu_train_2d_dmem_202006.bin, lpddr4_pmu_train_2d_imem_202006.bin**：DDR PHY固件镜像"

msgid "**phytec-qt6demo-image\\*.wic.xz**: SD card image"
msgstr "**phytec-qt6demo-image\\*.wic.xz**: SD卡镜像"

msgid "This step only works if the size of the image file is less than 1,28GB due to limited RAM space available in the Bootloader."
msgstr "此步骤仅在镜像文件大小小于1.28GB时有效，因为Bootloader可用的RAM空间有限。"

msgid "Uncompress your image:"
msgstr "解压缩镜像："

msgid "Only the lower USB-A port is configured for storage devices and only this port will work when trying to access a storage device in U-Boot."
msgstr "在U-Boot中只能使用下方的USB-A端口来连接优盘。"

msgid "These steps will show how to flash the eMMC on Linux with a USB stick. You only need a complete image saved on the USB stick and a bootable WIC image. (e.g. |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext|). Set the |ref-bootswitch| to SD Card."
msgstr "下面这些步骤展示如何在Linux系统上使用USB大容量存储设备烧写eMMC。您只需要一个保存在USB优盘上的完整镜像和一个可引导的WIC镜像。（例如：|yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext|）。将 |ref-bootswitch| 设置为SD卡。"

msgid "Flash your WIC image (for example |yocto-imagename|.roots.wic) from the SD card to eMMC. This will partition the card and copy imx-boot, Image, dtb, dtbo, and root file system to eMMC."
msgstr "将您保存在SD的WIC镜像（例如 |yocto-imagename|.roots.wic）烧写到eMMC。这将对卡进行分区，并将imx-boot、Image、dtb、dtbo和根文件系统复制到eMMC。"

msgid "The RAUC (Robust Auto-Update Controller) mechanism support has been added to meta-ampliphy. It controls the procedure of updating a device with new firmware. This includes updating the Linux kernel, Device Tree, and root filesystem. PHYTEC has written an online manual on how we have intergraded RAUC into our BSPs: `L-1006e.A6 RAUC Update & Device Management Manual <https://www.phytec.de/cdocuments/?doc=F4DiM>`__."
msgstr "BSP支持RAUC（Robust Auto-Update Controller）。它管理设备固件更新的过程。这包括更新Linux内核、设备树和根文件系统。PHYTEC已撰写了一份在线手册，介绍如何在我们的BSP中集成RAUC：`L-1006e.A6 RAUC更新与设备管理手册 <https://www.phytec.de/cdocuments/?doc=F4DiM>`__。"

msgid "Download imx-boot from our server or get it from your Yocto build directory at build/deploy-|yocto-distro|/images/|yocto-machinename|/. For flashing a wic image to eMMC, you will also need |yocto-imagename|-|yocto-machinename|.rootfs.wic"
msgstr "从我们的服务器下载 imx-boot，或者从您的 Yocto 编译目录中的 build/deploy-|yocto-distro|/images/|yocto-machinename|/ 获取它。为了将 wic 镜像烧写到 eMMC，你还需要 |yocto-imagename|-|yocto-machinename|.rootfs.wic"

msgid "Now you can mount the root partition and copy e.g. the |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext| image to it. Then unmount it again:"
msgstr "现在您可以挂载根分区并将例如 |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext| 镜像复制到其中。然后再卸载它："

msgid "Now you can mount the new partition and copy e.g. |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext| image to it. Then unmount it again:"
msgstr "现在您可以挂载新的分区并将例如 |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext| 镜像复制到其中。然后再次卸载它："

msgid "The device tree representation for UART1 pinmuxing: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L387`"
msgstr "UART1引脚复用的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L387`"

msgid "The device tree representation for RS232 and RS485: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L251`"
msgstr "RS232和RS485的设备树： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L251`"

msgid "We currently use dynamic IP addresses in U-Boot. This is enabled by this variable:"
msgstr "我们目前在U-Boot中使用动态IP地址。这是通过以下这个变量启用的："

msgid "Set up path for NFS. A modification could look like this:"
msgstr "设置NFS的路径。一个示例如下："

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec:`/blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L261`"
msgstr "MMC（SD卡插槽）接口的DT配置：:linux-phytec:`/blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L261`"

msgid "DT configuration for the eMMC interface can be found here: :linux-phytec:`/blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L181`"
msgstr "eMMC接口的DT配置：:linux-phytec:`/blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L181`"

msgid "The definition of the SPI master node in the device tree can be found here: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L67`"
msgstr "在设备树中，SPI主节点的定义：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L67`"

msgid "Device tree configuration for the User I/O configuration can be found here: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L160`"
msgstr "GPIO的设备树配置：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L160`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L81`"
msgstr "I²C1 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L81`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L145`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L145`"

#, fuzzy
msgid "DT representation, e.g. in |som| file imx8mp-phycore-som.dtsi can be found in our PHYTEC git: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L169`"
msgstr "核心板 phyCORE-|soc| 的设备树imx8mp-phycore-som.dtsi可以在PHYTEC git中找到： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L169`"

msgid "DT representation for I²C RTCs: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L175`"
msgstr "I²C RTCs 的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L175`"

msgid "DT representation for USB Host: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L220`"
msgstr "USB Host的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L220`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L130`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L130`"

msgid "The mainline BSP currently only supports software rendering."
msgstr "Mainline BSP目前仅支持软件渲染。"

msgid "The |sbc| supports LVDS output via the LVDS1 connector on the carrier board. The LVDS interface is enabled by default."
msgstr "|sbc| 通过开发板上的LVDS1连接器支持LVDS输出。LVDS接口默认启用。"

msgid "Weston will work without any additional configuration. Configuration options are done at /etc/xdg/weston/weston.ini."
msgstr "Weston可以在无需额外配置的情况下运行。配置选项位于 /etc/xdg/weston/weston.ini。"

msgid "Device tree description of LVDS can be found here: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L182`"
msgstr "LVDS的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L182`"

msgid "We noticed some visible backlight flickering on brightness level 1 (probably due to frequency problems with the hardware)."
msgstr "我们注意到在亮度级别1上有一些明显的背光闪烁（可能是由于硬件频率问题导致的）。"

msgid "The X_ONOFF pin connected to the ON/OFF button can be pressed long to trigger Power OFF without SW intervention. With the *snvs_pwrkey* driver, the KEY_POWER event is also reported to userspace when the button is pressed. On default, systemd is configured to ignore such events. The function of Power OFF without SW intervention are not configured. Triggering a power off with systemd when pushing the ON/OFF button can be configured under ``/etc/systemd/logind.conf`` and set using:"
msgstr "连接到开/关按钮的 X_ONOFF 引脚可以长按以触发关机，而无需软件干预。使用 *snvs_pwrkey* 驱动程序时，当按下按钮时，KEY_POWER 事件也会报告给用户空间。默认情况下，systemd 被配置为忽略此类事件。无软件干预的关机功能没有配置。可以在 ``/etc/systemd/logind.conf`` 中配置在按下开/关按钮时通过 systemd 触发关机："

msgid "Even if there is no network available, you can update the eMMC. For that, you only need a ready-to-use image file (``*.wic``) located on the SD card. Because the image file is quite large, you have to enlarge your SD card to use its full space (if it was not enlarged before). To enlarge your SD card, see Resizing ext4 Root Filesystem."
msgstr "即使没有可用的网络，您也可以更新eMMC。为此，您需要一个位于SD卡上的镜像文件（``*.wic``）。由于镜像文件相当大，您需要扩展SD卡以使用其全部空间（如果之前没有扩展的话）。有关如何扩展SD卡，请参阅调整 ext4 根文件系统的大小一节。"

msgid "There is one more overlay available for phyboard-pollux-imx8mp-2.conf: imx8mp-phyboard-pollux-1552.1.dtbo"
msgstr "phyboard-pollux-imx8mp-2.conf还有一个可用的overlay文件：imx8mp-phyboard-pollux-1552.1.dtbo"

msgid "The following is an example of the pin muxing of the UART1 device in imx8mp-phyboard-pollux.dtsi:"
msgstr "以下是imx8mp-phyboard-pollux.dtsi中UART1的引脚复用示例："

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n331`"
msgstr "RS232和RS485的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n331`"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n367`"
msgstr "MMC（SD卡插槽）接口的DT配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n367`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n220`"
msgstr "eMMC接口的DT配置：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n220`"

msgid ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n72`"
msgstr ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n72`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n216`"
msgstr "GPIO的设备树配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n216`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n105`"
msgstr "I²C1总线DT配置（例如 |dt-som|.dtsi）： :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n105`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n201`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n201`"

#, fuzzy
msgid "DT representation, e.g. in |som| file imx8mp-phycore-som.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n201`"
msgstr "phyCORE-|soc| 核心板的设备树imx8mp-phycore-som.dtsi可以在PHYTEC git中找到：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n201`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n207`"
msgstr "I²C RTC的设备树表示：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy17#n207`"

msgid "DT representation for USB Host: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n341`"
msgstr "USB Host的DT配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n341`"

msgid "Device Tree CAN configuration of imx8mp-phyboard-pollux.dtsi: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n165`"
msgstr "imx8mp-phyboard-pollux.dtsi的CAN设备树配置： :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n165`"

msgid "Device Tree PCIe configuration of imx8mm-phyboard-polis.dtsi: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n277`"
msgstr "imx8mm-phyboard-polis.dtsi的PCIe设备树配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n277`"

msgid "If the sound is not audible change playback devices to the software volume control playback devices, set *playback.pcm* to the respective softvol playback device either \"softvol_hdmi\" or \"softvol_pebav10\". Use alsamixer controls to vary the volume levels."
msgstr "如果听不到声音，请将播放设备更改为软件音量控制播放设备，将 *playback.pcm* 设置为相应的软音量播放设备，选择 \"softvol_hdmi\" 或 \"softvol_pebav10\"。使用 alsamixer 控件来调整音量水平。"

msgid "Device Tree Audio configuration: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n57`"
msgstr "音频的设备树配置：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n57`"

msgid "The |sbc| supports up to 4 different display outputs. Three can be used simultaneously. The following table shows the required extensions and devicetree overlays for the different interfaces."
msgstr "该 |sbc| 支持多达4种不同的显示输出。可以同时使用三种。下表显示了不同接口所需的扩展板和设备树overlay。"

msgid "imx8mp-phyboard-pollux-peb-av-010.dtbo (loaded by default)"
msgstr "imx8mp-phyboard-pollux-peb-av-010.dtbo（默认加载）"

msgid "MIPI"
msgstr "MIPI"

msgid "PEB-AV-12 (MIPI to LVDS)"
msgstr "PEB-AV-12 (MIPI到LVDS)"

msgid "imx8mp-phyboard-pollux-peb-av-012.dtbo"
msgstr "imx8mp-phyboard-pollux-peb-av-012.dtbo"

msgid "HDMI will not work if LVDS1 (onboard) is enabled."
msgstr "如果启用了LVDS1（板载），HDMI将无法工作。"

msgid "The default-enabled Interfaces are HDMI and LVDS0 (PEB-AV-010). We support a 10'' edt,etml1010g0dka display for the PEB-AV-10 and PEB-AV-12."
msgstr "默认启用的接口是HDMI和LVDS0（PEB-AV-010）。我们的PEB-AV-10和PEB-AV-12扩展板支持10英寸edt,etml1010g0dka显示屏。"

msgid "In our BSP, the default Weston output is set to HDMI. ::"
msgstr "在我们的BSP中，默认的Weston输出设置为HDMI. ::"

msgid "Device tree description of LVDS-1 and HDMI can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n255` :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n180`"
msgstr "LVDS-1和HDMI的设备树： :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n255` :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n180`"

msgid "The device tree of LVDS-0 on PEB-AV-10 can be found here: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n132`"
msgstr "PEB-AV-10上LVDS-0的设备树配置：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy17#n132`"

msgid "The device tree description of GPIO Fan can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n26`"
msgstr "GPIO风扇的设备树配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy17#n26`"

#, fuzzy
msgid "The |soc| SoC contains a Neural Processing Unit up to 2.3 TOPS as an accelerator for artificial intelligence operations. Refer to our latest |som| AI Kit Guide on the |som| download section to get information about the NPU: `L-1015e.A0 phyCORE-i.MX 8M Plus AI Kit Guide <https://www.phytec.de/cdocuments/?doc=ZQBhDw>`_"
msgstr "|soc| SoC包含一个NPU，其运算能力达到 2.3 TOPS，专用于人工智能操作。有关 NPU 的信息，请参考我们最新的 phyCORE-|soc| AI 套件指南，您可以在 phyCORE-|soc| 下载部分找到：`L-1015e.A0 phyCORE-i.MX 8M Plus AI Kit Guide <https://www.phytec.de/cdocuments/?doc=ZQBhDw>`_"

msgid "NXP Examples for eIQ"
msgstr "NXP eIQ 示例"

msgid "NXP provides a set of machine learning examples for eIQ using Python3. To add a pre-configured machine learning package group, add to your local.conf and build your BSP::"
msgstr "NXP提供了一组使用Python3的针对eIQ的机器学习示例，。要添加一个预配置的机器学习软件包，请将其添加到你的local.conf中并编译你的BSP::"

#, fuzzy
msgid "This will require about 1GB of additional space on the SD Card. Instructions on how to install and use the NXP examples can be found at https://community.nxp.com/t5/NXP-Tech-Blog/PyeIQ-3-x-Release-User-Guide/ba-p/1305998."
msgstr "这将需要在SD卡上有大约1GB的空间。有关如何安装和使用NXP示例的说明，请访问 https://community.nxp.com/t5/Blogs/PyeIQ-3-x-Release-User-Guide/ba-p/1305998。"

msgid "The installation of the eiq examples with pip3 requires an internet connection."
msgstr "使用pip3安装eiq示例需要互联网连接。"

msgid "On some Ubuntu 20.04 hosts, cmake uses the host's Python 3 instead of Python 3.7 from Yocto when building python3-pybind11. (see https://community.nxp.com/t5/i-MX-Processors/Yocto-L5-4-70-2-3-0-build-image-failed/m-p/1219619)"
msgstr "在某些Ubuntu 20.04主机上，cmake在编译python3-pybind11时使用主机的Python 3，而不是Yocto中的Python 3.7。（参见：https://community.nxp.com/t5/i-MX-Processors/Yocto-L5-4-70-2-3-0-build-image-failed/m-p/1219619）"

msgid "As a workaround edit, the python3-pybind11 recipe by::"
msgstr "可以用以下方法解决，修改python3-pybind11的recipe："

msgid "and add to the file::"
msgstr "并将以下内容加入文件::"

msgid "Reading the registers using ``/dev/mem`` will cause the system to hang unless the *ocotp_root_clk* is enabled. To enable this clock permanent, add to the device tree:"
msgstr "除非*ocotp_root_clk*已启用，否则使用``/dev/mem``读取寄存器会导致系统挂起。要永久启用此时钟，请在设备树中添加："

msgid "2024/08/05"
msgstr "2024/08/05"

msgid "When the PCM-070 does not have the X1 extension connector populated, some Software features described here do not work. These are Wirless LAN, PCIe, CSI (cameras), PEB-AV-12, CAN, USB-OTG."
msgstr "当PCM-070开发板没有安装X1扩展连接器时，此处描述的一些软件功能将无法使用。这些功能包括无线局域网、PCIe、CSI（摄像头）、PEB-AV-12、CAN和USB-OTG。"

msgid "Edit the file configs/phycore-|kernel-socname|\\_defconfig:"
msgstr "编辑文件 configs/phycore-|kernel-socname|\\_defconfig:"

msgid "Choose the correct RAM size as populated on the board and uncomment the line for this ram size. For Article number 0F\\ **8**\\ 443I, use [...]_4GB_2GHZ, for 0F\\ **5**\\ 443I, use [...]_4GB. After saving the changes, follow the remaining steps from |ref-build-uboot|."
msgstr "选择与板上配置匹配的正确RAM大小，并取消注释该RAM大小的行。对于型号0F\\ **8**\\ 443I，请使用 [...]_4GB_2GHZ；对于0F\\ **5**\\ 443I，请使用 [...]_4GB。保存更改后，请按照 |ref-build-uboot| 进行操作。"

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n331`"
msgstr "RS232和RS485的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n331`"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n367`"
msgstr "MMC（SD卡插槽）接口的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n367`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n220`"
msgstr "eMMC接口的DT配置：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n220`"

msgid ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n72`"
msgstr ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n72`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n216`"
msgstr "GPIO配置的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n216`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n105`"
msgstr "I²C1 总线DT配置（例如 |dt-som|.dtsi）：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n105`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n201`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）：imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n201`"

#, fuzzy
msgid "DT representation, e.g. in |som| file imx8mp-phycore-som.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n201`"
msgstr "核心板phyCORE-|soc| 的设备树文件 imx8mp-phycore-som.dtsi 可以在我们的 PHYTEC git 中找到：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n201`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n207`"
msgstr "I²C RTC的DT表示： :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.10.72_2.2.0-phy18#n207`"

msgid "DT representation for USB Host: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n341`"
msgstr "USB Host的DT表示：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n341`"

msgid "Device Tree CAN configuration of imx8mp-phyboard-pollux.dtsi: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n165`"
msgstr "imx8mp-phyboard-pollux.dtsi的设备树CAN配置： :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n165`"

msgid "Device Tree PCIe configuration of imx8mm-phyboard-polis.dtsi: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n277`"
msgstr "imx8mm-phyboard-polis.dtsi的设备树PCIe配置：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n277`"

msgid "Device Tree Audio configuration: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy18#n57`"
msgstr "设备树音频DT配置：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy18#n57`"

msgid "Device tree description of LVDS-1 and HDMI can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n255` :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n180`"
msgstr "LVDS-1和HDMI的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n255` :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n180`"

msgid "The device tree of LVDS-0 on PEB-AV-10 can be found here: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy18#n132`"
msgstr "PEB-AV-10上LVDS-0的设备树：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.10.72_2.2.0-phy18#n132`"

msgid "The device tree description of GPIO Fan can be found here: :imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n26`"
msgstr "GPIO风扇的设备树：:imx-dt:`imx8mp-phyboard-pollux.dtsi?h=v5.10.72_2.2.0-phy18#n26`"

#, fuzzy
msgid "Starting with PD23.1.0 release, the |som| SoMs with revision 1549.3 and newer also support 2GHz RAM timings. These will be enabled for supported boards automatically, but they can also be enabled or disabled manually."
msgstr "从PD23.1.0版本开始，带有1549.3及更高版本的phyCORE-|soc| SoM也支持2GHz的RAM时序。这将在支持的核心板上自动启用，但也可以手动启用或禁用。"

msgid "Edit the file configs/phycore-|kernel-socname|\\_defconfig. The fixed RAM size with 2GHz timings will be used:"
msgstr "编辑文件 configs/phycore-|kernel-socname|\\_defconfig。将使用固定的2GHz时序的RAM大小："

msgid "Choose the correct RAM size as populated on the board and uncomment the line for this ram size. When not specifying the ``CONFIG_PHYCORE_IMX8MP_USE_2GHZ_RAM_TIMINGS`` option, the 1.5GHz timings will be chosen by default. After saving the changes, follow the remaining steps from |ref-build-uboot|."
msgstr "选择正确的RAM大小，根据板上的配置取消该RAM大小的注释。当不指定 ``CONFIG_PHYCORE_IMX8MP_USE_2GHZ_RAM_TIMINGS`` 选项时，默认将选择1.5GHz的时序。保存更改后，按照 |ref-build-uboot| 中的剩余步骤进行操作。"

msgid "The device tree representation for UART1 pinmuxing: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n536`"
msgstr "UART1引脚复用的设备树表示： :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n536`"

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n341`"
msgstr "RS232和RS485的设备树：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n341`"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n380`"
msgstr "MMC（SD卡槽）接口的DT配置：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n380`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n223`"
msgstr "eMMC接口的DT配置：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n223`"

msgid ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n76`"
msgstr ":imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n76`"

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n229`"
msgstr "GPIO的设备树配置：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n229`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n110`"
msgstr "I²C1 总线DT配置（例如 |dt-som|.dtsi）：:imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n110`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n212`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts ）: imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n212`"

msgid "On the |som| there is an i2c EEPROM flash populated. It has two addresses. The main EEPROM space (bus: I2C-0 address: 0x51) and the ID-page (bus: I2C-0 address: 0x59) can be accessed via the sysfs interface in Linux. The first 256 bytes of the main EEPROM and the ID-page are used for board detection and must not be overwritten. Overwriting reserved spaces will result in boot issue."
msgstr "在 |som| 上有一个i2c EEPROM闪存。它有两个地址。主EEPROM空间（总线：I2C-0 地址：0x51）和ID页（总线：I2C-0 地址：0x59）可以通过Linux中的sysfs接口访问。主EEPROM和ID页的前256个字节用于板检测，不可被覆盖。覆盖这些保留的空间将导致启动问题。"

#, fuzzy
msgid "DT representation, e.g. in |som| file imx8mp-phycore-som.dtsi can be found in our PHYTEC git: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n199`"
msgstr "phyCORE-|soc| 核心板的设备树 imx8mp-phycore-som.dtsi 可以在 PHYTEC git 中找到： :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n199`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n207`"
msgstr "I²C RTCs的DT表示： :imx-dt:`imx8mp-phycore-som.dtsi?h=v5.15.71_2.2.2-phy3#n207`"

msgid "DT representation for USB Host: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n351`"
msgstr "USB主机的DT表示：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n351`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n175`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n175`"

msgid "Device Tree PCIe configuration of |dt-carrierboard|.dts: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n287`"
msgstr "|dt-carrierboard|.dts的设备树PCIe配置：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n287`"

msgid "Device Tree Audio configuration: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n58`"
msgstr "音频DT配置：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n58`"

msgid "For dual display at LVDS0 (PEB-AV-010) and MIPI (PEB-AV-012), both dtbos need to be loaded at the bootenv.txt and the weston.ini should look like this:"
msgstr "对于LVDS0 (PEB-AV-010)和MIPI (PEB-AV-012)的双显示，bootenv.txt中需要加载两个dtbo，weston.ini应如下所示："

msgid "Triple Display"
msgstr "三屏显示"

msgid "Three outputs: HDMI, LVDS-1 (PEB-AV-10), and LVDS-2 (PEB-AV-12). Remember to load both dtbos for LVDS interfaces."
msgstr "三个输出：HDMI、LVDS-1（PEB-AV-10）和LVDS-2（PEB-AV-12）。请记得为LVDS接口加载两个dtbo。"

msgid "Device tree description of LVDS-1 and HDMI can be found here: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n264` :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n191`"
msgstr "LVDS-1和HDMI的设备树：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n264` :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n191`"

msgid "The device tree of LVDS-0 on PEB-AV-10 can be found here: :imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n133`"
msgstr "PEB-AV-10上的LVDS-0设备树：:imx-dt:`overlays/imx8mp-phyboard-pollux-peb-av-010.dtso?h=v5.15.71_2.2.2-phy3#n133`"

msgid "The device tree description of GPIO Fan can be found here: :imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n33`"
msgstr "GPIO风扇的设备树：:imx-dt:`imx8mp-phyboard-pollux-rdk.dts?h=v5.15.71_2.2.2-phy3#n33`"

msgid "2024/11/08"
msgstr "2024/11/08"

msgid "2024/11/06"
msgstr "2024/11/06"

msgid "2024/04/08"
msgstr "2024/04/08"

msgid "PD24.1.1"
msgstr "PD24.1.1"

msgid "Send the image with the ``dd`` command combined with ssh through the network to the eMMC of your device:"
msgstr "通过网络使用 ``dd`` 命令结合ssh将镜像发送到您设备的eMMC："

msgid "Flash eMMC from USB in U-Boot on Target"
msgstr "在开发板的U-Boot环境中从USB烧写eMMC"

msgid "Flash an SD card with a working image and create a third FAT partition. Copy the WIC image (for example |yocto-imagename|.\\ |yocto-imageext|) to this partition."
msgstr "将一个可用的镜像烧写到SD卡，并创建一个FAT格式的第三分区。将WIC镜像（例如 |yocto-imagename|.\\ |yocto-imageext|）复制到该分区。"

msgid "Flash your WIC image (for example |yocto-imagename|.\\ |yocto-imageext|) from the SD card to eMMC. This will partition the card and copy imx-boot, Image, dtb, dtbo, and root file system to eMMC."
msgstr "将您的WIC镜像（例如 |yocto-imagename|.\\ |yocto-imageext|）从SD卡烧写到eMMC。这将对卡进行分区，并将imx-boot、Image、dtb、dtbo和根文件系统复制到eMMC。"

msgid "Alternatively, ``dd`` may be used instead:"
msgstr "另外，也可以使用 ``dd`` 命令："

msgid "Keep in mind that the root partition does not make use of the full space when flashing with ``dd``."
msgstr "请注意，在使用 ``dd`` 进行烧写时，root分区并没有使用全部存储容量。"

msgid "Download imx-boot from our server or get it from your Yocto build directory at build/deploy/images/|yocto-machinename|/. For flashing a wic image to eMMC, you will also need |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext|"
msgstr "从我们的服务器下载imx-boot，或者从你的Yocto编译目录中的build/deploy/images/|yocto-machinename|/获取它。为了将wic镜像烧写到eMMC，你还需要 |yocto-imagename|-|yocto-machinename|.\\ |yocto-imageext|"

msgid "Build the SDK"
msgstr "编译SDK"

msgid "You can build the SDK yourself with Yocto:"
msgstr "您可以使用Yocto自行编译SDK："

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L261`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L261`"

msgid "DT configuration for the eMMC interface can be found here: :linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L181`"
msgstr "eMMC接口的DT配置：:linux-phytec:`blob/v6.6.21-phy1/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L181`"

msgid "|doc-id| |soc| BSP Mainline Manual"
msgstr "|doc-id| |soc| BSP Mainline 手册"

msgid "2024/06/26"
msgstr "2024/06/26"

msgid "Download imx-boot from our server or get it from your Yocto build directory at build/deploy/images/|yocto-machinename|/. For flashing a wic image to eMMC, you will also need |yocto-imagename|-|yocto-machinename|.rootfs.wic"
msgstr "从我们的服务器下载 imx-boot，或者从您的 Yocto 编译目录中的 build/deploy/images/|yocto-machinename|/ 获取它。为了将 wic 镜像烧写到 eMMC，你还需要 |yocto-imagename|-|yocto-machinename|.rootfs.wic"

msgid "i.MX 93 Manuals"
msgstr "i.MX 93 手册"

#, fuzzy
msgid "i.MX 95 Manuals"
msgstr "i.MX 9 手册"

msgid "i.MX 9 Manuals"
msgstr "i.MX 9 手册"

#, fuzzy
msgid "i.MX 9"
msgstr "i.MX 9 手册"

msgid "On our web page, you can see all supported Machines with the available Article Numbers for this release: |yocto-manifestname|, see `download <dlpage-bsp_>`_."
msgstr "在我们的网页上，您可以查看适用于BSP版本 |yocto-manifestname| 的所有Machine及其对应的Article Numbers(产品型号)： 请参见 `网页 <dlpage-bsp_>`_。"

msgid "If you choose a specific **Machine Name** in the section **Supported Machines**, you can see which **Article Numbers** are available under this machine and also a short description of the hardware information. In case you only have the **Article Number** of your hardware, you can leave the **Machine Name** drop-down menu empty and only choose your **Article Number**. Now it should show you the necessary **Machine Name** for your specific hardware."
msgstr "如果您在“Supported Machines”部分选择了特定的 **Machine Name** ，您可以查看该Machine下可用的 **Article Number(产品型号)** 以及硬件信息的简短描述。如果您只有硬件的 **Article Number** ，可以将 **Machine Name** 下拉菜单留空，仅选择您的 **Article Number** 。现在它会显示您特定硬件所需的 **Machine Name** 。"

msgid "**Console examples in this BSP manual only focus on phyBOARD-Segin i.MX 93. Similar commands can also be executed for/on phyBOARD-Nash i.MX 93**"
msgstr "**本BSP手册中的终端示例仅针对phyBOARD-Segin i.MX 93。类似的命令也可以在phyBOARD-Nash i.MX 93上执行。**"

msgid "phyBOARD-Segin i.MX 93 Components"
msgstr "phyBOARD-Segin i.MX 93 器件"

msgid "**phyBOARD-Segin i.MX 93 Components (top)**"
msgstr "**phyBOARD-Segin i.MX 93 器件（顶部）**"

msgid "**phyBOARD-Segin i.MX 93 Components (bottom)**"
msgstr "**phyBOARD-Segin i.MX 93 器件（底部）**"

msgid "phyBOARD-Nash i.MX 93 Components"
msgstr "phyBOARD-Nash i.MX 93 器件"

msgid "**phyBOARD-Nash i.MX 93 Components (top)**"
msgstr "**phyBOARD-Nash i.MX 93 器件（顶部）**"

msgid "**phyBOARD-Nash i.MX 93 Components (bottom)**"
msgstr "**phyBOARD-Nash i.MX 93 器件（底部）**"

msgid "Connect the targets debug console with your host. Use |ref-debugusbconnector|."
msgstr "将开发板的调试接口与您的主机连接。使用 |ref-debugusbconnector|。"

msgid "Open serial/usb port with 115200 baud and 8N1 (you should see u-boot/linux start on the console"
msgstr "以115200波特率和8N1格式打开串口/USB端口（您应该在终端上看到u-boot/linux启动信息）"

msgid "**bl31-imx93.bin**: ARM Trusted Firmware binary"
msgstr "**bl31-imx93.bin**: ARM可信固件二进制文件"

msgid "**lpddr4_dmem_1d_v202201.bin, lpddr4_dmem_2d_v202201.bin, lpddr4_imem_1d_v202201.bin, lpddr4_imem_2d_v202201.bin**: DDR PHY firmware images"
msgstr "**lpddr4_dmem_1d_v202201.bin, lpddr4_dmem_2d_v202201.bin, lpddr4_imem_1d_v202201.bin, lpddr4_imem_2d_v202201.bin**: DDR PHY 固件镜像"

msgid "**imx93-phyboard-*.dtb**: Kernel device tree file"
msgstr "**imx93-phyboard-*.dtb**: 内核设备树文件"

msgid "**imx93-phy\\*.dtbo**: Kernel device tree overlay files"
msgstr "**imx93-phy\\*.dtbo**: 内核设备树overlay文件"

msgid "**phytec-\\*.tar.gz**: Root file system, of bitbake-image that was built."
msgstr "**phytec-\\*.tar.gz**: bitbake-image编译生成的root文件系统。"

msgid "**phytec-qt6demo-image-phyboard-*-imx93-*.tar.gz**: when bitbake-build was processed for ``phytec-qt6demo-image``"
msgstr "**phytec-qt6demo-image-phyboard-*-imx93-*.tar.gz**：在使用bitbake-build编译 ``phytec-qt6demo-image`` 时"

msgid "**phytec-headless-image-phyboard-*-imx93-*.tar.gz**: when bitbake-build was processed for ``phytec-headless-image``"
msgstr "**phytec-headless-image-phyboard-*-imx93-*.tar.gz**：在使用bitbake-build编译 ``phytec-headless-image`` 时"

msgid "**phytec-\\*.rootfs.wic.xz**: Compressed bootable SD card image of bitbake-image that was built. Includes bootloader, DTBs, Kernel and Root file system."
msgstr "**phytec-\\*.rootfs.wic.xz**：bitbake-image编译生成的压缩的可引导SD卡镜像，包括bootloader、设备树二进制文件（DTB）、内核和根文件系统。"

msgid "**phytec-qt6demo-image-phyboard-*-imx93-*.rootfs.wic.xz**: when bitbake-build was processed for ``phytec-qt6demo-image``"
msgstr "**phytec-qt6demo-image-phyboard-*-imx93-*.rootfs.wic.xz**：在使用bitbake-build编译 ``phytec-qt5demo-image`` 时"

msgid "**phytec-headless-image-phyboard-*-imx93-*.rootfs.wic.xz**: when bitbake-build was processed for ``phytec-headless-image``"
msgstr "**phytec-headless-image-phyboard-*-imx93-*.rootfs.wic.xz**：在使用bitbake-build编译 ``phytec-headless-image`` 时"

msgid "**imx93-11x11-evk_m33_\\*.bin**, binaries of demo applications for the Cortex-M33 MCU; can be manually loaded and started with U-Boot or Linux"
msgstr "**imx93-11x11-evk_m33_\\*.bin**，Cortex-M33 MCU的Demo应用程序的二进制文件；可以通过U-Boot或Linux手动加载和启动"

msgid "Hardware revision baseboard:"
msgstr "底板版本："

msgid "|sbc-segin|: 1472.5"
msgstr "|sbc-segin|: 1472.5"

#, fuzzy
msgid "|sbc-nash|: 1616.0, 1616.1, 1616.2"
msgstr "|sbc-nash|: 1616.0, 1616.1"

msgid "can be run to inspect whether the current setup is affected. If |emmcdev|\\p1 and mmcblk1p1 have an identical UUID, the setup is affected."
msgstr "可以运行以检查当前设置是否受到影响。如果 |emmcdev|\\p1 和 mmcblk1p1 具有相同的 UUID，则该设置受到影响。"

msgid "If there is no network available, you can update the eMMC from SD card. For that, you only need a ready-to-use image file (``*.wic``) located on the SD card. Because the image file is quite large, you have to enlarge your SD card to use its full space (if it was not enlarged before). To enlarge your SD card, see Resizing ext4 Root Filesystem."
msgstr "如果没有可用的网络，您可以通过SD卡更新eMMC。为此，您只需在SD卡上准备一个可用的镜像文件（``*.wic``）。由于镜像文件相当大，您需要扩展SD卡以使用其全部空间（如果之前没有扩展的话）。有关如何扩展SD卡，请参见“调整 ext4 根文件系统的大小”。"

msgid "You can flash the eMMC on Linux. You only need a partup package or WIC image saved on the SD card."
msgstr "您可以在Linux上烧写eMMC。您只需在SD卡上保存一个partup包或WIC镜像即可。"

msgid "Show your saved partup package or WIC image or WIC.XZ image files on the SD card:"
msgstr "在SD卡上查看您保存的partup包或WIC镜像或WIC.XZ镜像文件："

msgid "The eMMC device can be recognized by the fact that it contains two boot partitions: (|emmcdev|\\ **boot0**; |emmcdev|\\ **boot1**)"
msgstr "eMMC设备的特征是它包含两个boot分区：(|emmcdev|\\  **boot0**; |emmcdev|\\  **boot1**)"

#, fuzzy
msgid "Write the image to the |som| eMMC (/dev/|emmcdev| **without** partition) using `partup`_:"
msgstr "使用 `partup`_ 将镜像写入 phyCORE-|soc| 的 eMMC (/dev/|emmcdev| **不带** 分区)："

msgid "**Using partup is highly recommended since it is easier to use and has the advantage of using the full capacity of the eMMC device, adjusting partitions accordingly.**"
msgstr "**强烈建议使用partup，因为它更易于使用，并且可以充分利用eMMC设备的容量，自动调整分区大小。**"

msgid "Alternatively, ``dd`` may be used instead."
msgstr "或者，可以使用 ``dd`` 命令。"

msgid "For uncompressed WIC images (\\*.wic):"
msgstr "对于未压缩的WIC镜像（\\*.wic）："

msgid "For compressed WIC images (\\*.wic.xz):"
msgstr "对于压缩的WIC镜像（\\*.wic.xz）："

msgid "Some PHYTECs BSPs produce compressed ``.wic.xz`` images. In this case, the compressed image must first be uncompressed."
msgstr "一些PHYTEC的BSP会生成压缩的 ``.wic.xz`` 镜像。在这种情况下，必须先对压缩镜像进行解压缩。"

msgid "Take an uncompressed image on the host and send it with ssh through the network to the eMMC of the target with a one-line command:"
msgstr "在主机上获取一个未压缩的镜像，并通过网络使用ssh将其发送到开发板的eMMC，使用一行命令："

msgid "These steps will show how to flash the eMMC on Linux with a USB stick. You only need a complete image saved on the USB stick and a bootable WIC image. (e.g. |yocto-imagename|-|yocto-machinename|.rootfs.wic). Set the |ref-bootswitch| to SD Card."
msgstr "下面这些步骤展示如何在Linux系统上使用U盘烧写eMMC。您需要一个保存了完整镜像的U盘和一个可启动的WIC镜像（例如 |yocto-imagename|-|yocto-machinename|.rootfs.wic）。将 |ref-bootswitch| 设置为SD卡启动。"

#, fuzzy
msgid "Write the image to the |som| eMMC (/dev/|emmcdev| without partition):"
msgstr "将镜像写入 phyCORE-|soc| eMMC (/dev/|emmcdev|，无分区)："

msgid "The RAUC (Robust Auto-Update Controller) mechanism support has been added to meta-ampliphy. It controls the procedure of updating a device with new firmware. This includes updating the Linux kernel, Device Tree, and root filesystem. PHYTEC has written an online manual on how we have intergraded RAUC into our BSPs: `L-1006e.A5 RAUC Update & Device Management Manual <https://www.phytec.de/cdocuments/?doc=fgByJg>`__."
msgstr "BSP支持RAUC（Robust Auto-Update Controller）。它管理设备固件更新的过程。这包括更新Linux内核、设备树和根文件系统。PHYTEC已撰写了一份在线手册，介绍如何在我们的BSP中集成RAUC：`L-1006e.A5 RAUC更新与设备管理手册 <https://www.phytec.de/cdocuments/?doc=fgByJg>`__。"

msgid "To build the imx-boot, you need to **gather** these **files** for later use with **imx-mkimage tool**:"
msgstr "要编译imx-boot，您需要 **收集** 这些 **文件** 以便后续使用 **imx-mkimage工具** ："

msgid "**Container image**: mx93a1-ahab-container.img"
msgstr "**容器镜像**：mx93a1-ahab-container.img"

msgid "If you already built our BSP with Yocto, you can get these files from the directory mentioned here: |ref-bsp-images|"
msgstr "如果您已经使用Yocto编译了我们的BSP，您可以从此处提到的目录中获取这些文件：|ref-bsp-images|"

msgid "Or you can download the files from the PHYTEC download server (|link-boot-tools|). You can use the commands below to download all the files from that server:"
msgstr "或者您可以从PHYTEC下载服务器（ |link-boot-tools| ）下载文件。您可以使用下面的命令从该服务器下载所有文件："

msgid "Build u-boot:"
msgstr "编译u-boot："

msgid "|u-boot-multiple-defconfig-note|"
msgstr "|u-boot-multiple-defconfig-note|"

msgid "Build final flash.bin with imx-mkimage"
msgstr "使用 imx-mkimage 编译最终的 flash.bin"

msgid "Get imx-mkimage:"
msgstr "获取 imx-mkimage："

msgid "Copy firmware binaries into imx-mkimage"
msgstr "将固件二进制文件复制到 imx-mkimage"

msgid "Copy u-boot binaries and DTB into imx-mkimage"
msgstr "将u-boot二进制文件和DTB复制到imx-mkimage中"

msgid "|u-boot-multiple-dtb-note|"
msgstr "|u-boot-multiple-dtb-note|"

msgid "Build final flash.bin binary"
msgstr "编译最终的 flash.bin 二进制文件"

msgid "The flash.bin can be found at imx-mkimage/|u-boot-soc-name|/ directory and now can be flashed. A chip-specific offset is needed:"
msgstr "flash.bin可以在imx-mkimage/|u-boot-soc-name|/目录下找到，现在可以进行烧写。需要一个特定于芯片的偏移量："

msgid "In the command above, replace ``<sd-card>`` with your sd-card device name. For more information on how to find the device name, see the section :ref:`Finding the Correct Device <getting-started-find-correct-device>` in Getting Started."
msgstr "在上述命令中，将 ``<sd-card>`` 替换为您的SD卡设备名称。有关如何找到设备名称的更多信息，请参阅入门部分中的 :ref:`找到正确的设备名 <getting-started-find-correct-device>` 。"

msgid "Available overlays for phyboard-nash-imx93-1.conf are:"
msgstr "phyboard-nash-imx93-1.conf可用的overlay有："

msgid "Make sure the boot partition is mounted! If it is not you can mount it with:"
msgstr "确保boot分区已挂载！如果没有，您可以使用以下命令进行挂载："

#, python-brace-format
msgid "We use the ``${overlays}`` variable for overlays describing expansion boards that can not be detected during run time. To prevent applying overlays listed in the ``${overlays}`` variable during boot, the ``${no_overlays}`` variable can be set to `1` in the bootloader environment."
msgstr "我们使用 ``${overlays}`` 变量来描述在运行时无法检测到的扩展板。为了禁止在启动时应用列在 ``${overlays}`` 变量中的overlay，可以在bootloader环境中将 ``${no_overlays}`` 变量设置为 `1`。"

msgid "The first part of the string MX93_PAD_UART1_RXD__LPUART1_RX names the pad (in this example UART1_RXD). The second part of the string (LPUART1_RX) is the desired muxing option for this pad. The pad setting value (hex value on the right) defines different modes of the pad, for example, if internal pull resistors are activated or not. In this case, the internal pull up is activated."
msgstr "字符串的第一部分 MX93_PAD_UART1_RXD__LPUART1_RX 指定了引脚（在这个例子中是 UART1_RXD）。字符串的第二部分（LPUART1_RX）是该引脚的期望复用选项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部上拉电阻是否被激活。在当前情况下，内部上拉电阻被激活。"

#, fuzzy
msgid "The device tree representation for UART1 pinmuxing: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L263`"
msgstr "UART1引脚复用的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L259`"

msgid "|sbc| provides two ethernet interfaces."
msgstr "|sbc| 提供两个以太网接口。"

msgid "On |sbc-segin| we have:"
msgstr "在 |sbc-segin| 上，我们有："

msgid "a 100 megabit Ethernet provided by |som|"
msgstr "由 |som| 提供的百兆以太网"

msgid "and 100 megabit Ethernet provided by phyBOARD."
msgstr "由phyBOARD提供的百兆以太网。"

msgid "On |sbc-nash| we have:"
msgstr "在 |sbc-nash| 上，我们有："

msgid "and 1 gigabit Ethernet provided by phyBOARD."
msgstr "由phyBOARD提供的千兆以太网。"

#, fuzzy
msgid "WLAN/Bluetooth"
msgstr "蓝牙"

msgid "WLAN and Bluetooth connectivity are enabled on the |sbc-segin| using the PEB-WLBT-05 expansion card, and on the |sbc-nash| with the PEB-WLBT-07 expansion card. Installation instructions for these WLAN and Bluetooth expansion cards can be found in the \"The PEB-WLBT-05 for |sbc-segin| Quickstart Guide\" and the \"The PEB-WLBT-07 for |sbc-nash| Quickstart Guide\", respectively.\""
msgstr ""

#, fuzzy
msgid "PEB-WLBT-05 on |sbc-segin|"
msgstr "|sbc-segin| 上的音频"

#, fuzzy
msgid "With the BSP Version PD24.2.0 and newer, the PEB-WLBT-05 overlay needs to be activated first, otherwise the PEB-WLBT-05 won't be recognized."
msgstr "对于BSP版本PD24.2及更新版本，需要先激活PEB-WLBT-05 Overlay，否则PEB-WLBT-05将无法被识别。"

#, fuzzy
msgid "With PEB-WLBT-05 adapter, we use Sterling-LWB module from LSR for WLAN and Bluetooth support. This module supports 2,4 GHz bandwidth and can be run in several modes, like client mode, Access Point (AP) mode using WEP, WPA, WPA2 encryption, and more. More information about the module can be found at https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf"
msgstr "为了支持WLAN和蓝牙，我们使用来自LSR的Sterling-LWB模块。该模块支持2.4 GHz，并且可以在多种模式下运行，如客户端模式、使用WEP、WPA、WPA2加密的接入点（AP）模式等。有关该模块的更多信息，请访问 https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf"

msgid "For proper Bluetooth operation please make sure to follow the \"The PEB-WLBT-05 for |sbc-segin| Quickstart Guide\" to correctly set jumper J9 & J10 configurations."
msgstr ""

#, fuzzy
msgid "PEB-WLBT-07 on |sbc-nash|"
msgstr "|sbc-nash| 上的音频"

#, fuzzy
msgid "With the BSP Version PD24.2.1 and newer, the PEB-WLBT-07 overlay needs to be activated first, otherwise the PEB-WLBT-07 won't be recognized."
msgstr "对于BSP版本PD24.2及更新版本，需要先激活PEB-WLBT-05 Overlay，否则PEB-WLBT-05将无法被识别。"

#, fuzzy
msgid "With PEB-WLBT-07 adapter, we use MAYA-W2 from u-blox for WLAN and Bluetooth support. This module supports dual-band 2,4 GHz and 5 GHz bandwidth and can be run in several modes, like client mode, Access Point (AP) mode using WEP, WPA, WPA2 encryption, and more. More information about the module can be found at https://content.u-blox.com/sites/default/files/documents/MAYA-W2_DataSheet_UBX-22009721.pdf"
msgstr "为了支持WLAN和蓝牙，我们使用来自LSR的Sterling-LWB模块。该模块支持2.4 GHz，并且可以在多种模式下运行，如客户端模式、使用WEP、WPA、WPA2加密的接入点（AP）模式等。有关该模块的更多信息，请访问 https://connectivity-staging.s3.us-east-2.amazonaws.com/2019-09/CS-DS-SterlingLWB%20v7_2.pdf"

msgid "The following WLAN chapter assumes wireless network interface name is ``wlan0``. However with PEB-WLBT-07 adapter the name of the WLAN interface is actually ``mlan0``. Thus when using commands to configure wireless network, substitute ``wlan0`` with ``mlan0`` when using PEB-WLBT-07 on |sbc-nash|."
msgstr ""

#, fuzzy
msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L217` or here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L206`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L213` or here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L202`"

#, fuzzy
msgid "DT configuration for the eMMC interface can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L194` or here:"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L194` 或者这里："

msgid "The |sbc| doesn't have a set of pins especially dedicated for user I/Os since all GPIOs are used by kernel device drivers or used for a specific purpose. The processor has organized its GPIOs into five banks of 32 GPIOs each (GPIO1 – GPIO4) GPIOs. gpiochip0, gpiochip32, gpiochip64 and gpiochip96 are the sysfs representation of these internal |soc| GPIO banks GPIO1 – GPIO4."
msgstr "|sbc| 没有用户可以使用的GPIO，因为所有GPIO都被内核设备驱动程序使用或用于其他特定目的。处理器将其GPIO组织为五个32个GPIO的组（GPIO1 – GPIO4）。gpiochip0、gpiochip32、gpiochip64和gpiochip96是这些内部 |soc| GPIO组GPIO1 – GPIO4的sysfs表示。"

msgid "The GPIOs are identified as GPIO<X>_<Y> (e.g. GPIO4_07). <X> identifies the GPIO bank and counts from 1 to 4, while <Y> stands for the GPIO within the bank. <Y> is being counted from 0 to 31 (32 GPIOs on each bank)."
msgstr "GPIO被标识为GPIO<X>_<Y>（例如，GPIO4_07）。<X>标识GPIO Bank，并从1到4计数，而<Y>表示Bank内的GPIO。<Y>从0到31计数（每个Bank有32个GPIO）。"

msgid "Order of GPIOchips in ``i.MX 93 Application Processor Reference Manual`` and in Linux kernel differ!"
msgstr "``i.MX 93 Application Processor Reference Manual`` 中的GPIO芯片顺序与Linux内核中的顺序不同！"

msgid "GPIOchip address"
msgstr "GPIOchip 地址"

msgid "Linux"
msgstr "Linux"

msgid "Reference Manual"
msgstr "Reference Manual"

#, fuzzy
msgid "0x43810000"
msgstr "0x43810080"

msgid "gpiochip0"
msgstr "gpiochip0"

msgid "gpiochip2"
msgstr "gpiochip2"

#, fuzzy
msgid "0x43820000"
msgstr "0x43820080"

msgid "gpiochip1"
msgstr "gpiochip1"

msgid "gpiochip3"
msgstr "gpiochip3"

#, fuzzy
msgid "0x43830000"
msgstr "0x43830080"

msgid "gpiochip4"
msgstr "gpiochip4"

#, fuzzy
msgid "0x47400000"
msgstr "0x47400080"

msgid "Read the value of a GPIO (e.g GPIO 3 from chip0):"
msgstr "读取GPIO的值（例如，从chip0读取GPIO 3）："

#, fuzzy
msgid "Set the value of GPIO 3 on chip0 to 0 and daemonize:"
msgstr "将chip0上的GPIO 3的值设置为0并退出："

msgid "When demonizing gpioset command please note that the process is still running in the background and you need to kill it afterward to release the GPIO. Otherwise you might get an error when trying to change state of the same GPIO:"
msgstr ""

msgid "This is the expected behavior in libgpiod version 2."
msgstr ""

msgid "As a workaround it is possible to use the ``-t 0`` switch:"
msgstr ""

msgid "Support to access GPIOs via sysfs is not enabled by default any more. It is only possible with manually enabling CONFIG_GPIO_SYSFS in the kernel configuration. To make CONFIG_GPIO_SYSFS visible in menuconfig the option CONFIG_EXPERT has to be enabled first."
msgstr "默认情况下不再支持通过sysfs访问GPIO。只有手动在内核配置中启用CONFIG_GPIO_SYSFS后才能支持。要使CONFIG_GPIO_SYSFS在menuconfig中可见，必须先启用CONFIG_EXPERT选项。"

#, fuzzy
msgid "You can also add this option for example to the imx9_phytec_defconfig config in the linux kernel sources under arch/arm64/configs ::"
msgstr "您还可以将此选项添加到Linux内核源代码中arch/arm64/configs下的imx9_phytec_distro.config配置片段中，例如："

msgid "ADC"
msgstr "ADC"

msgid "The PHYTEC |soc| include general purpose Analog-to-Digital Converters (ADC) which can be used for interfacing analog sensors."
msgstr "PHYTEC |soc| 包含通用的ADC，可用于与模拟传感器连接。"

msgid "Reading the ADC values can be done through sysfs:"
msgstr "通过sysfs可以读取ADC值："

msgid "On |sbc-nash| the ADC lines are accessible on X16 expansion connector:"
msgstr "在 |sbc-nash| 上，ADC线路可以通过X16扩展连接器访问："

msgid "ADC input"
msgstr "ADC输入"

msgid "X16 pin"
msgstr "X16 引脚"

msgid "ADC_IN0"
msgstr "ADC_IN0"

msgid "47"
msgstr "47"

msgid "ADC_IN2"
msgstr "ADC_IN2"

msgid "49"
msgstr "49"

msgid "Here the LEDs ``green:heartbeat`` is on the |som|. If you are using phyBOARD-Segin there is also ``yellow`` LED which is populated on the PEB-EVAL-01."
msgstr "这里的LED灯 ``green:heartbeat`` 位于 |som| 上。如果您使用的是phyBOARD-Segin，PEB-EVAL-01上还有一个 ``黄色`` LED灯。"

#, fuzzy
msgid "Device tree configuration for the User I/O configuration can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-eval-01.dtso#L33`"
msgstr "GPIO的设备树配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-eval-01.dtso#L33`"

#, fuzzy
msgid "General I²C3 bus configuration (e.g. |dt-som|.dtsi): :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L88`"
msgstr "I²C3 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L88`"

#, fuzzy
msgid "General I²C2 bus configuration for |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L159` or for imx93-phyboard-nash.dts: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L117`"
msgstr "|dt-carrierboard|.dts的I²C2总线DT配置: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L155` 或者 imx93-phyboard-nash.dts:  :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L113`"

msgid "There are two different I2C EEPROM flashes populated on |som| SoM and on the |sbc|. For now only the one on the |som| is enabled, and it is used for board detection."
msgstr "在 |som| SoM和 |sbc| 上有两个不同的I2C EEPROM存储。目前只有 |som| 上的存储被启用，它用于硬件检测。"

msgid "The I2C EEPROM on the |som| SoM has its memory divided into two parts."
msgstr "|som| SoM上的I2C EEPROM的空间被划分两部分。"

msgid "normal area (size: 4096 bytes, bus: I2C-2, addr: 0x50)"
msgstr "正常区域（大小：4096字节，总线：I2C-2，地址：0x50）"

msgid "ID page (size: 32 bytes, bus: I2C-2, addr: 0x58)"
msgstr "ID页面（大小：32字节，总线：I2C-2，地址：0x58）"

msgid "It is possible to read and write from the device populated:"
msgstr "可以从设备进行读写操作："

msgid "To fill the whole EEPROM (ID page) with zeros we first need to disable the EEPROM write protection, use:"
msgstr "要将整个EEPROM（ID页）填充为零，我们首先需要禁用EEPROM写保护，请使用："

msgid "Then the EEPROM can be written to:"
msgstr "然后可以写入EEPROM："

msgid "To re-enable EEPROM wire protection, use:"
msgstr ""

msgid "The first 256 bytes of the normal EEPROM area (bus: I2C-2 addr: 0x50) are reserved and should not be overwritten! (See below)"
msgstr "正常EEPROM区域的前256个字节（总线：I2C-2 地址：0x50）是保留的，不应被覆盖！ （见下文）"

msgid "PHYTEC uses first 256 bytes in EEPROM normal area to store information about the SoM. This includes PCB revision and mounting options."
msgstr "PHYTEC在EEPROM正常区域的前256字节中存储有关核心板的信息。这包括PCB版本和贴装选项。"

msgid "If the first 256 bytes of the normal area are deleted, the bootloader will fall back to the |som| Kit RAM setup, which is |kit-ram-size| RAM."
msgstr "如果正常区域的前256个字节被删除，启动加载程序将回退到 |som| 开发板内存配置，即 |kit-ram-size| RAM。"

msgid "Data in the first 256 bytes of the normal EEPROM area (bus: I2C-2 addr: 0x50) shouldn't be erased or corrupted! This might influence the behavior of the bootloader. The board might not boot correctly anymore."
msgstr "正常EEPROM区域的前256个字节（总线：I2C-2 地址：0x50）不应被擦除或损坏！这可能会影响bootloader的行为。板子可能无法正确启动。"

msgid "The hardware introspection data is pre-written on the EEPROM data spaces. If you have accidentally deleted or overwritten the HW data, you could contact our support!"
msgstr "硬件自检数据已预先写入EEPROM数据空间。如果您不小心删除或覆盖了数据，请联系我们的支持团队！"

#, fuzzy
msgid "DT representation, e.g. in |som| file can be found in our PHYTEC git: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L172`"
msgstr "核心板 phyCORE-|soc| 的设备树可以在PHYTEC git中找到： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L172`"

#, fuzzy
msgid "DT representation for I²C RTCs: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L177` or :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L126`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L173` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L122`\""

msgid "The USB controller of the |soc| SoC provides a low-cost connectivity solution for numerous consumer portable devices by providing a mechanism for data transfer between USB devices with a line/bus speed of up to 480 Mbps (HighSpeed 'HS'). The USB subsystem has two independent USB controller cores. Both cores are capable of acting as a USB peripheral device or a USB host, but on the |sbc| one of them is used as a host-only port (USB-A connector)."
msgstr "|soc| SoC 的 USB 控制器为众多消费类便携设备提供了一种低成本的连接解决方案，传输速度高达 480 Mbps （高速 'HS'）。USB 子系统具有两个独立的 USB 控制器。两个控制器都能够充当 USB Device或 USB Host，但在 |sbc| 上，其中一个被用作仅Host端口（USB-A 连接器）。"

msgid "The OTG port provides an additional pin for over-current protection, which is not used on the |sbc|. Since it's not used, the driver part is also disabled from within the device tree. In case this pin is used, activate this over-current in the device tree and set the correct polarity (active high/low) according to the device specification. For the correct setup, please refer to the Kernel documentation under Linux/Documentation/devicetree/bindings/usb/ci-hdrc-usb2.txt."
msgstr "OTG端口提供了一个额外的引脚用于过流保护，但在 |sbc| 上并未使用。由于未使用，该引脚在设备树中也被禁用。如果需要使用该引脚，请在设备树中激活过流保护，并根据设备规格设置正确的极性（高电平/低电平）。有关正确的设置，请参考Linux内核文档中的Linux/Documentation/devicetree/bindings/usb/ci-hdrc-usb2.txt。"

#, fuzzy
msgid "DT representation for USB Host: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L196` or :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L185`"
msgstr "USB Host的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L193` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L181`"

msgid "The |sbc-nash| i.MX 93 SoC provides one RS232/RS485 serial port."
msgstr "|sbc-nash| i.MX 93 SoC 提供一个 RS232/RS485 串口。"

msgid "RS232 with HW flow control and RS485 are not working due to HW bug on the |sbc-nash| PCB revision 1616.0"
msgstr "由于 |sbc-nash| PCB版本1616.0上的硬件缺陷，RS232的硬件流控制和RS485无法正常工作"

#, fuzzy
msgid "The device tree representation for RS232 and RS485: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L178`"
msgstr "RS232和RS485的设备树： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L174`"

msgid "The |sbc| has one flexCAN interface supporting CAN FD. They are supported by the Linux standard CAN framework which builds upon the Linux network layer. Using this framework, the CAN interfaces behave like an ordinary Linux network device, with some additional features special to CAN. More information can be found in the Linux Kernel documentation: https://www.kernel.org/doc/html/latest/networking/can.html"
msgstr "|sbc| 具有一个支持CAN FD的flexCAN接口。它们由Linux标准CAN框架支持，该框架建立在Linux网络层之上。使用该框架，CAN接口表现得像普通的Linux网络设备，并具有一些特定于CAN的附加功能。更多信息可以在Linux内核文档中找到：https://www.kernel.org/doc/html/latest/networking/can.html"

msgid "to see the state of the interfaces. The CAN interface should show up as can0."
msgstr "查看接口的状态。CAN接口应该显示为can0。"

#, fuzzy
msgid "The CAN configuration is done in the systemd configuration file ``/lib/systemd/network/11-can.network``. For a persistent change of (as an example, the default bitrates), change the configuration in the BSP under ``./meta-ampliphy/recipes-core/systemd/systemd-conf/11-can.network`` in the root filesystem and rebuild the root filesystem."
msgstr "CAN配置是在systemd配置文件 ``/lib/systemd/network/can0.network`` 中完成的。为了持久化更改（例如，默认比特率），请在BSP中更改根文件系统下的 ``./meta-ampliphy/recipes-core/systemd/systemd-conf/can0.network`` 中的配置，并重新编译根文件系统。"

msgid "By default, we enable CAN-FD (flexible datarate) in our BSP. In case CAN Classic is required one needs to remove options ``FDMode`` and ``DataBitRate`` from the ``/lib/systemd/network/11-can.network`` file."
msgstr ""

msgid "To disable flexible datarate manually, one can use:"
msgstr ""

#, fuzzy
msgid "The bitrate can also be changed manually, for example:"
msgstr "比特率也可以手动更改，例如，设置为灵活比特率（flexible bitrate）："

#, fuzzy
msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L151` or :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L109`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L147` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L105`"

msgid "Audio on |sbc-segin|"
msgstr "|sbc-segin| 上的音频"

msgid "On |sbc-segin| the TI TLV320AIC3007 audio codec is used. It uses I2S for data transmission and I2C for codec control. The audio signals available are:"
msgstr "在 |sbc-segin| 上使用了 TI TLV320AIC3007 音频编解码器（CODEC）。它使用 I2S 进行数据传输，使用 I2C 进行控制。可用的音频信号有："

msgid "Stereo LINE IN,"
msgstr "立体声 LINE IN，"

msgid "Stereo LINE OUT,"
msgstr "立体声 LINE OUT，"

msgid "Output where D-Class 1W speaker can be connected"
msgstr "Class D 1W的扬声器输出"

msgid "If Speaker volume it too low you can increase its volume with (values 0-3):"
msgstr "如果扬声器音量太低，可以增加音量（值范围 0-3）："

msgid "Speaker output is only mono so when stereo track is played only left channel will be played by speaker."
msgstr "扬声器输出仅为单声道，因此当播放立体声轨道时，扬声器只会播放左声道。"

msgid "``arecord`` is a command-line tool for capturing audio streams which use Line In as the default input source."
msgstr "``arecord`` 是一个命令行工具，用于捕获音频流，默认输入源为线路输入（Line In）。"

#, fuzzy
msgid "Device Tree Audio configuration: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L62`"
msgstr "|dt-carrierboard|.dts 的设备树 音频 配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L62`"

msgid "Audio on |sbc-nash|"
msgstr "|sbc-nash| 上的音频"

msgid "Due to HW bug Audio is broken on |sbc-nash| PCB revision: 1616.0"
msgstr "由于硬件缺陷，|sbc-nash| PCB 版本：1616.0上的音频功能不可用"

msgid "To use audio with |sbc-nash| an additional adapter for the Audio/Video connector is needed. The PEB-AV-10 (1531.1 revision) can be bought separately to the Kit. PEB-AV-10 is populated with a TI TLV320AIC3007 audio codec. Audio support is done via the I2S interface and controlled via I2C."
msgstr "要在 |sbc-nash| 上使用音频，需要在Audio/Video接口连接一个扩展板。PEB-AV-10（1531.1修订版）可以单独购买，并未随套件一起提供。PEB-AV-10配备了TI TLV320AIC3007音频编解码器（CODEC）。音频支持通过I2S接口实现，并通过I2C控制。"

#, fuzzy
msgid "Device Tree Audio configuration: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso#L56`"
msgstr "音频的设备树配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso#L56`"

#, fuzzy
msgid "The **phyBOARD-Segin** i.MX 93 supports PEB-AV-02 with 7'' ``edt,etm0700g0edh6`` parallel display with capacitive touchscreen. Device-tree overlay for the aforementioned display is enabled in ``/boot/bootenv.txt`` by default!"
msgstr "**phyBOARD-Segin** i.MX 93 支持 PEB-AV-02，配备 7 英寸的 ``edt,etm0700g0edh6`` 并口显示屏和电容触摸屏。该显示屏的设备树overlay在 ``BOOT/bootenv.txt`` 中默认启用！"

#, fuzzy
msgid "The **phyBOARD-Nash** i.MX 93 needs additional adapter to support 10'' ``edt,etml1010g3dra`` LVDS display with capacitive touchscreen. The PEB-AV-10 (1531.1 revision) can be bought separately to the Kit. Device-tree overlay for the aforementioned adapter is enabled in ``/boot/bootenv.txt`` by default!"
msgstr "**phyBOARD-Nash** i.MX 93需要额外的扩展板来支持10英寸的 ``edt,etml1010g3dra`` LVDS显示器和电容触摸。PEB-AV-10（1531.1修订版）可以单独购买。该LCD的overlay在 ``BOOT/bootenv.txt`` 中默认启用！"

#, fuzzy
msgid "The device tree of PEB-AV-02 can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-av-02.dtso`"
msgstr "PEB-AV-02的设备树配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-av-02.dtso`"

#, fuzzy
msgid "The device tree of PEB-AV-10 can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso`"
msgstr "PEB-AV-10的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso`"

msgid "The CPU in the |soc| SoC is able to scale the clock frequency and the voltage. This is used to save power when the full performance of the CPU is not needed. Unlike i.MX8 M family the i.MX 93 doesn't support *Dynamic* Voltage and Frequency Scaling (DVFS), but has the support of basic **Voltage and Frequency Scaling (VFS)**. The board can be put into these modes:"
msgstr "|soc| SoC中的CPU能够调整时钟频率和电压。这用于在不需要CPU的全部性能时节省电力。与i.MX8 M系列不同，i.MX 93不支持 *动态* 电压和频率调整（DVFS），但支持简化的 **电压和频率调整（VFS）** 。可以进入以下模式："

msgid "nominal (ND),"
msgstr "nominal（ND），"

msgid "overdrive (OD),"
msgstr "overdrive （OD），"

msgid "Low Drive (LD) and"
msgstr "Low Drive（LD）和"

msgid "Low Drive (LD) with Software Fast Frequency Change (SWFFC)."
msgstr "Low Drive（LD）与软件快速频率变化（SWFFC）。"

msgid "Mode"
msgstr "模式"

msgid "CPU freq"
msgstr "CPU频率"

msgid "DDR data rate"
msgstr "DDR数据速率"

msgid "VDD_SOC"
msgstr "VDD_SOC"

msgid "OverDrive (OD)"
msgstr "OverDrive (OD)"

msgid "1.7 GHz"
msgstr "1.7 GHz"

msgid "3733 MT/s"
msgstr "3733 MT/s"

msgid "900mV"
msgstr "900mV"

msgid "NominalDrive (ND)"
msgstr "NominalDrive (ND)"

msgid "1.4 GHz"
msgstr "1.4 GHz"

msgid "1866 MT/s"
msgstr "1866 MT/s"

msgid "850mV"
msgstr "850mV"

msgid "LowDrive (LD)"
msgstr "LowDrive (LD)"

msgid "900 MHz"
msgstr "900 MHz"

msgid "800mV"
msgstr "800mV"

msgid "LowDrive (LD) with SWFFC"
msgstr "带有SWFFC的LowDrive（LD）"

msgid "625 MT/s"
msgstr "625 MT/s"

msgid "The |soc| BSP supports the VFS feature. The Linux kernel provides a LPM driver that allows setting VDD_SOC, CPU freq and DDR speed."
msgstr "|soc| BSP支持VFS功能。Linux内核提供了一个LPM驱动程序，可以设置VDD_SOC、CPU频率和DDR速度。"

msgid "Low-cost |soc| SoC variants such as parts numbers NXP IMX9301/IMX9302 do not support VFS features. Those SoCs always run in LowDrive (LD) mode. Hence, the Linux LPM driver is disabled automatically for SoMs with such SoCs."
msgstr "低成本的 |soc| SoC比如NXP IMX9301/IMX9302这些型号不支持VFS功能。这些SoC会固定运行在 LowDrive（LD）模式。因此在使用这些SoC的核心板时，Linux的LPM驱动会自动禁用。"

msgid "To put the device in **OverDrive (OD)** mode type:"
msgstr "要将设备置于 **OverDrive（OD）** 模式，请输入："

msgid "To put the device in **NominalDrive (ND)** mode type:"
msgstr "要将设备置于 **NominalDrive（ND）** 模式，请输入："

msgid "To put the device in **LowDrive (LD)** mode type:"
msgstr "要将设备置于 **LowDrive（LD）** 模式，请输入："

msgid "To put the device in **LowDrive (LD)** mode with the lowest DDR speed with SWFFC type:"
msgstr "将设备置于 **LowDrive（LD）** 模式，使用最低DDR速度，SWFFC类型："

msgid "To check the current CPU frequency type:"
msgstr "要检查当前的CPU频率，请输入："

msgid "To check the current mode and DDR frequency type:"
msgstr "要检查当前模式和DDR频率，请输入："

msgid "To check the current VDD_SOC type:"
msgstr "要检查当前的 VDD_SOC 类型，请输入："

msgid "For more detailed information about the LPM driver and modes, refer to the NXPs documentation: https://docs.nxp.com/bundle/AN13917/page/topics/low_power_mode_use_cases.html"
msgstr "有关LPM驱动程序和模式的更详细信息，请参考NXP的文档：https://docs.nxp.com/bundle/AN13917/page/topics/low_power_mode_use_cases.html"

msgid "The |soc| SoC can have multiple processor cores on the die. The |soc|, for example, has 2 ARM Cores which can be turned on and off individually at runtime."
msgstr "|soc| SoC 在芯片上拥有多个处理器核心。例如，|soc| 具有 2 个 ARM 核，这些核可以在运行时单独开启和关闭。"

msgid "Here the system has two processor cores. By default, all available cores in the system are enabled to get maximum performance."
msgstr "这里系统有两个处理器核心。默认情况下，系统中所有可用的核心都被启用，以获得最佳性能。"

msgid "Device can be put into suspend and waken-up with PEB-EVAL-01 S2 button"
msgstr "设备可以通过PEB-EVAL-01的S2按钮进入休眠状态并唤醒"

msgid "To wake up with RTC alarm check: `RTC Wakealarm`_"
msgstr "要通过RTC闹钟唤醒，请检查：`RTC Wakealarm`_"

msgid "There are two trip points registered by the imx_thermal kernel driver. These differ depending on the CPU variant. A distinction is made between Commercial, Industrial and Extended Industrial."
msgstr "imx_thermal内核驱动注册了两个温度阈值。这些阈值根据CPU型号的不同而有所区别。包括商业级、工业级和扩展工业级。"

msgid "Extended Industrial"
msgstr "扩展工业级"

msgid "115°C"
msgstr "115°C"

msgid "120°C"
msgstr "120°C"

msgid "The kernel thermal management uses these trip points to trigger events and change the cooling behavior. The following thermal policies (also named thermal governors) are available in the kernel: Step Wise and Power Allocator. The default policy used in the BSP is step_wise."
msgstr "内核热管理使用这些触发点来触发事件并改变温控行为。内核中可用的热政策（也称为thermal governor）包括：Step Wise和Power Allocator。BSP中使用的默认政策是step_wise。"

msgid "If the value of the SoC temperature in the sysfs file temp reaches *trip_point_1*, the board immediately shuts down to avoid any heat damage. If this doesn't meet you expectations, an external supervisor circuit that starts the module again with X_ONOFF signal when the temperature drops below a selected trip point can be implemented"
msgstr "如果sysfs文件中的SoC温度值达到 *trip_point_1* ，主板将立即关闭以避免任何热损伤。如果这不符合您的期望，可以实现一个外部监控电路，当温度降到选定的触发点以下时，通过X_ONOFF信号重新启动模块"

msgid "PWM Fan"
msgstr "PWM风扇"

msgid "A PWM fan can be connected to the phyBOARD-Nash i.MX 93 connector X48 (label FAN)."
msgstr "可以在phyBOARD-Nash i.MX 93的连接器X48 (标注 FAN)连接一个PWM风扇。"

msgid "Afterwards, a PWM fan overlay needs to be activated, otherwise PWM fan won't be recognized."
msgstr "从本版本开始，需要先激活PWM风扇Overlay，否则PWM风扇将无法被识别。"

msgid "The bootenv.txt file should look like this (it can also contain other devicetree overlays!):"
msgstr "bootenv.txt 文件应该如下所示（它还可以包含其他设备树overlay！）："

msgid "The SoC only contains one temperature sensor which is already used by the thermal frequency scaling. The fan thus can not be controlled by the kernel. We use lmsensors with hwmon for this instead. lmsensors reads the temperature periodically and adjusts output PWM duty-cycle accordingly. By default, temperature threshold for PWM fan to activate is set to 60°C."
msgstr "该SoC只包含一个温度传感器，而该传感器被用于热频率调节，因此风扇无法通过内核进行控制。我们使用lmsensors和hwmon来代替。lmsensors定期读取温度，并在可配置的阈值下配置风扇PWM的输出。默认启动PWM风扇的温度阈值是60°C。"

msgid "bbnsm Power Key"
msgstr "bbnsm 电源键"

msgid "The X_ONOFF pin connected to the ON/OFF button can be pressed long (for 5 seconds) to trigger Power OFF without SW intervention or used to wake up the system out of suspend. With the *bbnsm_pwrkey* driver, the KEY_POWER event is also reported to userspace when the button is pressed. On default, systemd is configured to ignore such events. The function of Power OFF without SW intervention are not configured. Triggering a power off with systemd when pushing the ON/OFF button can be configured under ``/etc/systemd/logind.conf`` and set using:"
msgstr "连接到开/关按钮的 X_ONOFF 引脚可以长按（5 秒）以触发关机，而无需软件干预，或者用于唤醒系统以退出挂起状态。使用 *bbnsm_pwrkey* 驱动程序时，当按钮被按下时，KEY_POWER 事件也会报告给用户空间。默认情况下，systemd 被配置为忽略此类事件，并未配置无软件干预的关机功能。如果需要，可以在 ``/etc/systemd/logind.conf`` 中配置在按下开/关按钮时通过 systemd 触发关机："

msgid "PXP"
msgstr "PXP"

msgid "The |soc| SoC contains an PiXel Pipeline (PXP). The PXP combines the following into a single processing engine:"
msgstr "|soc| SoC包含一个PiXel Pipeline (PXP)。PXP将以下内容组合成一个单独的处理引擎："

msgid "Scaling"
msgstr "缩放"

msgid "Color Space Conversion (CSC)"
msgstr "颜色空间转换 (CSC)"

msgid "Secondary Color Space Conversion (CSC2)"
msgstr "辅助色彩空间转换 (CSC2)"

msgid "Rotation"
msgstr "旋转"

msgid "and thus minimizes the memory footprint required for the display pipeline. How to use the PXP with Gstreamer and Wayland check the `How to Use PXP in GStreamer and Wayland` (AN13829) Application note from NXP."
msgstr "因此，减少了显示管道所需的内存占用。有关如何在 Gstreamer 和 Wayland 中使用 PXP，请查看 NXP 的《How to Use PXP in GStreamer and Wayland》（AN13829）应用笔记。"

msgid "The |soc| provides one-time programmable fuses to store information such as the MAC address, boot configuration, and other permanent settings (\"On-Chip OTP Controller (OCOTP_CTRL)\" in the |soc| Reference Manual). The following list is an abstract from the |soc| Reference Manual and includes some useful registers in the OCOTP_CTRL (at base address 0x47510000):"
msgstr "该 |soc| 提供一次性可编程寄存器（fuse），用于存储信息，例如MAC地址、启动配置和其他永久设置（在 |soc| reference manual中称为“片上一次性可编程控制器（OCOTP_CTRL）”）。以下列表是 |soc| reference manual的摘要，包括OCOTP_CTRL中的一些有用寄存器（基地址为0x47510000）："

msgid "Memory offset at 0x47510000"
msgstr "内存偏移量为 0x47510000"

msgid "BOOT_CFG0"
msgstr "BOOT_CFG0"

msgid "3"
msgstr "3"

msgid "0    0x60"
msgstr "0    0x60"

msgid "boot fuse settings"
msgstr "启动fuse设置"

msgid "BOOT_CFG1"
msgstr "BOOT_CFG1"

msgid "1    0x64"
msgstr "1    0x64"

msgid "BOOT_CFG2"
msgstr "BOOT_CFG2"

msgid "2    0x68"
msgstr "2    0x68"

msgid "BOOT_CFG3"
msgstr "BOOT_CFG3"

msgid "3    0x6c"
msgstr "3    0x6c"

msgid "MAC1_ADDR"
msgstr "MAC1_ADDR"

msgid "39"
msgstr "39"

msgid "0x4ec"
msgstr "0x4ec"

msgid "MAC1/2_ADDR"
msgstr "MAC1/2_ADDR"

msgid "4"
msgstr "4"

msgid "0x4f0"
msgstr "0x4f0"

msgid "MAC2_ADDR"
msgstr "MAC2_ADDR"

msgid "5"
msgstr "5"

msgid "0x4f4"
msgstr "0x4f4"

msgid "MAC1_ADDR:"
msgstr "MAC1_ADDR:"

msgid "Burning MAC addresses"
msgstr "烧录MAC地址"

msgid "Let's say we want to burn the following MAC addresses:"
msgstr "假设我们想要烧录以下MAC地址："

msgid "MAC1"
msgstr "MAC1"

msgid "12:34:56:78:90:Aa"
msgstr "12:34:56:78:90:AA"

msgid "MAC2"
msgstr "MAC2"

msgid "Bb:Cc:Dd:Ee:Ff:D0"
msgstr "Bb:Cc:Dd:Ee:Ff:D0"

msgid "We would execute this in u-boot:"
msgstr "我们将在u-boot中执行这个："

msgid "Burning Boot Fuses"
msgstr "烧写启动fuse"

msgid "Fuses can only be written once! You can brick your board easily by burning the wrong boot configuration. It cannot be reversed!"
msgstr "fuse只能写入一次！如果烧录了错误的启动配置，您可能会轻易地将您的板子变砖。这个过程是不可逆的！"

msgid "Which fuse bank/word should be used to program the BOOT_CFGX can be checked in *i.MX 93 Applications Processor Reference Manual* attached spreadsheet named **i.MX93_Fusemap.xlsx**."
msgstr "可以在附带的名为 **i.MX93_Fusemap.xlsx** 的excel表格中查找应使用哪个fuse bank/word来编程 BOOT_CFGX，这些信息可以在 *i.MX 93 Applications Processor Reference Manual* 中找到。"

msgid "These values should be written to the BOOT_CFG0, which can be read/written from fuses on Bank 3, Word 0."
msgstr "这些值应该写入BOOT_CFG0，可以从第3个 Bank 的第0字节中读取/写入fuse。"

msgid "Boot Device"
msgstr "启动设备"

msgid "0x20020002"
msgstr "0x20020002"

msgid "0x20000103"
msgstr "0x20000103"

msgid "To set internal fuses to boot from eMMC one can program them with:"
msgstr "要设置内部fuse以从eMMC启动，可以使用以下方法进行编程："

msgid "In this example we:"
msgstr "在这个例子中，我们："

msgid "set the Boot_Mode to 0b0010 (eMMC) with BOOT_CFG0[3:0],"
msgstr "将 Boot_Mode 设置为 0b0010 （eMMC），也就是 BOOT_CFG0[3:0]，"

msgid "set the eMMC Bus width to 0b01 (8 bit) with BOOT_CFG0[18:17]"
msgstr "将eMMC总线宽度设置为0b01（8位），也就是 BOOT_CFG0[18:17]。"

msgid "set the BT_FUSE_SEL (Boot fuses already programmed) bit with BOOT_CFG0[29]"
msgstr "设置BT_FUSE_SEL（Boot fuses already programmed）位，也就是BOOT_CFG0[29]"

msgid "Make sure you set the right bits by reading the **Boot Fusemap** chapter in *i.MX 93 Applications Processor Reference Manual*."
msgstr "确保通过阅读 *i.MX 93 Applications Processor Reference Manual* 中的 **Boot Fusemap** 章节来设置正确的位。"

msgid "TPM"
msgstr "TPM"

msgid "The **phyBOARD-Nash** i.MX 93 is equipped with a Trusted Platform Module (TPM) that provides hardware-based security functions."
msgstr "**phyBOARD-Nash** i.MX 93配备了可信任的平台模块（TPM），提供基于硬件的安全功能。"

msgid "Here are some useful examples to work with the TPM"
msgstr "以下是一些与TPM相关的示例"

msgid "Generate 4-byte random value with TPM2 tools:"
msgstr "使用TPM2工具生成4字节随机值："

msgid "Generate 4-byte random value with OpenSSL tools:"
msgstr "使用OpenSSL工具生成4字节随机值："

msgid "Generate RSA private key and validate its contents:"
msgstr "生成RSA私钥并验证其内容："

msgid "Do NOT share your private RSA keys if you are going to use these keys for any security purposes."
msgstr "如果您打算将这些密钥用于任何安全目的，请不要共享您的私有RSA密钥。"

msgid "Generate RSA public key and validate its contents:"
msgstr "生成RSA公钥并验证其内容："

#, fuzzy
msgid "Device tree TPM configuration can be found here: :linux-phytec-imx:`blob/v6.6.52-2.2.0-phy9/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L161`"
msgstr "TPM的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L151`"

msgid "In addition to the Cortex-A55 cores, there is a Cortex-|mcore| as MCU integrated into the |soc| SoC. Our Yocto-Linux-BSP runs on the A55-Cores and the |mcore| can be used as a secondary core for additional tasks using bare-metal firmware. Both cores have access to the same peripherals and thus peripheral usage needs to be limited either in the |mcore|'s firmware or the devicetree for the Linux operating system."
msgstr "除了Cortex-A55核心外，SoC中还集成了一个Cortex-|mcore| 作为单片机（MCU）。我们的Yocto-Linux-BSP在A55核心上运行，而 |mcore| 可以作为辅助核心使用，执行额外的任务，采用bare-metal的固件。两个核心都可以访问相同的外设，因此在 |mcore| 的固件或Linux操作系统的设备树中，需要限制外设的使用。"

msgid "Our Yocto-BSP contains pre-built firmware examples for |mcore| from NXP."
msgstr "我们的Yocto-BSP包含来自NXP的 |mcore| 预编译固件示例。"

msgid "This section describes how to run pre-built |mcore| firmware examples on |sbc|."
msgstr "本节描述了如何在 |sbc| 上运行预编译的 |mcore| 固件示例。"

msgid "There are two ways to run the |mcore| firmware examples, from U-Boot bootloader and from Remoteproc subsystem within a running Linux."
msgstr "运行 |mcore| 固件示例有两种方式：从 U-Boot bootloader和在正在运行的 Linux 中使用 Remoteproc 子系统。"

msgid "On |sbc| an external \"USB TTL to serial adapter\" is required. Adapter's I/O pins should be able to operate at 3.3V voltage levels."
msgstr "在 |sbc| 上需要一个“USB接口 TTL 串口转换器”。转换器的 I/O 引脚应能够在 3.3V 电压水平下工作。"

msgid "Connect external \"USB TTL to serial adapter\" signals to the |ref-m-core-connections| connector on the board according to the following table:"
msgstr "根据下表，将外部“USB接口 TTL 串口转换器”信号连接到板上的 |ref-m-core-connections| 连接器："

msgid "USB-TTL adapter pins"
msgstr "USB-TTL适配器引脚"

msgid "X16 signal"
msgstr "X16信号"

msgid "RXD"
msgstr "RXD"

msgid "X_UART2_TX"
msgstr "X_UART2_TX"

msgid "TXD"
msgstr "TXD"

msgid "X_UART2_RX"
msgstr "X_UART2_RX"

msgid "8"
msgstr "8"

msgid "GND"
msgstr "GND"

msgid "To load firmware examples using the U-Boot bootloader, the ``bootaux`` command can be used:"
msgstr "要使用U-Boot bootloader加载固件示例，可以使用 ``bootaux`` 命令："

msgid "List available |mcore| firmware examples on the first partition of SD Card:"
msgstr "列出SD卡第一分区上可用的 |mcore| 固件示例："

msgid "Available firmware examples start with ``imx93-11x11-evk_m33_TCM_*`` and end with ``*.bin``. Examples come from NXP's Yocto layer meta-imx and are selected based on compatibility with |sbc| hardware."
msgstr "可用的固件示例以 ``imx93-11x11-evk_m33_TCM_*`` 开头，以 ``*.bin`` 结尾。这些示例来自NXP的Yocto层meta-imx，并根据与 |sbc| 硬件的兼容性进行选择。"

msgid "Load desired firmware example:"
msgstr "加载所需的固件示例："

msgid "Remoteproc is a module that allows you to control the |mcore| from Linux during runtime. Firmware examples for |mcore| can be loaded and the execution started or stopped within Linux. To use Remoteproc a devicetree overlay needs to be set:"
msgstr "Remoteproc是一个模块，它允许您在运行时从Linux控制 |mcore| 。可以加载 |mcore| 的固件示例，并在Linux中控制它启动或停止。要使用Remoteproc，需要设置设备树overlay："

msgid "Edit the ``bootenv.txt`` file located in the ``/boot`` directory on the target by adding |dtbo-rpmsg|:"
msgstr "在开发板的 ``/boot`` 目录中编辑 ``bootenv.txt`` 文件，添加 |dtbo-rpmsg| ："

msgid "Firmware examples ``*.elf`` files for the |mcore| can be found under ``/lib/firmware``. List available firmware examples:"
msgstr "针对 |mcore| 的固件示例 ``*.elf`` 文件可以在 ``/lib/firmware`` 下找到。列出可用的固件示例："

msgid "To load the firmware, type:"
msgstr "要加载固件，请输入："

msgid "The samples found in ``/lib/firmware`` on the target come from NXP's Yocto layer meta-imx and are selected based on compatibility with |sbc| hardware."
msgstr "在开发板的 ``/lib/firmware`` 目录中找到的例子来自NXP的Yocto层meta-imx，并根据与 |sbc| 硬件的兼容性进行了挑选。"

msgid "Some firmware examples from NXP require additional Linux kernel modules to be loaded."
msgstr "NXP的一些固件示例需要加载额外的Linux内核模块。"

msgid "For example, when loading ``imx93-11x11-evk_m33_TCM_rpmsg_lite_str_echo_rtos.elf`` firmware, one requires corresponding ``imx_rpmsg_tty`` module to be loaded:"
msgstr "例如，当加载 ``imx93-11x11-evk_m33_TCM_rpmsg_lite_str_echo_rtos.elf`` 固件时，需要加载相应的 ``imx_rpmsg_tty`` 模块："

msgid "This exposes an RPMsg endpoint as a virtual TTY at ``/dev/ttyRPMSG30``. Now it is possible to send messages from A55 Core to |mcore| by typing:"
msgstr "这将一个RPMsg端点作为虚拟TTY暴露在 ``/dev/ttyRPMSG30`` 。现在可以通过输入以下内容从A55核心发送消息到 |mcore| ："

msgid "Observing |mcore| debug UART should result in the following output:"
msgstr "观察 |mcore| 调试 UART 应该会产生以下输出："

#, fuzzy
msgid "BSP-Yocto-NXP-i.MX93-PD24.2.1"
msgstr "BSP-Yocto-NXP-i.MX93-PD24.2.0"

msgid "BSP-Yocto-NXP-i.MX93-PD24.2.0"
msgstr "BSP-Yocto-NXP-i.MX93-PD24.2.0"

msgid "BSP-Yocto-NXP-i.MX93-PD24.1.1"
msgstr "BSP-Yocto-NXP-i.MX93-PD24.1.1"

msgid "BSP-Yocto-NXP-i.MX93-PD24.1.0"
msgstr "BSP-Yocto-NXP-i.MX93-PD24.1.0"

msgid "Mickledore"
msgstr "Mickledore"

msgid "2024/01/31"
msgstr "2024/01/31"

msgid "Connect the target (|ref-debugusbconnector|) and the host with **serial cable**"
msgstr "使用**RS232串口线**将开发板（|ref-debugusbconnector|）和主机连接起来"

msgid "Open serial port with 115200 baud and 8N1 (you should see u-boot/linux start on the console"
msgstr "以115200波特率和8N1格式打开串口终端（您可以在终端上看到u-boot/linux启动信息）"

msgid "**imx93-phyboard-segin.dtb**: Kernel device tree file"
msgstr "**imx93-phyboard-segin.dtb**: 内核设备树文件"

msgid "**phytec-qt6demo-image-phyboard-segin-imx93-2.tar.gz**: when bitbake-build was processed for ``phytec-qt6demo-image``"
msgstr "**phytec-qt6demo-image-phyboard-segin-imx93-2.tar.gz**：当bitbake-build的编译目标是``phytec-qt6demo-image``时"

msgid "**phytec-headless-image-phyboard-segin-imx93-2.tar.gz**: when bitbake-build was processed for ``phytec-headless-image``"
msgstr "**phytec-headless-image-phyboard-segin-imx93-2.tar.gz**：当bibake-build的编译目标是``phytec-headless-image``时"

msgid "**phytec-\\*.wic.xz**: Compressed bootable SD card image of bitbake-image that was built. Includes bootloader, DTBs, Kernel and Root file system."
msgstr "**phytec-\\*.wic.xz**：bitbake-image编译生成的压缩的可引导SD卡镜像，包括bootloader、设备树二进制文件（DTB）、内核和根文件系统。"

msgid "**phytec-qt6demo-image-phyboard-segin-imx93-2.wic.xz**: when bitbake-build was processed for ``phytec-qt6demo-image``"
msgstr "**phytec-qt6demo-image-phyboard-segin-imx93-2.wic.xz**：当bitbake-build的编译目标是``phytec-qt6demo-image``时"

msgid "**phytec-headless-image-phyboard-segin-imx93-2.wic.xz**: when bitbake-build was processed for ``phytec-headless-image``"
msgstr "**phytec-headless-image-phyboard-segin-imx93-2.wic.xz**：当bibake-build的编译目标是``phytec-headless-image``时"

msgid "Hardware revision baseboard: 1472.5"
msgstr "底板硬件版本：1472.5"

msgid "The device tree representation for UART1 pinmuxing: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n267`"
msgstr "UART1引脚复用的设备树：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n267`"

msgid "|sbc|-|soc| provides two ethernet interfaces. A 100 megabit Ethernet is provided by our module and board."
msgstr "|sbc|-|soc| 提供两个以太网接口。我们的核心板和底板各提供一个百兆以太网。"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n216`"
msgstr "MMC（SD卡插槽）接口的设备树：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n216`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n195`"
msgstr "eMMC接口的DT配置：:imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n195`"

msgid "0x43810080"
msgstr "0x43810080"

msgid "0x43820080"
msgstr "0x43820080"

msgid "0x43830080"
msgstr "0x43830080"

msgid "0x47400080"
msgstr "0x47400080"

msgid "Set the value of GPIO 3 on chip0 to 0 and exit tool:"
msgstr "将chip0上的GPIO 3的值设置为0并退出："

msgid "You can also add this option for example to the imx9_phytec_distro.config config fragment in the linux kernel sources under arch/arm64/configs ::"
msgstr "您还可以将此选项添加到Linux内核源代码中arch/arm64/configs下的imx9_phytec_distro.config配置片段中，例如："

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx93-phyboard-segin-peb-eval-01.dtso?h=v6.1.36_2.1.0-phy1#n33`"
msgstr "GPIO配置的设备树配置：:imx-dt:`imx93-phyboard-segin-peb-eval-01.dtso?h=v6.1.36_2.1.0-phy1#n33`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n88`"
msgstr "I²C1总线DT配置（例如 |dt-som|.dtsi）： :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n88`"

msgid "General I²C2 bus configuration (e.g. |dt-carrierboard|.dts) :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n155`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）: imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n155`"

#, fuzzy
msgid "DT representation, e.g. in |som| file can be found in our PHYTEC git: :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n173`"
msgstr "phyCORE-|soc| 核心板的设备树可以在我们的PHYTEC Git中找到：:imx-dt:`imx93-phycore-som.dtsi?h=v6.1.36_2.1.0-phy1#n173`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n173`"
msgstr "I²C RTC的DT表示： :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n173`"

msgid "DT representation for USB Host: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n190`"
msgstr "USB主机的DT：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n190`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n147`"
msgstr "|dt-carrierboard|.dts的设备树CAN配置: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n147`"

msgid "On |sbc| the TI TLV320AIC3007 audio codec is used. It uses I2S for data transmission and I2C for codec control. The audio signals available are:"
msgstr "在 |sbc| 上使用了 TI TLV320AIC3007 音频编解码器（CODEC）。它使用 I2S 进行数据传输，使用 I2C 进行控制。可用的音频信号有："

msgid "Device Tree Audio configuration: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n62`"
msgstr "设备树音频配置：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.36_2.1.0-phy1#n62`"

msgid "The device tree of PEB-AV-02 can be found here: :imx-dt:`imx93-phyboard-segin-peb-av-02.dtso?h=v6.1.36_2.1.0-phy1`"
msgstr "PEB-AV-02的设备树可以在这里找到：:imx-dt:`imx93-phyboard-segin-peb-av-02.dtso?h=v6.1.36_2.1.0-phy1`"

msgid "2024/05/07"
msgstr "2024/05/07"

msgid "**phytec-qt6demo-image-phyboard-*-imx93-*.wic.xz**: when bitbake-build was processed for ``phytec-qt6demo-image``"
msgstr "**phytec-qt6demo-image-phyboard-*-imx93-*.wic.xz**：在使用bitbake-build编译 ``phytec-qt5demo-image`` 时"

msgid "**phytec-headless-image-phyboard-*-imx93-*.wic.xz**: when bitbake-build was processed for ``phytec-headless-image``"
msgstr "**phytec-headless-image-phyboard-*-imx93-*.wic.xz**：在使用bitbake-build编译 ``phytec-headless-image`` 时"

msgid "phyBOARD-Segin-i.MX 93: 1472.5"
msgstr "phyBOARD-Segin-i.MX 93: 1472.5"

msgid "phyBOARD-Nash-i.MX 93: 1616.0"
msgstr "phyBOARD-Nash-i.MX 93: 1616.0"

msgid "The device tree representation for UART1 pinmuxing: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n262`"
msgstr "UART1引脚复用的设备树：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n262`"

msgid "On **phyBOARD-Segin** we have:"
msgstr "在 **phyBOARD-Segin** 上，我们有："

msgid "On **phyBOARD-Nash** we have:"
msgstr "在 **phyBOARD-Nash** 上，我们有："

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n216` or here: :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n201`"
msgstr "MMC（SD卡插槽）接口的设备树配置可以在这里找到：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n216` 或者这里：:imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n201`"

msgid "DT configuration for the eMMC interface can be found here: :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n194` or here:"
msgstr "eMMC接口的DT配置可以在这里找到：:imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n194` 或者在这里："

msgid "On phyBOARD-Nash the ADC lines are accessible on X16 expansion connector:"
msgstr "在phyBOARD-Nash上，ADC线路可以通过X16扩展连接器访问："

msgid "Device tree configuration for the User I/O configuration can be found here: :imx-dt:`imx93-phyboard-segin-peb-eval-01.dtso?h=v6.1.55_2.2.0-phy3#n33`"
msgstr "GPIO的设备树：:imx-dt:`imx93-phyboard-segin-peb-eval-01.dtso?h=v6.1.55_2.2.0-phy3#n33`"

msgid "General I²C1 bus configuration (e.g. |dt-som|.dtsi): :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n88`"
msgstr "I²C1总线DT配置（例如 |dt-som|.dtsi）：:imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n88`"

msgid "General I²C2 bus configuration for |dt-carrierboard|.dts: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n155` or for imx93-phyboard-nash.dts: :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n113`"
msgstr "|dt-carrierboard|.dts的I²C2总线DT配置：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n155` 或者 imx93-phyboard-nash.dts: :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n113`"

#, fuzzy
msgid "DT representation, e.g. in |som| file can be found in our PHYTEC git: :imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n172`"
msgstr "phyCORE-|soc| 核心板的设备树文件可以在 PHYTEC git 中找到：:imx-dt:`imx93-phycore-som.dtsi?h=v6.1.55_2.2.0-phy3#n172`"

msgid "DT representation for I²C RTCs: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n173` or :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n122`"
msgstr "I²C RTC的设备树：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n173` 或 :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n122`"

msgid "DT representation for USB Host: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n190` or :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n180`"
msgstr "USB Host的DT：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n190` 或 :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n180`"

msgid "The **phyBOARD-Nash** i.MX 93 SoC provides one RS232/RS485 serial port."
msgstr "开发板 **phyBOARD-Nash** i.MX 93 SoC 提供一个 RS232/RS485 串口。"

msgid "RS232 with HW flow control and RS485 are not working due to HW bug on the phyBOARD-Nash PCB revision 1616.0"
msgstr "由于phyBOARD-Nash PCB版本1616.0上的硬件缺陷，RS232的硬件流控制和RS485无法正常工作"

msgid "The device tree representation for RS232 and RS485: :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n173`"
msgstr "RS232和RS485的设备树：:imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n173`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n147` or :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n105`"
msgstr "|dt-carrierboard|.dts 的CAN设备树： :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n147` 或 :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n105`"

msgid "Audio on phyBOARD-Segin"
msgstr "phyBOARD-Segin上的音频"

msgid "On phyBOARD-Segin i.MX 93 the TI TLV320AIC3007 audio codec is used. It uses I2S for data transmission and I2C for codec control. The audio signals available are:"
msgstr "在phyBOARD-Segin i.MX 93上使用的是TI TLV320AIC3007音频编解码器（CODEC）。它使用I2S进行数据传输，使用I2C进行编解码器控制。可用的音频信号包括："

msgid "Device Tree Audio configuration: :imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n62`"
msgstr "音频设备树配置：:imx-dt:`imx93-phyboard-segin.dts?h=v6.1.55_2.2.0-phy3#n62`"

msgid "Audio on phyBOARD-Nash"
msgstr "phyBOARD-Nash上的音频"

msgid "Due to HW bug Audio is broken on phyBOARD-Nash i.MX 93 PCB revision: 1616.0"
msgstr "由于硬件缺陷，phyBOARD-Nash i.MX 93 PCB 版本：1616.0上的音频功能不可用"

msgid "To use audio with phyBOARD-Nash an additional adapter for the Audio/Video connector is needed. The PEB-AV-10 (1531.1 revision) can be bought separately to the Kit. PEB-AV-10 is populated with a TI TLV320AIC3007 audio codec. Audio support is done via the I2S interface and controlled via I2C."
msgstr "要在phyBOARD-Nash上使用音频，需要在Audio/Video接口连接一个扩展板。PEB-AV-10（1531.1修订版）可以单独购买，并未随套件一起提供。PEB-AV-10配备了TI TLV320AIC3007音频编解码器（CODEC）。音频支持通过I2S接口实现，并通过I2C控制。"

msgid "Device Tree Audio configuration: :imx-dt:`imx93-phyboard-nash-peb-av-010.dtso?h=v6.1.55_2.2.0-phy3#n57`"
msgstr "设备树音频配置：:imx-dt:`imx93-phyboard-nash-peb-av-010.dtso?h=v6.1.55_2.2.0-phy3#n57`"

msgid "The device tree of PEB-AV-02 can be found here: :imx-dt:`imx93-phyboard-segin-peb-av-02.dtso?h=v6.1.55_2.2.0-phy3`"
msgstr "PEB-AV-02的设备树：:imx-dt:`imx93-phyboard-segin-peb-av-02.dtso?h=v6.1.55_2.2.0-phy3`"

msgid "The device tree of PEB-AV-10 can be found here: :imx-dt:`imx93-phyboard-nash-peb-av-010.dtso?h=v6.1.55_2.2.0-phy3`"
msgstr "PEB-AV-10的设备树：:imx-dt:`imx93-phyboard-nash-peb-av-010.dtso?h=v6.1.55_2.2.0-phy3`"

msgid "Device tree TPM configuration can be found here: :imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n151`"
msgstr "TPM的设备树配置：:imx-dt:`imx93-phyboard-nash.dts?h=v6.1.55_2.2.0-phy3#n151`"

msgid "2024/10/08"
msgstr "2024/10/08"

msgid "|sbc-nash|: 1616.0, 1616.1"
msgstr "|sbc-nash|: 1616.0, 1616.1"

msgid "The device tree representation for UART1 pinmuxing: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L259`"
msgstr "UART1引脚复用的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L259`"

msgid "For now, only |sbc-segin| supports WLAN/Bluetooth features. WLAN/Bluetooth is thus not supported on |sbc-nash| yet."
msgstr "现在只有 |sbc-segin| 支持WLAN/蓝牙功能。 |sbc-nash| 还不支持WLAN/蓝牙。"

msgid "WLAN and Bluetooth on the |sbc-segin| are provided by the PEB-WLBT-05 expansion card. The PEB-WLBT-05 for |sbc-segin| Quickstart Guide shows you how to install the PEB-WLBT-05."
msgstr "在 |sbc-segin| 上，WLAN和蓝牙由PEB-WLBT-05扩展板提供。PEB-WLBT-05的 |sbc-segin| 快速入门指南向您展示了如何安装PEB-WLBT-05。"

msgid "By default, bluetooth is not supported on |sbc-segin| with PEB-WLBT-05 expansion card due to hard-wired connections. However, it is possible to re-work PEB-WLBT-05 card by adjusting solder pads and enabling bluetooth in the software. Please contact your PHYTEC representative for more information."
msgstr "默认情况下，安装了PEB-WLBT-05扩展板的 |sbc-segin| 并不支持蓝牙。但是，可以通过修改PEB-WLBT-05扩展版同时在软件中使能蓝牙来实现。请连接PHYTEC以获得更多信息。"

msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L213` or here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L202`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L213` or here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L202`"

msgid "DT configuration for the eMMC interface can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L194` or here:"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L194` 或者这里："

msgid "Device tree configuration for the User I/O configuration can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-eval-01.dtso#L33`"
msgstr "GPIO的设备树配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-eval-01.dtso#L33`"

msgid "General I²C3 bus configuration (e.g. |dt-som|.dtsi): :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L88`"
msgstr "I²C3 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L88`"

msgid "General I²C2 bus configuration for |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L155` or for imx93-phyboard-nash.dts: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L113`"
msgstr "|dt-carrierboard|.dts的I²C2总线DT配置: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L155` 或者 imx93-phyboard-nash.dts:  :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L113`"

#, fuzzy
msgid "DT representation, e.g. in |som| file can be found in our PHYTEC git: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L172`"
msgstr "核心板 phyCORE-|soc| 的设备树可以在PHYTEC git中找到： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phycore-som.dtsi#L172`"

msgid "DT representation for I²C RTCs: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L173` or :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L122`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L173` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L122`\""

msgid "DT representation for USB Host: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L193` or :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L181`"
msgstr "USB Host的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L193` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L181`"

msgid "The device tree representation for RS232 and RS485: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L174`"
msgstr "RS232和RS485的设备树： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L174`"

msgid "Device Tree CAN configuration of |dt-carrierboard|.dts: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L147` or :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L105`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L147` 或者 :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L105`"

msgid "Device Tree Audio configuration: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L62`"
msgstr "|dt-carrierboard|.dts 的设备树 音频 配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin.dts#L62`"

msgid "Device Tree Audio configuration: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso#L56`"
msgstr "音频的设备树配置： :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso#L56`"

msgid "The device tree of PEB-AV-02 can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-av-02.dtso`"
msgstr "PEB-AV-02的设备树配置：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-segin-peb-av-02.dtso`"

msgid "The device tree of PEB-AV-10 can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso`"
msgstr "PEB-AV-10的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash-peb-av-10.dtso`"

msgid "Device tree TPM configuration can be found here: :linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L151`"
msgstr "TPM的设备树：:linux-phytec-imx:`blob/v6.6.23-2.0.0-phy8/arch/arm64/boot/dts/freescale/imx93-phyboard-nash.dts#L151`"

#, fuzzy
msgid "2025/03/21"
msgstr "2024/06/26"

#, fuzzy
msgid "2025/06/02"
msgstr "2024/06/26"

#, fuzzy
msgid "BSP-Yocto-NXP-i.MX95-ALPHA1"
msgstr "BSP-Yocto-NXP-i.MX93-PD24.1.1"

msgid "Alpha"
msgstr ""

#, fuzzy
msgid "**Libra FPSC Components (top)**"
msgstr "Libra 器件（顶部）"

#, fuzzy
msgid "**Libra FPSC Components (bottom)**"
msgstr "Libra 器件（底部）"

msgid "There is no partup support in imx95 ALPHA1 release yet."
msgstr ""

#, fuzzy
msgid "The image contains all necessary files and makes sure partitions and any raw data are correctly written. The WIC image, which can be flashed using ``dd``, can be downloaded from the `PHYTEC download server <dl-server_>`_."
msgstr "|yocto-imagename| 镜像包含完整系统所需的所有必要文件，您需确保镜像中各个分区以及裸数据都会被正确写入启动盘。可以从 `PHYTEC 下载服务器 <dl-server_>`_ 下载 partup 镜像文件或者是可以使用 ``dd`` 进行烧写的 WIC 镜像。"

#, fuzzy
msgid "Get the WIC image from the download server:"
msgstr "从下载服务器获取WIC文件："

#, fuzzy
msgid "Now, the SD card is ready to be flashed with an image, using either ``dd`` or ``bmap-tools``."
msgstr "现在，SD卡已经准备好可以使用 ``partup`` 、 ``dd`` 或 ``bmap-tools`` 来写入镜像。"

#, fuzzy
msgid "Connect the target and the host with **USB-C** on |ref-debugusbconnector| debug USB"
msgstr "使用 **micro USB** 线将开发板的 |ref-debugusbconnector| 调试USB口和主机连接起来"

#, fuzzy
msgid "**bl31-imx95.bin**: ARM Trusted Firmware binary"
msgstr "**bl31-imx93.bin**: ARM可信固件二进制文件"

#, fuzzy
msgid "**lpddr5_dmem_qb_v202311.bin, lpddr5_dmem_v202311.bin, lpddr5_imem_qb_v202311.bin, lpddr5_imem_v202311.bin**: DDR PHY firmware images"
msgstr "**lpddr4_dmem_1d_v202201.bin, lpddr4_dmem_2d_v202201.bin, lpddr4_imem_1d_v202201.bin, lpddr4_imem_2d_v202201.bin**: DDR PHY 固件镜像"

msgid "**oei-m33-ddr.bin, oei-m33-tcm.bin**: OEI images"
msgstr ""

msgid "**m33_image-mx95libra.bin**: System Manager image"
msgstr ""

#, fuzzy
msgid "**imx95-libra-rdk-fpsc*.dtb**: Kernel device tree file"
msgstr "**imx8mp-libra-rdk-fpsc*.dtb**: 内核设备树文件"

#, fuzzy
msgid "**imx95-phycore-fpsc\\*.dtbo, imx95-libra-rdk-fpsc\\*.dtbo**: Kernel device tree overlay files"
msgstr "**imx93-phy\\*.dtbo**: 内核设备树overlay文件"

#, fuzzy
msgid "Build the imx-boot binary with imx-mkimage"
msgstr "使用 imx-mkimage 编译最终的 flash.bin"

#, fuzzy
msgid "Clone the repository"
msgstr "使用的 U-Boot 仓库："

msgid "First clone the imx-mkimage git repository from NXP."
msgstr ""

msgid "Then get the needed binaries and copy them to the imx-mkimage/iMX95 folder."
msgstr ""

#, fuzzy
msgid "**DDR firmware files** (*mkimage tool* compatible format **lpddr5_[i,d]mem_\\*.bin**): lpddr5_dmem_qb_*.bin, lpddr5_dmem_*.bin, lpddr5_imem_qb_*.bin, lpddr5_imem_*.bin"
msgstr "**DDR firmware files** ( *mkimage 工具* 兼容格式 **lpddr4_[i,d]mem_\\*d_\\*.bin** ): lpddr4_dmem_1d_*.bin, lpddr4_dmem_2d_*.bin, lpddr4_imem_1d_*.bin, lpddr4_imem_2d_*.bin"

#, fuzzy
msgid "**ARM Trusted firmware binary** (*mkimage tool* compatible format **bl31.bin**): bl31.bin"
msgstr "**ARM Trusted firmware 二进制文件** （ *mkimage 工具*  兼容格式 **bl31.bin** ）：bl31-|kernel-socname|.bin"

#, fuzzy
msgid "**OPTEE image**: tee.bin"
msgstr "**OPTEE 镜像** (可选的)：tee.bin"

msgid "**NXP Systemmanager**: m33_image.bin"
msgstr ""

msgid "**OEI-DDR and OEI-TCM**: oei-m33-ddr.bin, oei-m33-tcm.bin"
msgstr ""

#, fuzzy
msgid "**AHAB container image**: mx95a0-ahab-container.img"
msgstr "**容器镜像**：mx93a1-ahab-container.img"

#, fuzzy
msgid "If you already built our BSP with Yocto, you can get the binaries from the directory mentioned here: |ref-bsp-images|"
msgstr "如果您已经使用Yocto编译了我们的BSP，您可以从此处提到的目录中获取这些文件：|ref-bsp-images|"

msgid "Also copy the **U-Boot** (u-boot.bin) and **U-Boot SPL** (u-boot-spl.bin) binaries from your U-Boot folder. The SPL binary is located in the spl subfolder."
msgstr ""

#, fuzzy
msgid "Build the flash.bin binary"
msgstr "编译最终的 flash.bin 二进制文件"

msgid "Go to the imx-mkimage folder and execute:"
msgstr ""

msgid "The flash.bin can be found in the iMX95 subfolder."
msgstr ""

#, fuzzy
msgid "The following is an example of the pin muxing of the lpuart7 device in |dt-som|.dtsi:"
msgstr "以下是 |dt-carrierboard|.dts中UART1设备的引脚复用示例："

#, fuzzy
msgid "The first part of the string IMX95_PAD_GPIO_IO37__LPUART7_RX names the pad (in this example IMX95_PAD_GPIO_IO37). The second part of the string (LPUART7_RX) is the desired muxing option for this pad. The pad setting value (hex value on the right) defines different modes of the pad, for example, if internal pull resistors are activated or not. In this case, the internal resistors are enabled."
msgstr "字符串的第一部分 MX93_PAD_UART1_RXD__LPUART1_RX 指定了引脚（在这个例子中是 UART1_RXD）。字符串的第二部分（LPUART1_RX）是该引脚的期望复用选项。引脚设置值（右侧的十六进制值）定义了引脚的不同模式，例如，内部上拉电阻是否被激活。在当前情况下，内部上拉电阻被激活。"

#, fuzzy
msgid "The device tree representation for UART1 pinmuxing: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L438`"
msgstr "UART1引脚复用的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L373`"

#, fuzzy
msgid "|sbc|-|soc| provides three ethernet interfaces. A gigabit Ethernet is provided by our module and board. Additionally there is a 10Gbit Ethernet. Currently only the one Gigabit Ethernet ports are supported (ETH0 and ETH1)."
msgstr "|sbc|-|soc| 提供两个以太网接口。我们的核心板和底板各提供一个千兆以太网接口。"

#, fuzzy
msgid "DT configuration for the MMC (SD card slot) interface can be found here: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L632`"
msgstr "MMC（SD卡插槽）接口的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L422`"

#, fuzzy
msgid "DT configuration for the eMMC interface can be found here: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L619`"
msgstr "eMMC接口的DT配置：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L214`"

#, fuzzy
msgid "General I²C bus configuration from SoM (e.g. |dt-som|.dtsi): :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L117`"
msgstr "I²C1 总线DT配置（例如 |dt-som|.dtsi）： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L113`"

#, fuzzy
msgid "General I²C bus configuration from carrierboard (e.g. |dt-carrierboard|.dts) :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-libra-rdk-fpsc.dts#L166`"
msgstr "I²C2总线DT配置（例如 |dt-carrierboard|.dts）： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L239`"

msgid "The system features three I2C EEPROM devices distributed across the SoM and carrier board:"
msgstr ""

msgid "On the |som| SoM:"
msgstr ""

msgid "Board Detection EEPROM (write-protected)"
msgstr ""

msgid "Bus: I2C-0"
msgstr ""

msgid "Address: 0x51"
msgstr ""

msgid "Purpose: Factory configuration for board identification"
msgstr ""

#, fuzzy
msgid "User EEPROM"
msgstr "EEPROM"

msgid "Address: 0x50"
msgstr ""

msgid "Purpose: Available for user applications"
msgstr ""

#, fuzzy
msgid "Device Tree Reference for SoM EEPROMs: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L125`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L208`"

msgid "And on the |sbc| carrier board:"
msgstr ""

msgid "Board Detection EEPROM"
msgstr ""

msgid "Bus: I2C-4"
msgstr ""

msgid "Purpose: Reserved for carrier board identification"
msgstr ""

#, fuzzy
msgid "Device Tree Reference for Carrier Board: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-libra-rdk-fpsc.dts#L231`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L203`"

#, fuzzy
msgid "DT representation for I²C RTCs: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-phycore-fpsc.dtsi#L139`"
msgstr "I²C RTCs 的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phycore-som.dtsi#L208`"

#, fuzzy
msgid "And the addions on the carrierboard: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-libra-rdk-fpsc.dts#L292`"
msgstr "|dt-carrierboard|.dts 的设备树 CAN 配置： :linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L203`"

#, fuzzy
msgid "DT representation for USB Host: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-libra-rdk-fpsc.dts#L383`"
msgstr "USB Host的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L380`"

msgid "The |sbc| supports up to 3 different display outputs. The following table shows the required extensions and devicetree overlays for the different interfaces. For the alpha release, we have included overlays for two different LVDS displays. These displays are ``edt,etml1010g3dra`` or ``powertip,ph128800t006-zhc01``. The name can be found on the back of the display."
msgstr ""

msgid "Currently only LVDS0 (onboard LVDS) is supported"
msgstr ""

msgid "imx95-libra-rdk-fpsc-lvds-etml1010g3dra.dtbo imx95-libra-rdk-fpsc-lvds-ph128800t006-zhc01.dtbo"
msgstr ""

msgid "The default interface is LVDS0 (onboard LVDS)."
msgstr ""

#, fuzzy
msgid "In our BSP, the default Weston output is set to LVDS-1 (onboard LVDS)."
msgstr "在我们的BSP中，默认的Weston输出设置为HDMI。"

#, fuzzy
msgid "Device tree description of LVDS-0 can be found here: :linux-phytec-imx:`tree/v6.6.52-2.2.0-phy13/arch/arm64/boot/dts/freescale/imx95-libra-rdk-fpsc-lvds.dtsi#L35`"
msgstr "GPIO风扇的设备树：:linux-phytec-imx:`tree/v6.6.23-2.0.0-phy10/arch/arm64/boot/dts/freescale/imx8mp-phyboard-pollux-rdk.dts#L35`"

msgid "There is no Thermal Management support in the first ALPHA release for the i.MX95 in U-Boot."
msgstr ""

#, fuzzy
msgid "This section describes how the thermal management kernel API is used for the |soc| SoC platform."
msgstr "本节描述了如何在 |soc| SoC 平台上使用热管理内核 API。 |socfamily| 具有用于 SoC 的内部温度传感器。"

msgid "There are nine temperature sensors on the SoM that are readable from Linux. The |socfamily| has two internal temperature sensors for the SoC. Three internal sensors for the PMICs and four I²C temperature sensors located close to DRAM, eMMC, ethernet PHY and PMIC."
msgstr ""

#, fuzzy
msgid "The current temperatures of the system can be read in milli celsius over"
msgstr "当前温度可以以毫摄氏度为单位读取："

msgid "The PMIC temperature sensors return only the last triggered threshold values and not the actual temperature values. The thresholds are 110°C, 125°C, 140°C and 155°C. All temperatures lower than 110°C are shown as 105°C as seen in the example."
msgstr ""

#, fuzzy
msgid "There are two trip points registered in the device tree. These may differ depending on the CPU variant. A distinction is made between Commercial, Industrial and Extended Industrial. For the ALPHA1 i.MX95 release there is only the Automotive/Extended Industrial temperature range available."
msgstr "imx_thermal内核驱动注册了两个温度阈值。这些阈值根据CPU型号的不同而有所区别。包括商业级、工业级和扩展工业级。"

msgid "trip point"
msgstr ""

#, fuzzy
msgid "105°C"
msgstr "120°C"

#, fuzzy
msgid "125°C"
msgstr "120°C"

msgid "If the value of the SoC temperature in the sysfs file temp reaches *trip_point_1* (critical), the board immediately shuts down to avoid any heat damage."
msgstr ""

msgid "NXP GoPoint demo suite"
msgstr ""

msgid "NXP provides demos for their EVK SBCs. They are bundled in a demo suite called GoPoint. It is advertised as"
msgstr ""

msgid "\"GoPoint for i.MX Applications Processors is for users who are interested in showcasing the various features and capabilities of NXP provided SoCs. The demos included in this application are meant to be easy to run for users of all skill levels, making complex use cases accessible to anyone. Users need some knowledge when setting up equipment on Evaluation Kits (EVKs), such as changing Device Tree Blob (DTB) files.\""
msgstr ""

msgid "`GoPoint for i.MX Applications Processors User Guide <gpntug_>`_"
msgstr ""

msgid "Since most of the demos require different accessory hardware to be connected to the SBC to function properly, the list of required hardware will be presented within each demo section."
msgstr ""

msgid "ML Benchmark"
msgstr ""

msgid "ML Benchmark tool allows to easily compare the performance of TensorFlow Lite models running on CPU (Cortex-A) and NPU, without the need to type in any command."
msgstr ""

msgid "`NXP ML benchmark tool <ml-benchmark_>`_"
msgstr ""

msgid "Note that NXP supplies instructions to run the demo as well. For completeness, references will be supplied."
msgstr ""

msgid "Prerequisites"
msgstr ""

msgid "To be able to run the ML Benchmark demo application, you will need the following:"
msgstr ""

msgid "Yocto Project setup with the PHYTEC BSP being built"
msgstr ""

msgid "Ethernet cable, board connected to the internet"
msgstr ""

msgid "Display for any of the supported SoCs PHYTEC SBCs"
msgstr ""

msgid "Console connection to the SBC from host PC"
msgstr ""

msgid "Yocto Project"
msgstr ""

msgid "Modifications in the Yocto Project are necessary as PHYTEC BSPs do not have the GoPoint suite included by default. Add the following to your local.conf::"
msgstr ""

msgid "Adding this causes the gopoint scripts/ui and the backend ml libraries to be installed, respectively. Build the phytec-qt6demo-image::"
msgstr ""

#, fuzzy
msgid "and flash the Image to the board."
msgstr "将镜像写入SD卡"

#, fuzzy
msgid "Ethernet"
msgstr "ethernet1 = eth0"

msgid "Connect an Ethernet cable to the SBC or make otherwise sure that the SBC has access to the internet. Otherwise the demo application is unable to download a ml model and fails."
msgstr ""

msgid "Connect the Display accompanying the PHYTEC SBC to the SBC. You may also use your own display, however different hardware and/or software may be required. The results for this demo are put out as a graphical UI and when weston is unable to start the demo will not start, either."
msgstr ""

msgid "The accompanying display supports touch. In that case no mouse is necessary. When not using a touch display, a mouse is necessary as you need to click on gui elements."
msgstr ""

msgid "Console"
msgstr ""

msgid "Connect a USB cable from your host PC to the respective port of the SBC."
msgstr ""

#, fuzzy
msgid "Running the demo"
msgstr "使用SDK"

msgid "Boot the board. Ensure the display is working. When using your own display, ensure you have the correct dtbo applied and weston starts. Connect to the SBC via debug console and execute::"
msgstr ""

msgid "This will prompt you for a selection of different demos. Use the arrow keys to select the ML Benchmark demo and press Enter. On the display, a TFLite Benchmarking box should appear. The bottom text within the box should say ``Models are ready for inference``. Click/press on ``RUN BENCHMARKS!``. Sometimes the box may disappear, rerun the ML Benchmark in the terminal. NXP explains this and other issues `here <ml-benchmark_>`_."
msgstr ""

msgid "Quickstart Guide ALPHA1"
msgstr ""

#, fuzzy
msgid "|doc-id| |soc| Quickstart Guide"
msgstr "|doc-id| |soc| BSP手册"

msgid "Quickstart Guide"
msgstr ""

msgid "This Quickstart guide describes the tools and provides the know-how to install and boot the Linux Board Support Package (BSP) for the |kit|."
msgstr ""

msgid "This kit is currently in Alpha Status. There are several topics to keep in mind while working with this kit and guide:"
msgstr ""

msgid "The |som| will go through several functional changes during the Alpha Stage of development. Due to this, this Quickstart guide may change without any prior notice."
msgstr ""

msgid "The |som| has some functionality that is not currently operational. Please be aware of this when working with the Alpha Kit."
msgstr ""

msgid "This Quickstart guide is only for booting and starting the basic functionality of the |som|."
msgstr ""

msgid "Hardware manual for the |som| can be found here: |hardware-manual|_"
msgstr ""

msgid "Yocto Reference Manual for |yocto-codename| can be found here: |yocto-ref-manual|"
msgstr ""

msgid "BSP Manual for |som| can be found here: |bsp-manual|"
msgstr ""

#, fuzzy
msgid "The following manuals will be available in future releases of the |som|:"
msgstr "下表是 |soc| SoC的偏移量："

msgid "Pin Muxing Table - a complete list of all signal chains from processor to carrier board output. Signal level, signal type, and other useful information is also included."
msgstr ""

msgid "For more information or details regarding the |som|, please contact the PHYTEC Sales department."
msgstr ""

msgid "Requirements"
msgstr ""

msgid "Included in the Kit"
msgstr ""

msgid "Alpha phyCORE-i.MX 95 FPSC SOM on Alpha Libra Development Board (PD-05032-ALPHA.A0)"
msgstr ""

msgid "Power adapter supplying 24 V / 3,75 A (SV071)"
msgstr ""

msgid "Ethernet cable (WK114)"
msgstr ""

msgid "USB-A to USB-C cable (WK560)"
msgstr ""

msgid "SD Card with prepared prebuilt images"
msgstr ""

msgid "2.54 10P to DB9P Female (WF072)"
msgstr ""

msgid "2 x 2.54 10P to DB9P Male (WF228)"
msgstr ""

#, fuzzy
msgid "Components"
msgstr "|sbc| 器件"

msgid "As this is an Alpha Kit, there will be continuous revisions being made to the |som| SoM and |sbc| board. Due to this, components and features may not be available. Contact PHYTEC if there any questions regarding components and features for this Alpha Kit. To see which components are currently functional, refer to the |som| release notes."
msgstr ""

msgid "Additional (optional) equipment (not included in Alpha Kit)"
msgstr ""

msgid "Display (KLCD-AC209-IMX95)"
msgstr ""

msgid "Embedded Imaging Kit (KPB-xxxx-Video-L01, KPB-xxxx-Video-L02)"
msgstr ""

msgid "Linux Host PC"
msgstr ""

msgid "Before you can work with the |som| Board Support Package (BSP), you will need a host PC with the following minimum requirements:"
msgstr ""

msgid "A modern Linux operating host system either natively or via a virtual machine."
msgstr ""

msgid "Ubuntu 22.04 LTS 64-bit recommended. Other distributions will likely work but note that some setup information as well as OS-specific commands and paths may differ."
msgstr ""

msgid "VMWare Workstation, VMWare Player, and VirtualBox are possible solutions if you want to use a virtual machine."
msgstr ""

msgid "Root access to your Linux host PC. Some commands in this guide will not work if you do not have sudo access (e.g. package installation, formatting an SD card)."
msgstr ""

msgid "At least 40 GB to 50 GB of free space on the build partition of the host PC."
msgstr ""

msgid "An SD card reader, operational under Linux."
msgstr ""

msgid "An active internet connection."
msgstr ""

#, fuzzy
msgid "Connecting the Board"
msgstr "给开发板通电"

msgid "There a few manual connections that you will need to make before using the |sbc|."
msgstr ""

msgid "Connecting the DEBUG USB interface"
msgstr ""

msgid "For the following steps, a console connection via USB is required. You can use the included USB Type-A to USB Type-C cable."
msgstr ""

msgid "For convenience, we have added a board UART to USB converter. This means, no RS232 interface is required during development for console communication between our carrier board and your host PC."
msgstr ""

msgid "Connect your PC's USB port with the USB-C connector of the |sbc| (X14). After plugging the USB-C cable into X14 a red LED (D12) will light up to indicate a present USB bus voltage."
msgstr ""

msgid "Your device manager will show four new COM ports. Select the first COM port. On the processor side, UART3 is the default debug UART of the A55 Cores. The second COM port is the debug UART for the M7 core. This equals to UART4 on the processor side."
msgstr ""

msgid "Do not open the third or fourth COM port in a terminal program! With the third COM port a reset of the board can be triggered. With the fourth COM port the bootmodes can be set. Opening these COM ports can lead to boards not booting. This feature is not fully functional yet."
msgstr ""

msgid "Setup your Terminal with the following parameters:"
msgstr ""

msgid "Speed: 115200 baud"
msgstr ""

msgid "Data bits: 8"
msgstr ""

msgid "Stop bits: 1"
msgstr ""

msgid "Parity: None"
msgstr ""

msgid "Flow control: None"
msgstr ""

#, fuzzy
msgid "Powering the Board"
msgstr "给开发板通电"

msgid "We recommend powering the |sbc| with the power supply (SV055) included in the kit. Connect the power supply to the Power-In connector (X8)."
msgstr ""

msgid "If you are using a power adapter other than the one provided, please note the polarity of the power component X8. Ensure that your power adapter is correctly set up to use the polarity as shown below."
msgstr ""

msgid "It is possible to power the |sbc| with a USB-PD (USB power-delivery) supply instead of the power supply SV055. Connect a conform USB-PD supply to USB-C connector X2 right next to Power-In connector X8."
msgstr ""

msgid "Do not power the |sbc| via USB Power-In (X2) and Power-In (X8) at the same time."
msgstr ""

msgid "Be aware that as soon as the |sbc| is supplied with power, the SD Card boot sequence will begin. Ensure that all cables are connected to the board!"
msgstr ""

#, fuzzy
msgid "Prebuilt Images"
msgstr "获取镜像"

msgid "PHYTEC provides prebuild images and release notes for the |som|. They can be downloaded here: |link-bsp-images|"
msgstr ""

msgid "There are three images available phytec-qt6demo-image, phytec-headless-image and phytec-vision-image."
msgstr ""

msgid "System Booting"
msgstr ""

msgid "The |kit| is shipped with a pre-flashed SD card. It contains the |yocto-imagename| and can be used directly as a boot source."
msgstr ""

msgid "The Quickstart guide will only describe how to boot from the pre-flashed SD card. How to build the BSP yourself, flash your own SD card or boot from other bootsources like eMMC is described in the |bsp-manual|."
msgstr ""

#, fuzzy
msgid "Boot with SD-Card"
msgstr "挂载SD卡："

#, fuzzy
msgid "To boot from an SD card, the bootmode switch (S1) needs to be set to the following position:"
msgstr "要从SD卡启动， |ref-bootswitch| 需要设置为以下位置："

#, fuzzy
msgid "Connect the target and the host with **USB-C** on (X14) debug USB"
msgstr "使用 **micro USB** 线将开发板的 |ref-debugusbconnector| 调试USB口和主机连接起来"

#~ msgid "Build imx-boot"
#~ msgstr "编译 imx-boot"

#~ msgid "To build the imx-boot, you need to **copy** these **files** to your |u-boot-repo-name| **build directory** and rename them to fit with *mkimage tool* script:"
#~ msgstr "要编译imx-boot，您需要将这些 **文件复制** 到您的 |u-boot-repo-name|  **编译目录** 中，并将它们重命名以适配 *mkimage tool* 脚本："

#~ msgid "If you already build our BSP with Yocto, you can get the bl31-|kernel-socname|.bin, tee.bin and lpddr4_*.bin from the directory mentioned here: |ref-bsp-images|"
#~ msgstr "如果您已经使用Yocto编译了我们的BSP，您可以从此处提到的目录中获取bl31-|kernel-socname|.bin、tee.bin和lpddr4_*.bin： |ref-bsp-images|"

#~ msgid "Build U-Boot"
#~ msgstr "编译 U-Boot"

#~ msgid "Copy all binaries into the U-Boot build directory"
#~ msgstr "将所有二进制文件复制到U-Boot编译目录中"

#~ msgid "Build Kernel"
#~ msgstr "编译内核"

#~ msgid "Choose the correct RAM size as populated on the board and uncomment the line for this ram size. When not specifying the ``CONFIG_PHYCORE_IMX8MP_RAM_FREQ_FIX`` option, the 1.5GHz timings will be chosen by default. After saving the changes, follow the remaining steps from |ref-build-uboot|."
#~ msgstr "选择板上已贴装的正确RAM大小，并取消注释该RAM大小的行。当未指定 ``CONFIG_PHYCORE_IMX8MP_RAM_FREQ_FIX`` 选项时，将默认选择1.5GHz的频率。保存更改后，请按照|ref-build-uboot| 中的剩余步骤进行操作。"

#~ msgid "For dual display in dual view mode at HDMI and LVDS0 (PEB-AV-10), both modes have to be set to current:"
#~ msgstr "在HDMI和LVDS0（PEB-AV-10）的双屏模式下进行双显示时，两个模式必须设置为current："

#~ msgid "In order to activate the driver, follow the instructions from our Yocto manual: `Kernel and Bootloader Configuration <https://phytec.github.io/doc-bsp-yocto/yocto/kirkstone.html#kernel-and-bootloader-configuration>`__ "
#~ msgstr "为了激活驱动程序，请按照我们的Yocto手册中的说明进行操作： `内核和引导加载程序配置 <https://phytec.github.io/doc-bsp-yocto/yocto/kirkstone.html#kernel-and-bootloader-configuration>`__ "

#~ msgid "or check |ref-disable-emmc-part| from Linux."
#~ msgstr "或在Linux环境中关闭boot分区引导功能 |ref-disable-emmc-part|。"

#~ msgid "Bootloader Filename"
#~ msgstr "bootloader文件名"

#~ msgid "imx-boot"
#~ msgstr "imx-boot"

#~ msgid "Device Tree PCIe configuration of |dt-carrierboard|.dts: :imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n257`"
#~ msgstr "|dt-carrierboard|.dts的设备树PCIe配置：:imx-dt:`imx8mm-phyboard-polis-rdk.dts?h=v5.15.71_2.2.2-phy3#n257`"

