Reference
=========

Boot Logic Implementation
-------------------------

.. tip::

   The implementation details described in this chapter serve as a reference
   guide. PHYTEC BSPs that have RAUC support include these by default and the
   changes are already incorporated.

U-Boot standard boot
....................

For U-Boot, the boot logic that selects the correct partitions to boot from is
implemented using `U-Boot's standard boot
<https://docs.u-boot.org/en/latest/develop/bootstd/overview.html>`_. Only the
RAUC-specific variables are saved in U-Boot's environment and should not need to
be modified.

+-----------------------+--------------------------------------------------------+
| Name                  | Function                                               |
+=======================+========================================================+
| ``BOOT_ORDER``        | Contains a space-separated list of boot targets in the |
|                       | order they should be tried. This parameter is          |
|                       | automatically set by RAUC.                             |
+-----------------------+--------------------------------------------------------+
| ``BOOT_system0_LEFT`` | Contains the number of remaining boot attempts to      |
| ``BOOT_system1_LEFT`` | perform for the respective slot. This parameter is     |
|                       | automatically set by RAUC.                             |
+-----------------------+--------------------------------------------------------+

Barebox Bootchooser Framework
.............................

For the barebox, the boot logic that selects the correct partitions to boot from
is implemented using the bootchooser and state framework. See the barebox
documentation for detailed information about these: `Barebox Bootchooser
Framework <https://www.barebox.org/doc/latest/user/bootchooser.html>`_, `Barebox
State Framework <https://www.barebox.org/doc/latest/user/state.html>`_.

First, the state framework configuration needs to be added to the barebox device
tree. Check out the |ref-yocto-bsp-customization|
chapter in the Yocto reference manual. The state framework configuration is
already included with our BSP for the supported SoC and can be directly included
in the main barebox device tree. E.g. for i.MX6 based module:

.. code-block:: devicetree

   #include "imx6qdl-phytec-state.dtsi"

Afterward, rebuild the image and flash the new bootloader.

.. warning::

   Be aware that by adding the state framework configuration, the first 160
   bytes of the EEPROM are occupied and can no longer be used for user-specific
   purposes.

The following device tree snippet shows an example of the state framework
configuration used with the BSP. As can be seen, the EEPROM is used as a backend
for the state information:

.. code-block:: devicetree

   / {
       aliases {
           state = &state;
       };

       state: imx6qdl_phytec_boot_state {
           magic = <0x883b86a6>;
           compatible = "barebox,state";
           backend-type = "raw";
           backend = <&backend_update_eeprom>;
           backend-stridesize = <54>;

           #address-cells = <1>;
           #size-cells = <1>;
           bootstate {
               #address-cells = <1>;
               #size-cells = <1>;
               last_chosen {
                   reg = <0x0 0x4>;
                   type = "uint32";
               };
               system0 {
                   #address-cells = <1>;
                   #size-cells = <1>;
                   remaining_attempts {
                       reg = <0x4 0x4>;
                       type = "uint32";
                       default = <3>;
                   };
                   priority {
                       reg = <0x8 0x4>;
                       type = "uint32";
                       default = <21>;
                   };
                   ok {
                       reg = <0xc 0x4>;
                       type = "uint32";
                       default = <0>;
                   };
               };
               system1 {
                   #address-cells = <1>;
                   #size-cells = <1>;
                   remaining_attempts {
                       reg = <0x10 0x4>;
                       type = "uint32";
                       default = <3>;
                   };
                   priority {
                       reg = <0x14 0x4>;
                       type = "uint32";
                       default = <20>;
                   };
                   ok {
                       reg = <0x18 0x4>;
                       type = "uint32";
                       default = <0>;
                   };
               };
           };
       };
   };

   &eeprom {
       status = "okay";
       partitions {
           compatible = "fixed-partitions";
           #size-cells = <1>;
           #address-cells = <1>;
           backend_update_eeprom: state@0 {
               reg = <0x0 0x100>;
               label = "update-eeprom";
           };
       };
   };

To be able to boot from two systems alternately, the bootchooser needs to be
aware of the state framework configuration. For each system, a boot script is
required. For a system with NAND flash, the boot script of the first system may
look like the following:

.. code-block:: sh
   :caption: /env/boot/system0

   #!/bin/sh

   [ -e /env/config-expansions ] && /env/config-expansions

   [ ! -e /dev/nand0.root.ubi ] && ubiattach /dev/nand0.root

   global.bootm.image="/dev/nand0.root.ubi.kernel0"
   global.bootm.oftree="/dev/nand0.root.ubi.oftree0"
   global.linux.bootargs.dyn.root="root=ubi0:root0 ubi.mtd=root rootfstype=ubifs"

The second boot script has the same structure but uses the partitions containing
the second system. Machines with eMMC flash use similar boot scripts, albeit the
mounting and boot arguments look different.

Run the following commands to create the required bootchooser non-volatile
environment variables:

.. code-block::

   barebox$ nv bootchooser.state_prefix=state.bootstate
   barebox$ nv bootchooser.system0.boot=system0
   barebox$ nv bootchooser.system1.boot=system1
   barebox$ nv bootchooser.targets="system0 system1"

eMMC Boot Partitions
--------------------

With eMMC flash storage it is possible to use the dedicated boot partitions for
redundantly storing the bootloader.

By default, bundles built with our BSP (e.g. ``phytec-headless-bundle``) contain
the bootloader for updating eMMC boot partitions accordingly.

Note, that the U-Boot environment still resides in the user area before the
first partition. The user area also still contains the bootloader which the
image first shipped during its initialization process.

To manually write the bootloader to the eMMC boot partitions, first disable the
write protection:

.. code-block:: console

   target:~$ echo 0 > /sys/block/mmcblk2boot0/force_ro
   target:~$ echo 0 > /sys/block/mmcblk2boot1/force_ro

Write the bootloader to the eMMC boot partitions:

.. code-block:: console

   target:~$ dd if=imx-boot of=/dev/mmcblk2boot0 bs=1k seek=33
   target:~$ dd if=imx-boot of=/dev/mmcblk2boot1 bs=1k seek=33

This example is valid for the i.MX 8M Mini SoC. Note, that other SoCs may have
different bootloader files and require different offsets where the bootloader is
expected, specified by the seek parameter. See the following table for the
different offsets being required by each SoC:

+--------------+------------------+-----------------------+--------------+-------------+
| SoC          | Offset User Area | Offset Boot Partition | eMMC Device  | Bootloader  |
+==============+==================+=======================+==============+=============+
| i.MX 6       | 1 kiB            | 0 kiB                 | /dev/mmcblk3 | barebox.bin |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 6UL     | 1 kiB            | 0 kiB                 | /dev/mmcblk1 | barebox.bin |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 8M      | 33 kiB           | 33 kiB                | /dev/mmcblk0 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 8M Mini | 33 kiB           | 33 kiB                | /dev/mmcblk2 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 8M Nano | 32 kiB           | 0 kiB                 | /dev/mmcblk2 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 8M Plus | 32 kiB           | 0 kiB                 | /dev/mmcblk2 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 91      | 32 kiB           | 0 kiB                 | /dev/mmcblk0 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 93      | 32 kiB           | 0 kiB                 | /dev/mmcblk0 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| i.MX 95      | 32 kiB           | 0 kiB                 | /dev/mmcblk0 | imx-boot    |
+--------------+------------------+-----------------------+--------------+-------------+
| AM62x        | N/A              | 0 kiB                 | /dev/mmcblk0 | tiboot3.bin |
| AM62Ax       |                  | 512 kiB               |              | tispl.bin   |
| AM64x        |                  | 2560 kiB              |              | u-boot.img  |
+--------------+------------------+-----------------------+--------------+-------------+

Bootloader Offsets
..................

Note that the offset is different, depending on whether the bootloader resides
in the user area or the boot partitions of the eMMC.

After a bootloader has been written to the eMMC boot partitions, booting from
these can be enabled by using the following command:

.. code-block:: console

   target:~$ mmc bootpart enable 1 0 /dev/mmcblk2

This also means that only the bootloaders written in the eMMC boot partitions
are used. The bootloader in the user area is not used anymore. These steps are
also executed by RAUC internally when updating the target system with a bundle.

To disable booting from the eMMC boot partitions simply enter the following
command:

.. code-block:: console

   target:~$ mmc bootpart enable 0 0 /dev/mmcblk2

After this command, the eMMC user area is used to provide the bootloader.

When using U-Boot, a similar command is also available in the bootloader:

.. code-block::

   u-boot=> mmc partconf 2 0 0 0  # disable
   u-boot=> mmc partconf 2 0 1 0  # enable
